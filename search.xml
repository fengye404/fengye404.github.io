<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OSPP参与记录</title>
      <link href="/2024/09/29/OSPP%E5%8F%82%E4%B8%8E%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/09/29/OSPP%E5%8F%82%E4%B8%8E%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今年毕业前申请参与了2024年的开源之夏（OSPP），是一次很宝贵的开源项目经验，最终成功结项。写这篇博客以此记录留存。</p><hr><h1 id="项目申请书"><a href="#项目申请书" class="headerlink" title="项目申请书"></a>项目申请书</h1><center>项目名称：探索 Java 低资源消耗的 gRPC 实现</center><center>项目主导师：断岭</center><center>申请人：风业</center><center>日期：2024.06.03</center><center>邮箱：1129126684@qq.com</center><hr><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>Arthas 是一个 Java 诊断工具，它允许开发人员在无需修改应用程序代码的情况下，动态地监视和解决生产环境中 Java 应用程序的问题。目前 Arthas 主要是通过交互式的命令行提供服务，此外也提供了 http api。但是 http api 比较简陋，预期通过grpc server提供服务。但是官方的 grpc 实现依赖多、运行时内存占用高，本项目旨在提供一种低资源消耗的 grpc 实现，需要支持 stream 并尽量减少外部依赖。</p><h2 id="项目主要内容"><a href="#项目主要内容" class="headerlink" title="项目主要内容"></a>项目主要内容</h2><ol><li>实现低资源消耗的 grpc 协议，需要尽量减少外部依赖，并支持双向 stream。</li><li>基于上述 grpc 协议，提供一个简单的Arthas服务的实现，比如查看Jvm System Properties。</li><li>实现 protobuf 的编译代码生成器，优先级不高，先用官方的生成代码也可以接受。</li></ol><h2 id="项目相关文档"><a href="#项目相关文档" class="headerlink" title="项目相关文档"></a>项目相关文档</h2><ul><li>github issue地址：<a href="https://github.com/alibaba/arthas/issues/2349">https://github.com/alibaba/arthas/issues/2349</a></li><li>arthas 官方文档：<a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>其他开源 grpc 实现参考：</p><ul><li>dubbo 的 triple 实现：<a href="https://github.com/apache/dubbo/tree/3.2/dubbo-rpc/dubbo-rpc-triple">https://github.com/apache/dubbo/tree/3.2/dubbo-rpc/dubbo-rpc-triple</a></li><li>armeria 的 grpc 实现：<a href="https://armeria.dev/docs/server-grpc">https://armeria.dev/docs/server-grpc</a></li><li>wire 的 grpc 实现：<a href="https://github.com/square/wire">https://github.com/square/wire</a></li></ul><hr><h2 id="项目方案概述"><a href="#项目方案概述" class="headerlink" title="项目方案概述"></a>项目方案概述</h2><p>参考各开源项目的 grpc 实现后，本项目方案设计如下：</p><ol><li>服务端和客户端使用 protobuf 作为IDL</li><li>客户端实现可以由用户自行决定，只要符合官方 grpc 协议即可，例如可以参考 grpc-java 官方的 client 请求实例</li><li>服务端不依赖 netty java 的官方实现（即 grpc-netty），因此需要实现两个部分<ol><li>stub 接口代码生成：参考 wire，读取 protobuf 后手动实现（可选，前期可以先手动写服务端的 stub 接口）</li><li>grpc 实现：参考 grpc-netty 官方实现，主要涉及对 http2 frame 的操作</li></ol></li></ol><h3 id="stub-代码生成"><a href="#stub-代码生成" class="headerlink" title="stub 代码生成"></a>stub 代码生成</h3><p>此操作在编译期完成，预计需要在编译期依赖 wire 读取 protobuf schema，然后手动拼接文件。</p><p>参考 opentelemetry-java 中关于生成 stub 接口代码的实现：<a href="https://github.com/open-telemetry/opentelemetry-java/blob/v1.22.0/buildSrc/src/main/kotlin/io/opentelemetry/gradle/ProtoFieldsWireHandler.kt">https://github.com/open-telemetry/opentelemetry-java/blob/v1.22.0/buildSrc/src/main/kotlin/io/opentelemetry/gradle/ProtoFieldsWireHandler.kt</a></p><p>可以使用 maven-compiler-plugin 来指定 maven 编译期间执行上述生成过程。</p><h3 id="gprc-实现"><a href="#gprc-实现" class="headerlink" title="gprc  实现"></a>gprc  实现</h3><p>grpc 的实现参考 grpc-netty 的实现。grpc 本质上是 http2。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/9895e16be720641411c9b27b46276724.png" alt="img"></p><p>要实现 grpc，就需要实现 netty 中处理 http2 请求的一些组件：</p><ul><li><strong>Http2ConnectionDecoder</strong>：<ul><li>负责解析 HTTP&#x2F;2 帧，并将它们转换为 gRPC 消息。</li><li>通常位于 Netty 的 <code>ChannelPipeline</code> 中，用于处理接收到的 HTTP&#x2F;2 帧。</li></ul></li><li><strong>Http2ConnectionHandler</strong>：<ul><li>负责处理 gRPC 消息，包括序列化和反序列化。</li><li>通常位于 Netty 的 <code>ChannelPipeline</code> 中，用于处理 gRPC 消息。</li></ul></li><li><strong>Http2ConnectionListener</strong>：<ul><li>负责处理 HTTP&#x2F;2 连接的生命周期事件，如设置和更改流状态。</li><li>通常位于 Netty 的 <code>ChannelPipeline</code> 中，用于处理 HTTP&#x2F;2 连接的状态变化。</li></ul></li></ul><p>参考 grpc-netty 的实现，其中就实现了这些组件。</p><p>以读取 data frame 为例，grpc-netty 中通过 io.grpc.netty.NettyServerHandler.FrameListener 实现了 io.netty.handler.codec.http2.Http2FrameAdapter，其中的 onDataRead 方法就会在读取 data frame 时触发，其简略代码如下：</p><p>io.grpc.netty.NettyServerHandler#onDataRead</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onDataRead</span><span class="params">(<span class="type">int</span> streamId, ByteBuf data, <span class="type">int</span> padding, <span class="type">boolean</span> endOfStream)</span></span><br><span class="line">    <span class="keyword">throws</span> Http2Exception &#123;</span><br><span class="line">    ...</span><br><span class="line">    flowControlPing().onDataRead(data.readableBytes(), padding);</span><br><span class="line">    NettyServerStream.<span class="type">TransportState</span> <span class="variable">stream</span> <span class="operator">=</span> serverStream(requireHttp2Stream(streamId));</span><br><span class="line">    stream.inboundDataReceived(data, endOfStream);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>io.grpc.internal.AbstractServerStream.TransportState#inboundDataReceived</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inboundDataReceived</span><span class="params">(ReadableBuffer frame, <span class="type">boolean</span> endOfStream)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    deframe(frame);</span><br><span class="line">    <span class="keyword">if</span> (endOfStream) &#123;</span><br><span class="line">        <span class="built_in">this</span>.endOfStream = <span class="literal">true</span>;</span><br><span class="line">        closeDeframer(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>io.grpc.internal.AbstractStream.TransportState#deframe</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">deframe</span><span class="params">(<span class="keyword">final</span> ReadableBuffer frame)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deframer.deframe(frame);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        deframeFailed(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>io.grpc.internal.MessageDeframer#deframe</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deframe</span><span class="params">(ReadableBuffer data)</span> &#123;</span><br><span class="line">...</span><br><span class="line">    deliver();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>io.grpc.internal.MessageDeframer#deliver</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deliver</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (!stopDelivery &amp;&amp; pendingDeliveries &gt; <span class="number">0</span> &amp;&amp; readRequiredBytes()) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> BODY:</span><br><span class="line">                processBody();</span><br><span class="line">                pendingDeliveries--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>io.grpc.internal.MessageDeframer#processBody</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processBody</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// There is no reliable way to get the uncompressed size per message when it&#x27;s compressed,</span></span><br><span class="line">    <span class="comment">// because the uncompressed bytes are provided through an InputStream whose total size is</span></span><br><span class="line">    <span class="comment">// unknown until all bytes are read, and we don&#x27;t know when it happens.</span></span><br><span class="line">    statsTraceCtx.inboundMessageRead(currentMessageSeqNo, inboundBodyWireSize, -<span class="number">1</span>);</span><br><span class="line">    inboundBodyWireSize = <span class="number">0</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> compressedFlag ? getCompressedBody() : getUncompressedBody();</span><br><span class="line">    nextFrame = <span class="literal">null</span>;</span><br><span class="line">    listener.messagesAvailable(<span class="keyword">new</span> <span class="title class_">SingleMessageProducer</span>(stream));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done with this frame, begin processing the next header.</span></span><br><span class="line">    state = State.HEADER;</span><br><span class="line">    requiredLength = HEADER_LENGTH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当接收到 data frame 后，grpc 的处理方式是将其放入缓冲区中，最终 data frame 结束后，会调用 <code>processBody()</code> 处理 body：从缓冲区中读出 inputStream，然后触发消息。</p><p>对 http2 frame 的操作可以参考 grpc-netty 实现，本方案主要修改点在于 processBody，需要替换为针对 stub 生成代码的实现，预计会考虑反射调用的处理。</p><p>此外，对于 http2 frame 的操作，netty 还给出了更好的方式，后续可以考虑：<a href="https://netty.io/4.1/api/io/netty/handler/codec/http2/Http2FrameCodecBuilder.html">Http2FrameCodecBuilder (Netty API Reference (4.1.110.Final))</a></p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><ul><li><strong>阶段一：研究 netty 实现 grpc 协议（7.1 - 8.15）</strong><ul><li>第一周：阅读 grpc-netty 源码，了解 netty 对于 http2 的封装。</li><li>第二周、第三周：使用 netty 实现 grpc 协议一元调用。</li><li>第四周：继续参考 grpc-netty 源码，了解双向流、异常处理的实现。</li><li>第五周、第六周：完成 grpc 双向流的实现。</li></ul></li><li><strong>阶段二：研究 stub 代码生成部分（8.15 - 8.30）</strong><ul><li>第一周：阅读 opentelemetry-java 相关实现，了解 protobuf 的 schema、了解 java 代码生成。</li><li>第二周：实现 stub 代码生成。</li></ul></li><li><strong>阶段三：使用 grpc 实现 arthas 中的部分功能（9.1 - 9.15）</strong><ul><li>第一周：阅读 arthas 的相关源码，了解其实现。</li><li>第二周：利用 gprc 实现其中的部分功能。</li></ul></li><li><strong>阶段四：完成结项报告和 pr&#x2F;mr 提交（9.16 - 9.30）</strong><ul><li>第一周：为项目编写 readme 文档，便于后续维护修改。</li><li>第二周：完成结项报告和 pr&#x2F;mr 提交。</li></ul></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这是我第一次参与到大型的开源项目中来，感谢 ospp 提供了这个机会，十分期待能够给开源社区提供贡献，并积累相关经验，学习更多知识。另外我对 arthas 非常感兴趣，平时的日常开发中也经常使用，如果以后有机会，希望能够继续投入到开源社区的工作中，为开源社区做贡献。</p><h1 id="结项报告"><a href="#结项报告" class="headerlink" title="结项报告"></a>结项报告</h1><h2 id="项目信息"><a href="#项目信息" class="headerlink" title="项目信息"></a>项目信息</h2><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>Arthas 是一个 Java 诊断工具，它允许开发人员在无需修改应用程序代码的情况下，动态地监视和解决生产环境中 Java 应用程序的问题。目前 Arthas 主要是通过交互式的命令行提供服务，此外也提供了 http api。但是 http api 比较简陋，预期通过grpc server提供服务。但是官方的 grpc 实现依赖多、运行时内存占用高，本项目旨在提供一种低资源消耗的 grpc 实现，需要支持 stream 并尽量减少外部依赖。</p><p>本项目主要完成了以下内容</p><ol><li>实现低资源消耗的 grpc 协议，需要尽量减少外部依赖，并支持双向 stream。</li><li>实现 protobuf 的序列化和反序列化</li></ol><h3 id="方案描述"><a href="#方案描述" class="headerlink" title="方案描述"></a>方案描述</h3><p>参考各开源项目的 grpc 实现后，本项目方案设计如下：</p><ol><li>服务端和客户端使用 protobuf 作为 IDL</li><li>客户端实现可以由用户自行决定，只要符合官方 grpc 协议即可，例如可以参考 grpc-java 官方的 client 请求实例</li><li>服务端不依赖 netty java 的官方实现（即 grpc-netty），因此需要实现两个部分<ol><li>protobuf 的序列化和反序列化，参考 protobuf</li><li>grpc 的请求处理，包括一元请求和双向流请求，参考 grpc-netty</li></ol></li></ol><h3 id="时间规划"><a href="#时间规划" class="headerlink" title="时间规划"></a>时间规划</h3><ul><li><strong>阶段一：研究 netty 实现 grpc 协议（7.1 - 8.15）</strong><ul><li>第一周：阅读 grpc-netty 源码，了解 netty 对于 http2 的封装。</li><li>第二周、第三周：使用 netty 实现 grpc 协议一元调用。</li><li>第四周：继续参考 grpc-netty 源码，了解双向流、异常处理的实现。</li><li>第五周、第六周：完成 grpc 双向流的实现。</li></ul></li><li><strong>阶段二：研究 stub 代码生成部分（8.15 - 8.30）</strong><ul><li>第一周：阅读 opentelemetry-java 相关实现，了解 protobuf 的 schema、了解 java 代码生成。</li><li>第二周：实现 stub 代码生成。</li></ul></li><li><strong>阶段三：使用 grpc 实现 arthas 中的部分功能（9.1 - 9.15）</strong><ul><li>第一周：阅读 arthas 的相关源码，了解其实现。</li><li>第二周：利用 gprc 实现其中的部分功能。</li></ul></li><li><strong>阶段四：完成结项报告和 pr&#x2F;mr 提交（9.16 - 9.30）</strong><ul><li>第一周：为项目编写 readme 文档，便于后续维护修改。</li><li>第二周：完成结项报告和 pr&#x2F;mr 提交。</li></ul></li></ul><h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度"></a>项目进度</h2><h3 id="已完成工作"><a href="#已完成工作" class="headerlink" title="已完成工作"></a>已完成工作</h3><p>截至930，该项目已完成：</p><ol><li>protobuf 的序列化和反序列化实现及其单元测试</li><li>解析 grpc 协议格式</li><li>netty 实现 grpc 的一元请求和流失请求处理</li></ol><p>本项目未使用除 protobuf 以外的任何外部依赖</p><h3 id="实现记录"><a href="#实现记录" class="headerlink" title="实现记录"></a>实现记录</h3><h4 id="protobuf-序列化"><a href="#protobuf-序列化" class="headerlink" title="protobuf 序列化"></a>protobuf 序列化</h4><p>实现 protobuf 的序列化和反序列化大致有两种思路</p><ol><li>参考 java grpc maven plugin，将解析逻辑实现在生成的 stub 中</li><li>参考 jprotobuf，将解析逻辑实现在运行时</li></ol><p>从本质上来看两种实现方式，其实都是建立 protobuf 字段类型到 java 字段类型的映射，然后处理映射逻辑实现序列化。但是两者实现的方式却不同，【1】是读取 protobuf，在编译期生成 java 代码，java 代码中实现 protobuf 的序列化和反序列化；【2】是根据定义的 java 对象，通过对对象的代理中的逻辑实现 protobuf 序列化和反序列化。</p><p>这两种方式各有优劣：</p><ol><li>逻辑上更符合直觉，但是有两个问题：【1】需要读取 protobuf 定义文件并解析其内容，这方面的库较少，可能需要手动解析；【2】需要处理编译期操作</li><li>类似于 “先射箭后画靶”，需要人工从已知的 protobuf 定义文件中解析内容，然后编写 java 类</li></ol><p>最终采用了方案2，因为成本更低，且有开源库 jprotobuf 参考。</p><p><strong>实现原理</strong></p><ul><li><p>定义 protobuf 到 java 字段类型的映射关系</p></li><li><p>定义代理类模板</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">$&#123;package&#125;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"><span class="comment">&lt;!-- $BeginBlock imports --&gt;</span></span><br><span class="line">import $&#123;importBlock&#125;;</span><br><span class="line"><span class="comment">&lt;!-- $EndBlock imports --&gt;</span></span><br><span class="line"></span><br><span class="line">public class $&#123;className&#125; implements $&#123;codecClassName&#125;&lt;$&#123;targetProxyClassName&#125;&gt;, Serializable &#123;</span><br><span class="line">public static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    public byte[] encode($&#123;targetProxyClassName&#125; target) throws IOException &#123;</span><br><span class="line">        CodedOutputStreamCache outputCache = CodedOutputStreamCache.get();</span><br><span class="line">        doWriteTo(target, outputCache.getCodedOutputStream());</span><br><span class="line">        return outputCache.getData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doWriteTo($&#123;targetProxyClassName&#125; target, CodedOutputStream output)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        <span class="comment">&lt;!-- $BeginBlock encodeFields --&gt;</span></span><br><span class="line">        $&#123;dynamicFieldType&#125; $&#123;dynamicFieldName&#125; = null;</span><br><span class="line">        if (!ProtoBufUtil.isNull($&#123;dynamicFieldGetter&#125;)) &#123;</span><br><span class="line">            $&#123;dynamicFieldName&#125; = $&#123;dynamicFieldGetter&#125;;</span><br><span class="line">            $&#123;encodeWriteFieldValue&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">&lt;!-- $EndBlock encodeFields --&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public $&#123;targetProxyClassName&#125; decode(byte[] bb) throws IOException &#123;</span><br><span class="line">        CodedInputStream input = CodedInputStream.newInstance(bb, 0, bb.length);</span><br><span class="line">        return readFrom(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size($&#123;targetProxyClassName&#125; target) throws IOException &#123;</span><br><span class="line">        int size = 0;</span><br><span class="line">        <span class="comment">&lt;!-- $BeginBlock encodeFields --&gt;</span></span><br><span class="line">        $&#123;dynamicFieldType&#125; $&#123;dynamicFieldName&#125; = null;</span><br><span class="line">        if (!ProtoBufUtil.isNull($&#123;dynamicFieldGetter&#125;)) &#123;</span><br><span class="line">            $&#123;dynamicFieldName&#125; = $&#123;dynamicFieldGetter&#125;;</span><br><span class="line">            size += $&#123;sizeDynamicString&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">&lt;!-- $EndBlock encodeFields --&gt;</span></span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public $&#123;targetProxyClassName&#125; readFrom(CodedInputStream input) throws IOException &#123;</span><br><span class="line">        $&#123;targetProxyClassName&#125; target = new $&#123;targetProxyClassName&#125;();</span><br><span class="line">        </span><br><span class="line">        $&#123;initListMapFields&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- $BeginBlock enumFields --&gt;</span></span><br><span class="line">        $&#123;enumInitialize&#125;;</span><br><span class="line">        <span class="comment">&lt;!-- $EndBlock enumFields --&gt;</span></span><br><span class="line">        try &#123;</span><br><span class="line">            boolean done = false;</span><br><span class="line">            ProtobufCodec codec = null;</span><br><span class="line">            while (!done) &#123;</span><br><span class="line">                int tag = input.readTag();</span><br><span class="line">                if (tag == 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">&lt;!-- $BeginBlock decodeFields --&gt;</span></span><br><span class="line">                if (tag == $&#123;decodeOrder&#125;) &#123;</span><br><span class="line">                    $&#123;objectDecodeExpress&#125;</span><br><span class="line">                    $&#123;decodeFieldSetValue&#125;</span><br><span class="line">                    $&#123;objectDecodeExpressSuffix&#125;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                $&#123;objectPackedDecodeExpress&#125;</span><br><span class="line">                <span class="comment">&lt;!-- $EndBlock decodeFields --&gt;</span>               </span><br><span class="line">                </span><br><span class="line">                input.skipField(tag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (com.google.protobuf.InvalidProtocolBufferException e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; catch (java.io.IOException e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据 protobuf 手动编写对应的 java 类</p></li><li><p>运行时为指定的类实现代理，通过开源库 MiniTemplator 解析并填充内容</p></li></ul><h4 id="http2-格式解析"><a href="#http2-格式解析" class="headerlink" title="http2 格式解析"></a>http2 格式解析</h4><p>grpc 是基于 netty 的，想要实现 grpc 协议，就必须要先解析 http2 协议格式。</p><p>netty 中提供了非常简单的操作 http2 frame 的方式：<a href="https://netty.io/4.1/api/io/netty/handler/codec/http2/Http2FrameCodecBuilder.html">Http2FrameCodecBuilder (Netty API Reference (4.1.110.Final))</a>。</p><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Http2Handler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;Http2Frame&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Http2Frame frame)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (frame <span class="keyword">instanceof</span> Http2HeadersFrame) &#123;</span><br><span class="line">            handleGrpcRequest((Http2HeadersFrame) frame, ctx);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frame <span class="keyword">instanceof</span> Http2DataFrame) &#123;</span><br><span class="line">            handleGrpcData((Http2DataFrame) frame, ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>channelRead0</code> 中，netty 用 Http2Frame 封装了 http2 的 frame，简化了 http2 frame 的解析操作。</p><h4 id="grpc-请求解析"><a href="#grpc-请求解析" class="headerlink" title="grpc 请求解析"></a>grpc 请求解析</h4><p>接收到了 http2Frame 后，需要将其解析为 grpc 请求。</p><blockquote><p><a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md">https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md</a> 定义了 http2 中 grpc 协议的一些基本格式</p></blockquote><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/image-20240929001524840-1735632468022-3.png" alt="image-20240929001524840"></p><p>可以看到 grpc 实际上就是在 http2 的 body 中塞入了一些 grpc 包头和业务数据。那么要解析 grpc 协议，实际上只需要解析 http2 协议，在此基础上解析 grpc 包头即可。</p><p>代码中将 grpc 请求封装为一个类来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrpcRequest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求对应的 streamId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer streamId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求的 service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求的 method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二进制数据，可能包含多个 grpc body，每个 body 都带有 5 个 byte 的前缀，分别是 boolean compressed - int length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuf byteData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二进制数据的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; clazz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是 grpc 流式请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是 grpc 流式请求的第一个data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> streamFirstData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GrpcRequest</span><span class="params">(Integer streamId, String path, String method)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.streamId = streamId;</span><br><span class="line">        <span class="built_in">this</span>.service = path;</span><br><span class="line">        <span class="built_in">this</span>.method = method;</span><br><span class="line">        <span class="built_in">this</span>.byteData = ByteUtil.newByteBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(ByteBuf byteBuf)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = ByteUtil.getBytes(byteBuf);</span><br><span class="line">        <span class="keyword">if</span> (bytes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] decompressedData = decompressGzip(bytes);</span><br><span class="line">        <span class="keyword">if</span> (decompressedData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        byteData.writeBytes(ByteUtil.newByteBuf(decompressedData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取部分数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] readData() &#123;</span><br><span class="line">        <span class="keyword">if</span> (byteData.readableBytes() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">compressed</span> <span class="operator">=</span> byteData.readBoolean();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> byteData.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        byteData.readBytes(bytes);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearData</span><span class="params">()</span> &#123;</span><br><span class="line">        byteData.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] decompressGzip(<span class="type">byte</span>[] compressedData) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isGzip</span> <span class="operator">=</span> (compressedData.length &gt; <span class="number">2</span> &amp;&amp; (compressedData[<span class="number">0</span>] &amp; <span class="number">0xff</span>) == <span class="number">0x1f</span> &amp;&amp; (compressedData[<span class="number">1</span>] &amp; <span class="number">0xff</span>) == <span class="number">0x8b</span>);</span><br><span class="line">        <span class="keyword">if</span> (isGzip) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">byteStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(compressedData);</span><br><span class="line">                <span class="type">GZIPInputStream</span> <span class="variable">gzipStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPInputStream</span>(byteStream);</span><br><span class="line">                <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> len;</span><br><span class="line">                <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">                <span class="keyword">while</span> ((len = gzipStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    out.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Failed to decompress GZIP data: &quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> compressedData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ByteBuf <span class="title function_">decompressGzip</span><span class="params">(ByteBuf byteBuf)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] compressedData = ByteUtil.getBytes(byteBuf);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isGzip</span> <span class="operator">=</span> (compressedData.length &gt; <span class="number">2</span> &amp;&amp; (compressedData[<span class="number">0</span>] &amp; <span class="number">0xff</span>) == <span class="number">0x1f</span> &amp;&amp; (compressedData[<span class="number">1</span>] &amp; <span class="number">0xff</span>) == <span class="number">0x8b</span>);</span><br><span class="line">        <span class="keyword">if</span> (isGzip) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">byteStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(compressedData);</span><br><span class="line">                <span class="type">GZIPInputStream</span> <span class="variable">gzipStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPInputStream</span>(byteStream);</span><br><span class="line">                <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> len;</span><br><span class="line">                <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">                <span class="keyword">while</span> ((len = gzipStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    out.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ByteUtil.newByteBuf(out.toByteArray());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Failed to decompress GZIP data: &quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> byteBuf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="grpc-请求路由调用"><a href="#grpc-请求路由调用" class="headerlink" title="grpc 请求路由调用"></a>grpc 请求路由调用</h4><p>将 grpc 数据读取出来后，配合前面的 protobuf 序列化部分，就可以将请求数据转化为具体的请求对象。</p><p>获取到请求对象后，需要将请求路由到具体的调用方法。</p><p>在一次请求的 http2 header frame 中，用 <code>:path</code> header 值存储了调用的路径，通过路径即可调用到具体的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrpcDispatcher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GRPC_SERVICE_PACKAGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;com.taobao.arthas.grpc.server.service.impl&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, MethodHandle&gt; grpcMethodInvokeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Boolean&gt; grpcMethodStreamMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadGrpcService</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; classes = ReflectUtil.findClasses(GRPC_SERVICE_PACKAGE_NAME);</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(GrpcService.class)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 处理 service</span></span><br><span class="line">                    <span class="type">GrpcService</span> <span class="variable">grpcService</span> <span class="operator">=</span> clazz.getAnnotation(GrpcService.class);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 处理 method</span></span><br><span class="line">                    MethodHandles.<span class="type">Lookup</span> <span class="variable">lookup</span> <span class="operator">=</span> MethodHandles.lookup();</span><br><span class="line">                    Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">                    <span class="keyword">for</span> (Method method : declaredMethods) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (method.isAnnotationPresent(GrpcMethod.class)) &#123;</span><br><span class="line">                            <span class="type">GrpcMethod</span> <span class="variable">grpcMethod</span> <span class="operator">=</span> method.getAnnotation(GrpcMethod.class);</span><br><span class="line">                            <span class="type">MethodHandle</span> <span class="variable">methodHandle</span> <span class="operator">=</span> lookup.unreflect(method);</span><br><span class="line">                            <span class="type">String</span> <span class="variable">grpcMethodKey</span> <span class="operator">=</span> generateGrpcMethodKey(grpcService.value(), grpcMethod.value());</span><br><span class="line">                            grpcMethodInvokeMap.put(grpcMethodKey, methodHandle.bindTo(instance));</span><br><span class="line">                            grpcMethodStreamMap.put(grpcMethodKey, grpcMethod.stream());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">generateGrpcMethodKey</span><span class="params">(String serviceName, String methodName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> serviceName + <span class="string">&quot;.&quot;</span> + methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GrpcResponse <span class="title function_">execute</span><span class="params">(String serviceName, String methodName, Object arg)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">MethodHandle</span> <span class="variable">methodHandle</span> <span class="operator">=</span> grpcMethodInvokeMap.get(generateGrpcMethodKey(serviceName, methodName));</span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">type</span> <span class="operator">=</span> grpcMethodInvokeMap.get(generateGrpcMethodKey(serviceName, methodName)).type();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">execute</span> <span class="operator">=</span> methodHandle.invoke(arg);</span><br><span class="line">        <span class="type">GrpcResponse</span> <span class="variable">grpcResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GrpcResponse</span>();</span><br><span class="line">        grpcResponse.setClazz(type.returnType());</span><br><span class="line">        grpcResponse.writeResponseData(execute);</span><br><span class="line">        <span class="keyword">return</span> grpcResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GrpcResponse <span class="title function_">execute</span><span class="params">(GrpcRequest request)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">service</span> <span class="operator">=</span> request.getService();</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">        <span class="comment">// protobuf 规范只能有单入参</span></span><br><span class="line">        request.setClazz(getRequestClass(request.getService(), request.getMethod()));</span><br><span class="line">        <span class="type">ProtobufCodec</span> <span class="variable">protobufCodec</span> <span class="operator">=</span> ProtobufProxy.getCodecCacheSide(request.getClazz());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">decode</span> <span class="operator">=</span> protobufCodec.decode(request.readData());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.execute(service, method, decode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定 service method 对应的入参类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getRequestClass(String serviceName, String methodName) &#123;</span><br><span class="line">        <span class="comment">//protobuf 规范只能有单入参</span></span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(grpcMethodInvokeMap.get(generateGrpcMethodKey(serviceName, methodName))).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;The specified grpc method does not exist&quot;</span>)).type().parameterArray()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkGrpcStream</span><span class="params">(GrpcRequest request)</span> &#123;</span><br><span class="line">        request.setStream(</span><br><span class="line">                Optional.ofNullable(grpcMethodStreamMap.get(generateGrpcMethodKey(request.getService(), request.getMethod())))</span><br><span class="line">                        .orElse(<span class="literal">false</span>)</span><br><span class="line">        );</span><br><span class="line">        request.setStreamFirstData(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="grpc-请求响应"><a href="#grpc-请求响应" class="headerlink" title="grpc 请求响应"></a>grpc 请求响应</h4><p>处理完请求后，需要将请求响应给客户端，这里可以 wireshark 抓包 http2 frame，观察一次正常的 grpc 请求会包含什么内容。</p><p>wireshark 抓包观察：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/image-20240818210447615-1735632505978-5.png" alt="image-20240818210447615"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/image-20240818210501661-1735632509942-7.png" alt="image-20240818210501661"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/image-20240818210514779-1735632517726-9.png" alt="image-20240818210514779"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/image-20240818210522123-1735632521652-11.png" alt="image-20240818210522123"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/image-20240818210530001-1735632525719-13.png" alt="image-20240818210530001"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/image-20240818210549107-1735632529711-15.png" alt="image-20240818210549107"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/image-20240818210558027-1735632532683-17.png" alt="image-20240818210558027"></p><p>在上图中可以发现一次 grpc 请求的请求响应过程大概如下：</p><ol><li>客户端向服务端发送 http2 frame，其中附带了一个 header 和一个 data</li><li>客户端向服务端发送一个空的 data frame，表示流结束（end stream）</li><li>服务端向客户端发送 ping</li><li>客户端响应服务端 pong</li><li>服务端响应客户端请求，其中附带了一个 heade</li><li>服务端响应客户端请求，其中附带了一个 data 和一个 header</li><li>客户端发送 RST_STREAM，结束请求</li></ol><p>其中 34 netty 会自动处理，主要看请求的接受和发送。</p><p>client 发送请求时，除了正常的附带数据的 http2 data frame 外，还会附带一个标识流结束的 http2 data frame；server 响应请求时，还会附带两个 header。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleGrpcData</span><span class="params">(Http2DataFrame dataFrame, ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">GrpcRequest</span> <span class="variable">grpcRequest</span> <span class="operator">=</span> dataBuffer.get(dataFrame.stream().id());</span><br><span class="line">    grpcRequest.writeData(dataFrame.content());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (grpcRequest.isStream()) &#123;</span><br><span class="line">        <span class="comment">// 流式调用，即刻响应</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">GrpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GrpcResponse</span>();</span><br><span class="line">            <span class="type">byte</span>[] bytes = grpcRequest.readData();</span><br><span class="line">            <span class="keyword">while</span> (bytes != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">ProtobufCodec</span> <span class="variable">protobufCodec</span> <span class="operator">=</span> ProtobufProxy.getCodecCacheSide(grpcDispatcher.getRequestClass(grpcRequest.getService(), grpcRequest.getMethod()));</span><br><span class="line">                <span class="type">Object</span> <span class="variable">decode</span> <span class="operator">=</span> protobufCodec.decode(bytes);</span><br><span class="line">                response = grpcDispatcher.execute(grpcRequest.getService(), grpcRequest.getMethod(), decode);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 针对第一个响应发送 header</span></span><br><span class="line">                <span class="keyword">if</span> (grpcRequest.isStreamFirstData()) &#123;</span><br><span class="line">                    ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">DefaultHttp2HeadersFrame</span>(response.getEndHeader()).stream(dataFrame.stream()));</span><br><span class="line">                    grpcRequest.setStreamFirstData(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">DefaultHttp2DataFrame</span>(response.getResponseData()).stream(dataFrame.stream()));</span><br><span class="line"></span><br><span class="line">                bytes = grpcRequest.readData();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            grpcRequest.clearData();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dataFrame.isEndStream()) &#123;</span><br><span class="line">                ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">DefaultHttp2HeadersFrame</span>(response.getEndStreamHeader(), <span class="literal">true</span>).stream(dataFrame.stream()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            processError(ctx, e, dataFrame.stream());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非流式调用，等到 endStream 再响应</span></span><br><span class="line">        <span class="keyword">if</span> (dataFrame.isEndStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">GrpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> grpcDispatcher.execute(grpcRequest);</span><br><span class="line">                ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">DefaultHttp2HeadersFrame</span>(response.getEndHeader()).stream(dataFrame.stream()));</span><br><span class="line">                ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">DefaultHttp2DataFrame</span>(response.getResponseData()).stream(dataFrame.stream()));</span><br><span class="line">                ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">DefaultHttp2HeadersFrame</span>(response.getEndStreamHeader(), <span class="literal">true</span>).stream(dataFrame.stream()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                processError(ctx, e, dataFrame.stream());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一元调用，需要在收到 end stream 的 frame 时才响应；对于双向 stream 调用，则每次都需要响应。</p><h4 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h4><p>![a925910e3a991ae54592d2f4c26a7a2](C:\Users\11291\Documents\WeChat Files\wxid_7n3wlrym4hzt21\FileStorage\Temp\a925910e3a991ae54592d2f4c26a7a2.png)</p><p>![1128115203a1559176da16aa96e1ce3](C:\Users\11291\Documents\WeChat Files\wxid_7n3wlrym4hzt21\FileStorage\Temp\1128115203a1559176da16aa96e1ce3.png)</p><p>开发完毕后，使用 apifox 针对服务发起调用，验证结果符合预期；</p><p>此外也在项目中提供了针对于 protobuf 序列化的单元测试和 grpc 请求的测试方法。经验证，同样符合测试预期。</p><h3 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h3><ol><li>在项目编写过程中主要考虑的问题是去除外部依赖，对于性能优化研究的还不够深入。后续需要继续深入优化性能。</li><li>由于时间问题，只是提供了一个实现了 grpc 协议的处理框架，但是并未实现某个具体的 arthas 功能。后续需要继续深入实现 arthas 的功能。</li><li>对于某些 grpc 实现细节还没有深入研究，例如 gzip 的解析、http2 协议的升级等等。后续需要继续投入。</li></ol><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>在这次项目过程中，我深入了解了 HTTP&#x2F;2 和 gRPC 协议，学习了如何使用 Wireshark 抓包以观察二进制数据，同时掌握了 Netty 的编写与使用。此外，在借鉴 jprotobuf 的过程中，我对 Java 编译的相关知识也有了更深刻的认识。在编写 gRPC 调用路由的过程中，我更深入地理解了 Java 的方法句柄及其应用。这是我首次参与大型开源项目，借此机会，我不仅提升了自己的技术能力，也拓宽了视野。衷心感谢 OSPP 提供的这个宝贵机会，让我在实践中受益良多。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>部署Grafana+Prometheus+Exporter</title>
      <link href="/2023/04/28/%E9%83%A8%E7%BD%B2Grafana-Prometheus-Exporter/"/>
      <url>/2023/04/28/%E9%83%A8%E7%BD%B2Grafana-Prometheus-Exporter/</url>
      
        <content type="html"><![CDATA[<h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=grafana --network host grafana/grafana-enterprise</span><br></pre></td></tr></table></figure><h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p>下载并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/prometheus/prometheus/releases/download/v2.42.0/prometheus-2.42.0.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar xvfz prometheus-*.tar.gz</span><br></pre></td></tr></table></figure><p>给 prometheus 配置 systemd 启动，默认运行端口为 9090</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/prometheus.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=prometheus</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">WorkingDirectory=/home/fengye/prometheus/prometheus-2.42.0.linux-amd64</span><br><span class="line"></span><br><span class="line"># 工作目录</span><br><span class="line">ExecStart=/home/fengye/prometheus/prometheus-2.42.0.linux-amd64./prometheus --storage.tsdb.path=../data --config.file=./prometheus.yml</span><br><span class="line"># 执行此 daemon 的指令或脚本程序</span><br><span class="line"></span><br><span class="line">Restart=on-failure</span><br><span class="line"># 非正常退出时重启</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"># 设置服务在开机时启动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl enable prometheus</span><br></pre></td></tr></table></figure><h2 id="Node-Exporter"><a href="#Node-Exporter" class="headerlink" title="Node Exporter"></a>Node Exporter</h2><p>下载并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/prometheus/node_exporter/releases/download/v1.5.0/node_exporter-1.5.0.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar xvfz node_exporter-*.tar.gz</span><br></pre></td></tr></table></figure><p>给 node_exporter 配置 systemd 启动，默认运行端口为 9100</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/node_exporter.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=node_exporter</span><br><span class="line"></span><br><span class="line">[Service]ExecStart=/home/fengye/node_exporter/node_exporter-1.5.0.linux-amd64/node_exporter</span><br><span class="line"># 执行此 daemon 的指令或脚本程序</span><br><span class="line"></span><br><span class="line">Restart=on-failure</span><br><span class="line"># 非正常退出时重启</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"># 设置服务在开机时启动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl enable node_exporter</span><br></pre></td></tr></table></figure><p>在 prometheus.yml 文件中追加监控 node_exporter 的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /home/fengye/prometheus/prometheus-2.42.0.linux-amd64/prometheus.yml</span><br><span class="line"></span><br><span class="line">在 scrape_configs 选项中追加</span><br><span class="line">  - job_name: &quot;node&quot;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&quot;localhost:9100&quot;]</span><br></pre></td></tr></table></figure><p>重启 prometheus</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart prometheus</span><br></pre></td></tr></table></figure><h2 id="MySQL-Exporter"><a href="#MySQL-Exporter" class="headerlink" title="MySQL Exporter"></a>MySQL Exporter</h2><p>下载并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/prometheus/mysqld_exporter/releases/download/v0.14.0/mysqld_exporter-0.14.0.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar xvfz mysqld_exporter-*.tar.gz</span><br></pre></td></tr></table></figure><p>在 MySQL 中创建新用户（注意，必须创建新用户，不能直接用 root 用户，否则获取不到数据）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;mysqld_exporter&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;mysqld_exporter&#x27;</span><br><span class="line"></span><br><span class="line">GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO &#x27;mysqld_exporter&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><p>创建配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /home/fengye/mysql_exporter/mysqld_exporter-0.14.0.linux-amd64/my.cnf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">host=localhost</span><br><span class="line">user=mysqld_exporter</span><br><span class="line">password=mysqld_exporter</span><br><span class="line">port=3306</span><br></pre></td></tr></table></figure><p>给 mysql_exporter 配置 systemd 启动，默认运行端口为 9104</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/mysql_exporter.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=mysql_exporter</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/home/fengye/mysql_exporter/mysqld_exporter-0.14.0.linux-amd64/mysqld_exporter --config.my-cnf=/home/fengye/mysql_exporter/mysqld_exporter-0.14.0.linux-amd64/my.cnf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行此 daemon 的指令或脚本程序</span></span><br><span class="line"></span><br><span class="line">Restart=on-failure</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">非正常退出时重启</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置服务在开机时启动</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl enable mysql_exporter</span><br></pre></td></tr></table></figure><p>在 prometheus.yml 文件中追加监控 mysql_exporter 的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /home/fengye/prometheus/prometheus-2.42.0.linux-amd64/prometheus.yml</span><br><span class="line"></span><br><span class="line">在 scrape_configs 选项中追加</span><br><span class="line">  - job_name: &quot;mysql&quot;</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&quot;localhost:9104&quot;]</span><br></pre></td></tr></table></figure><p>重启 prometheus</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart prometheus</span><br></pre></td></tr></table></figure><h2 id="RocketMQ-Exporter"><a href="#RocketMQ-Exporter" class="headerlink" title="RocketMQ Exporter"></a>RocketMQ Exporter</h2><p>下载并解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制</title>
      <link href="/2023/01/29/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/01/29/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java为了做到“一次编写，到处运行”，发布了运行在不同平台上的JVM，所有平台上的JVM都支持统一的程序存储格式————字节码（ByteCode），而存储字节码的二进制文件被称为Class文件。</p><p>对于JVM来说，不管是什么语言，只要能编译成Class文件，就可以在JVM中运行。换句话说，JVM不与任何语言绑定，而是与Class文件绑定。</p><p>任何一个Class文件都对应一个唯一的类或者接口，但是类或接口不一定定义在文件中（例如可以动态生成）。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209112229781.png" alt="image-20220911222923732"></p><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p><h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><p>在学习类加载之前，需要先了解Class文件的结构。</p><p>首先给出一个简单的代码样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>javac TestClass.java</code> 对其编译后，生成了一个名为 <code>TestClass.class</code> 的文件。使用16进制编辑器打开后，内容如下：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209052036337.png" alt="img"></p><p>后续的讲解都基于这个例子。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Class文件是一组以<strong>8个字节为基础</strong>的<strong>二进制</strong>流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符。</p><p>在Class文件中，只有两种数据类型————“<strong>无符号数</strong>”和“<strong>表</strong>”</p><ul><li>无符号数：分为<strong>u1、u2、u4、u8</strong>，表示占用1个字节、2个字节、4个字节、8个字节。无符号数可以用来描述数字、索引引用、数量值或者UTF8字符串。</li><li>表：由多个无符号数或者其他表构成，用于描述由层次关系的复合结构的数据。为了便于区分，所有表的命名都习惯性地用“_info”结尾。</li></ul><p>本质上，整个Class文件也是一个表，其结构如下： </p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209052005663.png" alt="image-20220905200506578"></p><p>无论是无符号数还是表，当需要描述同一类型但<strong>数量不定</strong>的多个数据时，经常会使用一个<strong>前置的容量计数器</strong>加<strong>若干个连续的数据项</strong>的形式，这时候称这一系列连续的某一类型的数据为某一类型的“<strong>集合</strong>”。</p><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>Class文件开头的第一个u4无符号数（magic）被称为魔数，用于标识这是一个Class类型的文件。</p><p>Class文件的魔数内容为 <code>0xCAFEBABE</code> 。</p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>紧接着魔数，后面的一个u2无符号数（minor_version）是次版本号；第二个u2无符号数（major_version）是主版本号。</p><p>JDK1的主版本号为45，每个大版本发布后都会+1；例如JDK17的主版本号为 <code>0x3D</code> ，即61。</p><p>高版本的JDK可以向下兼容以前版本的Class文件。</p><p>次版本号在JDK1时曾经被使用过，后来直到JDK12之前均为使用，全部固定为0。到了JDK12时期，由于JDK新特性越来越多，次版本号又被启用。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>版本号之后的是常量池（constant_pool）。常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一。由于常量池的数量不固定，因此常量池的入口前需要加一个u2无符号数（constant_pool_count，计数从1开始）表示常量池的容量。</p><p>常量池中主要存放两大类常量：<strong>字面量</strong>和<strong>符号引用</strong>。字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念。</p><p>常量池中的每个常量都是一个表，并且结构各不相同。每个常量有个共同特点，表结构起始的第一位是一个u1的标志位，表示当前常量属于哪种常量类型。</p><p>常量池中的元素的类型如下：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209112230895.png" alt="image-20220911223018824"></p><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>常量池之后的一个u2无符号数（access_flags）表示访问标志，用于标识类或接口层次的访问信息。它的值是各个标志值的或运算结果。</p><p>例如 access_flags &#x3D; <code>0x0011 = 0x0001 | 0x0010</code>，则表示 <code>public</code> 和 <code>final</code> 。</p><p>访问标志类型：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209112230468.png" alt="image-20220911223045415"></p><h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><p>访问标志后的是类索引（this_class）、父类索引（super_class）和接口索引（interfaces）。类索引和父类索引是u2类型的数据，而接口索引集合是一组u2类型的索引。</p><p>它们各自指向一个类型为CONSTANT_class_info类型的常量；类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，接口索引用于确定这个类实现或继承的接口的全限定名。</p><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>在此之后的是u2类型的字段表集合（fields_count和fields）。字段表集合中的每一个元素被称为字段表，用于描述一个字段（即声明在接口或类中的变量，Java语言中的字段包括类级变量和实例级变量）。</p><p>字段表的结构：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209112232182.png" alt="image-20220911223227149"></p><p>字段表中也有access_flags，它与类中的access_flags非常类似，具体如下：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209112233674.png" alt="image-20220911223316529"></p><p>在access_flags后的是两项索引值：name_index和descriptor_index。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p><blockquote><p>全限定名：把类全名中的<code>&#39;.&#39;</code>替换为<code>&#39;/&#39;</code>，例如<code>com.example.demo.TestClass</code>的全限定名为<code>com/example/demo/TestClass</code></p><p>简单名称：没有类型和参数修饰的方法或者字段名称</p><p>描述符：描述<strong>字段的数据类型</strong>、<strong>方法的参数列表和返回值</strong>。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209130154204.png" alt="image-20220913015434129"></p><p>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava&#x2F;lang&#x2F;String；”，一个整型数组“int[]”将被记录成“[I”。</p><p>用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava&#x2F;lang&#x2F;String；”，方法<code>int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)</code>的描述符为“([CII[CIII)I”。</p></blockquote><p>字段表的最后是一个属性表集合，用于存放字段的具体数值（具体内容将在后面提及）。</p><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>方法表集合（methods_count和methods）和字段表集合基本一致，仅在访问标志和属性表中有所差异。例如volatile不能用于修饰方法等等。</p><p>字段表的最后也是一个属性表集合，用于存放方法中的的具体实现（具体内容将在后面提及）。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209130210853.png" alt="image-20220913021049815"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209130212244.png" alt="image-20220913021245195"></p><h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>在Class文件的最后，是一个属性表组成的集合（attributes_counts和attributes）。</p><p>属性表集合在之前的字段表和方法表中也有出现。</p><p>与Class文件中的其他数据项目不同，属性表并没有严格的顺序、长度、内容要求，并且只要不与已存在的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。为了能正确解析Class文件，JVM规范中预定义了一些属性，只需了解一些其中常用的即可。</p><p>每一个属性的结构如下：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209130221460.png" alt="image-20220913022156428"></p><ul><li>attribute_name_index: 引用常量池中的一个 CONSTANT_Utf8_info 类型的常量作为名称</li><li>attribute_length: 属性值占用的位数</li><li>info: 自定义的属性值</li></ul><h4 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h4><p>Code属性出现在方法表的属性集合中（并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性）。Code属性主要用于存放经过编译器处理后的<strong>方法体</strong></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209191507420.png" alt="image-20220919150756350"></p><ul><li>attribute_name_index: 指向CONSTANT_Utf8_info型常量，固定为”Code”，表示这个属性的名称是Code。</li><li>attribute_length: 属性值的长度（属性表长度-6byte）。</li><li>max_stack: 操作数栈最大深度。</li><li>max_locals: 局部变量所需的存储空间。</li><li>code_length: 方法体编译后的字节码的长度。</li><li>code: 存储方法体编译后的<strong>字节码指令</strong>。</li><li>exception_table_length: 异常表长度。</li><li>exception_table: 异常表。</li></ul><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209191627689.png" alt="image-20220919162738642"></p><p>异常表描述的是try-catch的过程：如果当字节码从第start_pc行到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转到handler_pc处进行处理。</p><h4 id="Exception属性"><a href="#Exception属性" class="headerlink" title="Exception属性"></a>Exception属性</h4><p>Code属性出现在方法表的属性集合中，用于列举方法中可能抛出的异常（即throws关键字后的异常）</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209191709802.png" alt="image-20220919170919754"></p><ul><li>execption_index_table: 指向常量池中的CONSTANT_Class_info型常量的索引。</li></ul><h4 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h4><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。</p><p>在Java中，用不同的方式定义的变量的赋值方式和时机都会不同。对于非static变量的赋值是在实例构造器<code>&lt;init&gt;()</code>方法中进行的；对于static变量，可以在类构造器<code>&lt;clinit&gt;()</code>中赋值或用ConstantValue属性赋值。</p><p>目前Oracle的Javac编译期的逻辑是：<strong>如果某个变量被static和final修饰，并且它的类型是基本数据类型或者String的话，就会将其认定为常量，生成ConstantValue属性来对其进行初始化。</strong></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209191829260.png" alt="image-20220919182919149"></p><ul><li>attribute_length: 固定为2</li><li>constantvalue_index: 指向常量池中的一个常量</li></ul><blockquote><p>自行了解属性表参考：<a href="https://blog.csdn.net/qq_38526573/article/details/88541241">Class文件结构介绍属性表集合-CSDN博客</a></p></blockquote><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>与在编译时期进行连接的语言不同，在Java中，类型的加载，连接和初始化都是在程序运行期间完成的。这种策略让Java很难提前编译，并且会增加</p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>一个类型（类和接口）从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历<strong>加载</strong>（Loading）、<strong>验证</strong>（Verification）、<strong>准备</strong>（Preparation）、<strong>解析</strong>（Resolution）、<strong>初始化</strong>（Initialization）、<strong>使用</strong>（Using）和<strong>卸载</strong>（Unloading）七个阶段，其中验证、准备、解析三个部分统称为<strong>连接</strong>（Linking）。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209171626736.png" alt="image-20220917162623677"></p><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>《JVM规范》中没有对类加载的第一个阶段“<strong>加载</strong>”进行强制约束，可以由虚拟机自由把握。但是《JVM规范》对与“<strong>初始化</strong>”有着严格规定，规定以下六种情况下必须立即对类进行“<strong>初始化</strong>”（“<strong>加载</strong>”和“<strong>连接</strong>”会在此之前执行）：</p><ol><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化。能够生成这四条指令的Java代码场景有：<ul><li>使用 new 关键字实例化对象</li><li>读取或设置类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）</li><li>调用一个类型的静态方法</li></ul></li><li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li><li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先 初始化这个主类。</li><li>当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li><li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li></ol><p>在《JVM规范》中，规定了“<strong>有且只有</strong>”这六种场景会触发初始化，这六种场景被称为<strong>主动引用</strong>。除此以外，其他引用的方式被称为<strong>被动引用</strong>，不会触发其初始化。</p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载是整个类加载过程的第一个阶段。在这个阶段，JVM需要完成三件事：</p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>加载阶段结束后，JVM外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了。类型数据安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。</p><p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是连接阶段的第一个步骤，目的是为了确保Class文件的字节流中包含的信息符合《JVM规范》的约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><p>验证阶段大致上分为下面四个阶段的检验动作：</p><h5 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h5><p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p><p>包括：</p><ul><li>是否以魔数0xCAFEBABE开头。</li><li>主、次版本号是否在当前Java虚拟机接受范围之内。</li><li>是否有其他不符合Class文件规范要求的数据。</li></ul><p>前面提到过，加载阶段和连接阶段的部分动作是交叉进行的。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p><h5 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h5><p>对字节码描述的元数据信息进行语义分析，保证其描述的信息符合Java语言规范的要求（验证元数据的语法）。</p><p>包括：</p><ul><li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li><li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</li><li>…</li></ul><h5 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h5><p>对类的方法体（Class文件中的Code属性）进行校验分析。</p><h5 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h5><p>符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量（static变量）分配内存并设置初始值（零值）的阶段。这些变量使用的内存在方法区中分配。</p><p>需要强调两点：</p><ol><li>准备阶段只会给类变量分配内存，而不包括实例变量。</li><li>通常情况下设置的初始值指的是零值。</li></ol><blockquote><p>赋零值是通常情况下的做法。</p><p>例如 <code>public static int value = 123;</code> 其中的 value 在准备阶段之后的值为 0 。</p><p>但是如果是 <code>public static int value = 123;</code> javac在编译这段代码后会为 value 生成常量属性，在准备阶段之后会直接赋值为 123 。</p></blockquote><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209181856295.png" alt="image-20220918185626238"></p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是JVM将常量池内的符号引用替换为直接引用的过程。</p><blockquote><p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用的字面量形式在《JVM规范》中有明确定义，因此各个虚拟机能接受的符号引用必须一致。</p><p>直接引用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用和虚拟机的内存布局直接相关，同一个符号引用在不同虚拟机上翻译出来的直接引用不一定相同。</p></blockquote><p>《JVM规范》没有严格规定解析阶段发生的具体时间，JVM可以根据需要自行判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的初始化是类加载过程的最后一步。</p><p>在准备阶段时，变量已经赋过一次零值了，而在初始化阶段，则会根据程序中编写的值进行初始化。换句话说，初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><p><code>&lt;clinit&gt;()</code>方法是Javac编译器自动产生的。编译器会自动收集类中的所有<strong>类变量的赋值语句</strong>和<strong>静态语句</strong>，并将其合并成<code>&lt;clinit&gt;()</code>方法。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>在前面的类加载过程中，第一步的加载阶段就是由类加载器实现的。</p><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。</p><h4 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h4><p>对于JVM来说，只存在两种不同的类加载器：</p><ul><li>启动类加载器：用C++实现，是JVM的一部分。</li><li>其他类加载器：用Java实现，独立在JVM外部，并且全部继承自<code>Java.lang.ClassLoader</code>。</li></ul><p>对于Java开发者来说，类加载器可以分为三层架构和<strong>双亲委派</strong>模型：</p><ul><li>启动类加载器（Bootstrap Class Loader）：负责加载<code>&lt;JAVA_HOME&gt;\lib</code>目录或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的类库。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器处理，那直接使用null代替即可。</li><li>扩展类加载器（Extension Class Loader）：在类 sun.misc.Launcher$ExtClassLoader 中以Java代码的形式实现。负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录或者被<code>java.ext.dirs</code>系统变量所指定的路径中存放的类库。通过这个加载器，用户可以把一些具有通用性的类库放在ext目录中以拓展JDK的功能。在JDK9之后，这种扩展机制被JDK的模块化功能的扩展机制所取代。由于扩展类加载器是由Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。</li><li>应用程序类加载器（Application Class Loader）：在类 sun.misc.Launcher$AppClassLoader 中实现。由于可以用<code>ClassLoader.getSystemClassLoader()</code>来获取，因此也被称为系统类加载器。它负责加载用户类路径（ClassPath）里的所有类库。开发者也可以直接在代码中使用应用程序类加载器，并且如果没有显示指定其他类加载器，一般情况下这个类加载器就是程序中默认的类加载器。</li></ul><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>JDK9之前的Java应用程序都是由这三种类加载器互相配合完成加载的，用户也可以加入自定义的类加载器进行拓展。这些类加载器的协作关系如图：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/2209202117172.png" alt="image-20220920211752097"></p><p>这种类加载器之间的层次关系就被称为类加载器的“双亲委派模型”。“双亲委派模型”要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。</p><p>“双亲委派模型”加载一个类的过程：如果一个类加载器收到了类加载的请求，它并不会首先自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，并且每一个层次的类加载器都是如此。因此所有的加载请求最终都会被传送到最顶层的启动类加载器中。只有父加载器无法完成这个加载请求，子加载器才会开始尝试自己去完成加载。</p><p>好处：前面提到过每个类的唯一性都需要这个类本身和它的加载器共同确立。在类加载器加载类时，会根据这个唯一性来确保让每个类只被加载一次，不会被重复加载。使用了双亲委派模型后，就可以让核心类（例如String）都用最顶层的启动类加载器加载，从而使得核心类不会被恶意篡改。</p><blockquote><p>参考：<a href="https://blog.csdn.net/javazejian/article/details/73413292?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~Rate-4-73413292-blog-48626159.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~Rate-4-73413292-blog-48626159.pc_relevant_default&utm_relevant_index=5">深入理解Java类加载器(ClassLoader)-CSDN博客</a></p></blockquote><blockquote><p>全文参考：《深入理解Java虚拟机-第三版》</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis笔记</title>
      <link href="/2023/01/24/Redis%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/24/Redis%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习后端开发这么久，Redis 是我常用的一个中间件，以往主要是用于做缓存处理和暂存一些值。但用了这么多，却并没有深入地了解过 Redis 底层，并且平时的使用也大多都是通过 SpringData 封装的 RedisTemplate，连 Redis 本身的命令也几乎要忘掉了。因此打算写一篇总结性的博客，包括Redis的基础 + Redis底层 + Redis进阶使用。</p><h2 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h2><h3 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h3><h4 id="操作数据库相关指令"><a href="#操作数据库相关指令" class="headerlink" title="操作数据库相关指令"></a>操作数据库相关指令</h4><ul><li>启动 Redis 客户端: <code>redis-cli -h host -p port -a password</code></li><li>切换当前数据库: <code>select 数据库index(0-15)</code></li><li>清空当前的库: <code>FLUSHDB</code> ；清空所有库: <code>FLUSHALL</code></li><li>动态调整 Redis 的配置而不用重启（重启失效）：<code>CONFIG SET ...</code></li></ul><h4 id="操作数据类型相关指令"><a href="#操作数据类型相关指令" class="headerlink" title="操作数据类型相关指令"></a>操作数据类型相关指令</h4><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p>String 是 Redis 中最简单的存储类型，一个 key 对应一个 value。其 value 是字符串（可以细分为字符串、整数、浮点数）。value 最大值不能超过512mb。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>SET key value</td><td>设置一个key&#x2F;value</td></tr><tr><td>GET key</td><td>根据key获得对应的value</td></tr><tr><td>MSET key value [key value …]</td><td>一次设置多个key的value</td></tr><tr><td>MGET key1 [key2..]</td><td>一次获得多个key的value</td></tr><tr><td>GETSET key value</td><td>获得原始key的值，同时设置新值</td></tr><tr><td>STRLEN key</td><td>获得对应key存储value的长度</td></tr><tr><td>APPEND key value</td><td>为对应key的value追加内容</td></tr><tr><td>GETRANGE key start end</td><td>截取value的内容（索引从0开始）</td></tr><tr><td>SETEX key seconds value</td><td>设置一个key存活的有效期（秒）</td></tr><tr><td>PSETEX key milliseconds value</td><td>设置一个key存活的有效期（毫秒）</td></tr><tr><td>SETNX key value</td><td>key不存在则设置value</td></tr><tr><td>MSETNX key value [key value …]</td><td>多个key都不存在则设置多个value</td></tr><tr><td>DECR key</td><td>将指定的数值类型-1</td></tr><tr><td>DECRBY key</td><td>将指定的数值类型减去指定的值（二者必须都是整数）</td></tr><tr><td>INCR key</td><td>将指定的数值类型+1</td></tr><tr><td>INCRBY key increment</td><td>将指定的数值类型加上指定的值（二者必须都是整数）</td></tr><tr><td>INCRBYFLOAT key increment</td><td>将指定的数值类型加上指定的值（increment必须是浮点数）</td></tr></tbody></table><p>使用场景：</p><ul><li>缓存</li><li>计数器</li><li>共享Session</li></ul><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>Redis 中的 List 是一个双向链表结构。一个 Key 对应多个有序的 Value，可以添加元素到头部（左边）或者尾部（右边）。一个 List 最多可以包含 <code>2^32 - 1</code> 个元素（4294967295）。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>LPUSH key value1 [value2]</td><td>将一个或多个值插入到 key list 的左边</td></tr><tr><td>LPUSHX key value1 [value2]</td><td>同LPUSH，但是必须要保证这个 key list 存在</td></tr><tr><td>RPUSH key value1 [value2]</td><td>将某个值加入到一个key列表末尾</td></tr><tr><td>RPUSHX key value1 [value2]</td><td>同RPUSH，但是必须要保证这个 key list 存在</td></tr><tr><td>LPOP key</td><td>返回并移除列表左边的第一个元素</td></tr><tr><td>RPOP key</td><td>返回并移除列表右边的第一个元素</td></tr><tr><td>LRANGE key start stop</td><td>获取某一个下标区间内的元素</td></tr><tr><td>LLEN key</td><td>获取列表元素个数</td></tr><tr><td>LSET key index value</td><td>设置某一个指定索引的值（索引必须存在）</td></tr><tr><td>LINDEX key index</td><td>获取某一个指定索引位置的元素</td></tr><tr><td>LREM key count value</td><td>删除列表中前 count 值等于 value 的元素</td></tr><tr><td>LTRIM key start stop</td><td>保留列表中特定区间内的元素</td></tr><tr><td>LINSERT key BEFORE&#x2F;AFTER pivot value</td><td>在某一个元素之前&#x2F;之后插入新元素</td></tr></tbody></table><p>通过以上命令组合，List 既可以作为队列，也可以作为栈等数据结构使用。</p><p>使用场景：</p><ul><li>时间轴</li><li>消息队列</li></ul><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>Redis 中的 Set 是 String 类型的无序集合，一个 Key 对应多个无序的 Value。Set 是通过哈希表实现的，所以添加、删除、查找的复杂度都是O(1)。集合中不能有重复元素。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>SADD key member1</td><td>为集合添加元素</td></tr><tr><td>SMEMBERS key</td><td>显示集合中所有元素（无序）</td></tr><tr><td>SCARD key</td><td>返回集合中元素的个数</td></tr><tr><td>SPOP key</td><td>随机返回并删除一个元素</td></tr><tr><td>SMOVE source destination member</td><td>从一个集合中向另一个集合移动元素  必须是同一种类型</td></tr><tr><td>SREM key member</td><td>从集合中删除元素</td></tr><tr><td>SISMEMBER key member</td><td>判断集合中是否含有这个元素</td></tr><tr><td>SRANDMEMBER key [count]</td><td>返回一个或多个随机元素</td></tr><tr><td>SDIFF key1 key2</td><td>返回两个集合中不同的元素</td></tr><tr><td>SINTER key1 key2]</td><td>返回交集</td></tr><tr><td>SUNION key1 key2</td><td>返回并集</td></tr></tbody></table><p>使用场景：</p><ul><li>tag标签</li><li>点赞、收藏</li></ul><h5 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h5><p>Redis 中的 Zset 是 String 类型的有序集合，一个 Key 对应多个有序的 value，每个 Key 同时还会关联一个 double 类型的分数。Zset 排序的依据就是这个分数。Zset底层通过跳表 + hash表实现。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>ZADD key score1 member1</td><td>添加一个有序集合元素，并指定分数</td></tr><tr><td>ZCARD key</td><td>返回集合的元素个数</td></tr><tr><td>ZCOUNT key min max</td><td>返回指定范围内的元素个数</td></tr><tr><td>ZRANGEBYSCORE key min max</td><td>按照分数查找一个范围内的元素</td></tr><tr><td>ZRANK key member</td><td>返回某个元素的排名</td></tr><tr><td>ZREVRANK zrevrank</td><td>返回某个元素的倒序排名</td></tr><tr><td>ZSCORE key mem</td><td>显示某一个元素的分数</td></tr><tr><td>ZREM key member</td><td>移除某一个元素</td></tr><tr><td>ZINCRBY key increment member</td><td>给某个特定元素加分</td></tr></tbody></table><p>使用场景：</p><ul><li>排行榜</li></ul><h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><p>Redis 中的 Hash 是 String 类型的键值对（filed&#x2F;value）映射表。每个Hash可以存储 <code>2^32 - 1</code> 个键值对（4294967295）。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>HSET key field value</td><td>设置一个 filed&#x2F;value 对</td></tr><tr><td>HGET key field</td><td>获得一个 filed 对应的 value</td></tr><tr><td>HGETALL key</td><td>获得所有的 filed&#x2F;value 对</td></tr><tr><td>HDEL key field1 [field2]</td><td>删除一个或多个 filed&#x2F;value 对</td></tr><tr><td>HEXISTS key field</td><td>判断一个 filed 是否存在</td></tr><tr><td>HKEYS key</td><td>获得所有的 filed</td></tr><tr><td>HVALS key</td><td>获得所有的 value</td></tr><tr><td>HLEN key</td><td>获取 filed&#x2F;value 对个数</td></tr><tr><td>HMSET key field1 value1 [field2 value2]</td><td>设置多个 filed&#x2F;value</td></tr><tr><td>HMGET key field1 [field2]</td><td>获得多个 filed 的 value</td></tr><tr><td>HSETNX key field value</td><td>field 不存在则添加 field&#x2F;value 对</td></tr><tr><td>HINCRBY key field increment</td><td>为 value 进行加法运算，同 String</td></tr><tr><td>HINCRBYFLOAT key field increment</td><td>为 value 加入浮点值，同 String</td></tr></tbody></table><p>使用场景：</p><ul><li>缓存</li></ul><h4 id="操作key相关指令"><a href="#操作key相关指令" class="headerlink" title="操作key相关指令"></a>操作key相关指令</h4><ul><li><p>del</p><ul><li>语法: DEL key [key …] </li><li>作用: 删除给定的一个或多个 key 。不存在的 key 会被忽略。</li><li>返回值: 被删除 key 的数量。</li></ul></li><li><p>exists</p><ul><li>语法: EXISTS key</li><li>作用: 检查给定 key 是否存在。</li><li>返回值: 若 key 存在，返回 1 ，否则返回 0。</li></ul></li><li><p>expire</p><ul><li>语法: EXPIRE key seconds</li><li>作用: 为给定 key 设置生存时间，当 key 过期时，它会被自动删除。</li><li>返回值: 设置成功返回1 。</li></ul></li><li><p>keys</p><ul><li>语法: KEYS pattern</li><li>作用: 查找所有符合给定模式 pattern 的key 。<br>KEYS * 匹配数据库中所有key 。<br>KEYS h?llo 匹配 hello，hallo 和 hxllo 等。<br>KEYS h*llo 匹配 hllo 和 heeeeello 等。<br>KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配hillo 。特殊符号用 “&quot; 隔开</li><li>返回值: 符合给定模式的key 列表。</li></ul></li><li><p>move</p><ul><li>语法: MOVE key db</li><li>作用: 将当前数据库的 key 移动到给定的数据库 db 当中。</li><li>返回值: 移动成功返回 1 ，失败则返回 0 。</li></ul></li><li><p>pexpire</p><ul><li>语法: PEXPIRE key milliseconds</li><li>作用: 这个命令和 EXPIRE 命令的作用类似，但是它以毫秒为单位设置 key 的生存时间</li><li>返回值: 设置成功，返回 1；key不存在或设置失败，返回 0</li></ul></li><li><p>ttl</p><ul><li>语法: TTL key</li><li>作用: 以秒为单位，返回给定 key 的剩余生存时间(time to live)。</li><li>返回值:<br>当key 不存在时，返回-2 。<br>当key 存在但没有设置剩余生存时间时，返回-1 。<br>否则，以秒为单位，返回key 的剩余生存时间。</li><li>注意: 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。</li></ul></li><li><p>pttl</p><ul><li><p>语法: PTTL key</p></li><li><p>作用: 这个命令类似于 TTL 命令，但它以毫秒为单位返回 key 的剩余生存时间</p></li><li><p>可用版本: &gt;&#x3D; 2.6.0</p></li><li><p>返回值: </p><p>当key 不存在时，返回 -2 。</p><p>当key 存在但没有设置剩余生存时间时，返回 -1 。</p><p>否则，以毫秒为单位，返回 key 的剩余生存时间。</p></li><li><p>注意: 在Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回-1 。</p></li></ul></li><li><p>randomkey</p><ul><li>语法: RANDOMKEY</li><li>作用: 从当前数据库中随机返回(不删除) 一个 key 。</li><li>返回值: 当数据库不为空时，返回一个 key 。当数据库为空时，返回nil 。</li></ul></li><li><p>rename</p><ul><li>语法: RENAME key newkey</li><li>作用: 将 key 改名为 newkey 。当 key 不存在时，返回一个错误。当 newkey 已经存在时，RENAME 命令将覆盖旧值。</li><li>返回值: 改名成功时提示OK ，失败时候返回一个错误。</li></ul></li><li><p>type</p><ul><li>语法: TYPE key</li><li>作用: 返回key 所储存的值的类型。</li><li>返回值:<br>none (key 不存在)<br>string (字符串)<br>list (列表)<br>set (集合)<br>zset (有序集)<br>hash (哈希表)</li></ul></li></ul><h2 id="Redis底层"><a href="#Redis底层" class="headerlink" title="Redis底层"></a>Redis底层</h2><blockquote><p>参考：《Redis设计与实现》（基于Redis 2.9）</p></blockquote><h3 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>Redis 底层中构造了一系列的数据结构。需要注意的是，这些数据结构和前面介绍的数据类型并没有直接的一一对应关系，数据类型实际上是对数据结构的进一层封装（在后续的“对象“部分会提到）。这些数据结构并不只是用于数据类型的底层，其中的大部分数据结构都广泛地应用在 Redis 内部的其他部分。</p><h5 id="单动态字符串"><a href="#单动态字符串" class="headerlink" title="单动态字符串"></a>单动态字符串</h5><p>Redis是用C语言实现的，但是Redis中的字符串并没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串的抽象类型（simple dynamic string，SDS），并将SDS作为Redis的默认字符串表示。SDS定义在 <code>src/sds.h</code> 和 <code>src/sds.c</code> 中。</p><p><code>src/sds.h/sdshdr</code> 定义了SDS的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"><span class="comment">//记录buf数组中已使用字节的数量</span></span><br><span class="line"><span class="comment">//等于SDS所保存字符串的长度</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line"><span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301051956753.png" alt="image-20230105195656692"></p><p>例如有如上SDS示例：</p><ul><li>free属性的值为0，表示这个SDS没有分配任何未使用空间。</li><li>len属性的值为5，表示这个SDS保存了一个五字节长的字符串。</li><li>buf属性是一个char类型的数组，数组的前五个字节分别保存了’R’、’e’、’d’、’i’、’s’五个字符，而最后一个字节则保存了空字符’\0’。最后的空字符串不计算入len。</li></ul><p>SDS遵循了C字符串以空字符结尾的惯例，因此可以直接复用C语言字符串函数库里的部分函数。</p><p>使用SDS而非C字符串的优势：</p><ul><li>C字符串并不能保存自身的长度信息，因此为了获取一个字符串的长度，需要遍历整个字符串直到结尾的空字符串。而SDS保存了字符串的长度，因此可以<strong>常数复杂度获取字符串长度</strong>。</li><li>C字符串容易造成缓冲区溢出。而SDS的API<strong>杜绝了缓冲区的溢出</strong>。</li><li>C字符串底层是字符数组，由于C数组是不可变的，因此每次对C字符串进行修改操作都需要重新分配内存。而SDS的API会预分配一部分未使用的内存给SDS，并且惰性释放空间，<strong>避免了频繁的内存分配</strong>。</li><li>C字符串使用空字符表示字符串结尾，因此无法存储一些带有空字符的数据。而SDS的API会采用处理二进制数据的方式来处理buf中的数据，因此<strong>SDS是二进制安全的</strong>。</li></ul><h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><p>链表是一种常用的数据结构，由于C语言中并没有内置这种数据结构，所以Redis构建了自己的链表实现。</p><h6 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h6><p>linkedlist 类似于 Java 中的 LinkedList，是一个双向链表。linkedlist 在 Redis 中应用广泛，例如列表键的底层实现之一就是 linkedlist。当列表键包含较多元素或者列表中的元素大小较长，Redis就会采用链表作为列表键的底层实现。</p><p>它的每个链表节点定义在 <code>adlist.h/listNode</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"><span class="comment">// 前置节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点的值</span></span><br><span class="line"><span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>多个 listNode 通过 prev 和 next 指针组成双向链表：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301060439086.png" alt="image-20230106043905043"></p><p><code>adlist.h/list</code> 中定义了 list 来持有双向链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="comment">// 表头节点</span></span><br><span class="line">listNode * head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表尾节点</span></span><br><span class="line">listNode * tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表所包含的节点数量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点值复制函数</span></span><br><span class="line"><span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点值释放函数</span></span><br><span class="line"><span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点值对比函数</span></span><br><span class="line"><span class="type">int</span> (*match)(<span class="type">void</span> *ptr,<span class="type">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><h6 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h6><p>ziplist 是 Redis 为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的<strong>顺序型数据结构</strong>。</p><p>ziplist 是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项都是小整数值或者长度较短的字符串，Redis 就会使用 ziplist 作为列表键的底层实现；当一个哈希表键只包含少量键值对，并且每个键值对的键和值都是小整数值或长度较短的字符串，Redis 就会使用 ziplist 作为哈希表键的底层实现。</p><p><strong>压缩列表的结构</strong></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301092032475.png" alt="image-20230109203249382"></p><table><thead><tr><th>属性</th><th>类型</th><th>长度</th><th>作用</th></tr></thead><tbody><tr><td>zlbytes</td><td>uint32_t</td><td>4字节</td><td>记录整个压缩列表占用的字节数</td></tr><tr><td>zltail</td><td>uint32_t</td><td>4字节</td><td>记录压缩列表中末尾节点距离压缩列表起始地址的字节数</td></tr><tr><td>zllen</td><td>uint16_t</td><td>2字节</td><td>记录了压缩列表包含的节点数量（上限是 65535，即当压缩列表节点的数量大于 65535 时，需要遍历整个压缩列表才知道真实节点数量）</td></tr><tr><td>entryX</td><td>列表节点</td><td>不定</td><td>保存压缩列表的各个节点，节点长度由具体保存的内容决定</td></tr><tr><td>zlend</td><td>uint8_t</td><td>1字节</td><td>特殊值 0xff，标记压缩列表的末端</td></tr></tbody></table><p>例如有如下压缩列表：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301100305945.png" alt="image-20230110030545902"></p><ul><li>zlbytes 为 0x50（十进制8 0），表示压缩列表的总长为80字节。</li><li>zltail 为 0x3C（十进制 60），标识如果有一个指向压缩列表起始地址的指针 p，那么只需要用 p 加上偏移量60，就可以计算出表尾节点 entry3 的地址。</li><li>zllen 为 0x3（十进制 3），标识压缩列表包含三个节点。</li></ul><p><strong>压缩列表节点的结构</strong></p><p>每个压缩列表节点可以保存一个字节数组或者一个整数值。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301100320450.png" alt="image-20230110032029417"></p><ul><li>previous_entry_length：记录前一个节点的字节长度。通过这个属性可以计算出前一个节点的位置，用于帮助程序实现从后向前遍历。<ul><li>若前一个节点的长度小于 254 字节，则 previous_entry_length 占用一个字节，其中保存的就是前一个结点的长度。</li><li>若前一个节点的长度大于等于 254 字节，则 previous_entry_length 占用五个字节，第一个字节的值被固定为 0xFE（十进制 254），后面四个字节用于保存迁移节点的长度。</li></ul></li><li>encoding：记录 content 保存的数据的类型和长度。<ul><li>若 encoding 占用一字节并且二进制高位以 11 开头，则说明 content 保存的是整数。content 的类型由 encoding 去掉最高两位之后的其他位记录：<ul><li>encoding 为 11000000，content 类型为 int16_t。</li><li>encoding 为 11010000，content 类型为 int32_t。</li><li>encoding 为 11100000，content 类型为 int64_t。</li><li>encoding 为 11110000，content 类型为 24 位有符号整数。</li><li>encoding 为 11111110，content 类型为 8 位有符号整数。</li><li>encoding 为 1111xxxx，由于 encoding 本身的 xxxx 四位已经可以保存一个介于 0 和 12 之间的值，因此没有 content 属性。</li></ul></li><li>若 encoding 占用一字节、两字节、五字节，值的最高位为00、01、10，则说明 content 保存的是字节数组。content 的长度由 encoding 去掉最高两位之后的其他位记录。<ul><li>encoding 为 00bbbbbb，content 保存的是长度小于等于 63 字节的字节数组。</li><li>encoding 占用两字节时，content 保存的是长度小于等于 16383 字节的字节数组。</li><li>encoding 占用五字节时，content 保存的是长度小于等于 4294967295 字节的字节数组。</li></ul></li></ul></li><li>content：负责保存数据。</li></ul><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5><h6 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h6><p>Redis中的字典使用哈希表作为底层实现，由三部分组成：dictEntry、dictht、dict。</p><p>哈希表由 <code>dict.h/dictht</code> 定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"><span class="comment">// 哈希表数组</span></span><br><span class="line"><span class="comment">// 每个元素都是一个指向 dict.h/dictEntry 的指针</span></span><br><span class="line"><span class="comment">// 每个 dictEntry 结构保存着一个键值对</span></span><br><span class="line">dictEntry **table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表大小，即 table 数组大小</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表大小掩码，用于计算索引</span></span><br><span class="line"><span class="comment">// 总是等于 size - 1 </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>哈希表节点由 <code>dict.h/dictEntry</code> 定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 键</span></span><br><span class="line"><span class="type">void</span> *key;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值</span></span><br><span class="line"><span class="comment">// 值可以是指针，</span></span><br><span class="line"><span class="comment">// 也可以是uint64_tu64或int64_ts64整数</span></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line"><span class="type">void</span> *val;</span><br><span class="line">uint64_tu64;</span><br><span class="line">int64_ts64;</span><br><span class="line">&#125; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用链表解决哈希冲突</span></span><br><span class="line"><span class="comment">// next即指向链表下一个节点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>字典由 <code>dict.h/dict</code> 定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型特定函数</span></span><br><span class="line">dictType *type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有数据</span></span><br><span class="line"><span class="type">void</span> *privdata;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line">dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// rehash 索引</span></span><br><span class="line"><span class="comment">// 当 rehash 不在进行时，值为-1</span></span><br><span class="line"><span class="type">int</span> rehashidx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>type属性和privdata属性时针对不同类型的键值对，为创建多态字典而设置的：</p><ul><li><p>type属性是一个指向 dictType 结构的指针，每个 dictType 结构保存了一些用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同类型的特定函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line"><span class="comment">//计算哈希值的函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制键的函数</span></span><br><span class="line"><span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制值的函数</span></span><br><span class="line"><span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对比键的函数</span></span><br><span class="line"><span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁键的函数</span></span><br><span class="line"><span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁值的函数</span></span><br><span class="line"><span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure></li><li><p>privdata属性保存了需要传给那些特定函数的可选参数。</p></li></ul></li><li><p>ht属性是一个包含两个项的数组，数组中的每个项都是一个 dictht 哈希表，一般情况下只会使用 ht[0] 哈希表，ht[1] 只会在对 ht[0] 进行 rehash 时使用。</p></li></ul><p>一个正常情况（没有进行rehash）下的字典结构如图：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301070639470.png" alt="image-20230107063956415"></p><h6 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h6><p>当要添加一个新的键值对到字典中时，程序会先根据键值对的键计算出哈希值，然后通过哈希值计算出索引值，再将键值对用哈希表节点封装后，存放到哈希表数组的指定索引上。</p><p>Redis计算哈希值和索引值的方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用字典设置的哈希函数，计算键key的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"># 使用哈希表的sizemask属性和哈希值，计算出索引值</span><br><span class="line"># 根据情况不同，ht[x]可以是ht[<span class="number">0</span>]或ht[<span class="number">1</span>]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure><p>Redis 使用 MurmurHash 算法来计算键的哈希值。</p><h6 id="解决哈希冲突"><a href="#解决哈希冲突" class="headerlink" title="解决哈希冲突"></a>解决哈希冲突</h6><p>当由两个或以上的键被分配到哈希表的同一个索引上时，就发生了哈希冲突。Redis的哈希表采用链表来解决哈希冲突。每个哈希表节点都有一个next指针，多个哈希表节点可以使用next指针构成一个单向链表。Redis中新节点总是被添加到表头。</p><h6 id="调整哈希表容量"><a href="#调整哈希表容量" class="headerlink" title="调整哈希表容量"></a>调整哈希表容量</h6><p>和 Java 中的 HashMap 类似，哈希表的底层是一个数组，需要给其定一个初始大小，并且动态地调整容量，以便让其负载因子维持在一个合理的范围内，从而减少哈希冲突的概率。</p><p>调整哈希表容量的工作可以通过执行 rehash 操作完成。</p><p>Redis 对字典的哈希表执行 rehash 的步骤如下：</p><ol><li>为字典的 ht[1] 哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及 ht[0] 当前包含的键值对数量（也即是 ht[0].used 属性的值）： <ul><li>如果执行的是扩展操作，那么 ht[1] 的大小为第一个大于等于 ht[0].used*2 的2^n。</li><li>如果执行的是收缩操作，那么 ht[1] 的大小为第一个大于等于 ht[0].used 的2^n。</li></ul></li><li>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面：rehash 指的是重新计算键的哈希值和索引值，然后将键值对放置到 ht[1] 哈希表的指定位置上。 </li><li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后（ht[0] 变为空表），释放 ht[0]，将 ht[1] 设置为 ht[0]，并在 ht[1] 新创建一个空白哈希表，为下一次 rehash 做准备。</li></ol><h5 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h5><p>跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>跳跃表支持平均 O(logN)、最坏 O(N) 复杂度的节点查找，还可以通过顺序性操作来批处理节点。</p><p><strong>在大部分情况下，跳跃表的效率可以和平衡树相媲美</strong>，并且跳跃表的实现比平衡树要来的更为简单，所以有不少程序都使用跳跃表来代替平衡树。</p><p>Redis使用跳跃表作为有序集合的底层实现之一，并且被用于构建 Redis 集群节点时作为内部数据结构。</p><p>Redis中的跳跃表由 <code>redis.h/zskiplistNode</code> 和 <code>redis.h/zskiplist</code> 两个结构定义。其中 zskiplistNode 结构用于表示跳跃表节点，zskiplist 结构用于保存跳跃表节点的相关信息。一个跳跃表实例如图：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301072229290.png" alt="image-20230107222933229"></p><ul><li><p>zskiplistNode：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 层</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨度，即两个节点之间的距离</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">&#125; level[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后退指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分值</span></span><br><span class="line"><span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员对象</span></span><br><span class="line">robj *obj;</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><ul><li>level[]：数组中的每个元素都是一个 zskiplistLevel 类型的对象。当新的节点被创建时，会随机生成一个1到32之间的值作为 level 数组的大小。<ul><li>zskiplistLevel 的 forward 指针指向下一个节点。</li><li>zskiplistLevel 的 span 属性表示跨度，即到下个节点的距离。如果 forward 指向的是null，则 span 为0。span的主要作用是计算 rank，在查找某个节点的过程中，将沿途的所有 span 累加，就可以得到目标节点的 rank。</li></ul></li><li>backward：用于向表头访问节点。每个节点只有一个 backward 指针，指向前一个节点。</li><li>socre：double 类型，跳跃表中的节点按照 score 进行排名。</li><li>obj：指向一个字符串对象，其中保存着一个 SDS。在一个跳跃表中，obj必须是唯一的。</li></ul></li><li><p>zskiplist：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表头节点和表尾节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表中节点的数量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line"><span class="type">int</span> level;</span><br><span class="line">    </span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure></li></ul><h5 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h5><p>整数集合（intset）是 Redis 中用于保存整数值的集合抽象数据结构。它可以保存类型为 int16_t、int32_t、int64_t 的整数值，并且保证集合中不出现重复元素。</p><p>intset 由 <code>intset.h/intset</code> 定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line"></span><br><span class="line">// 编码方式</span><br><span class="line">uint32_t encoding;</span><br><span class="line"></span><br><span class="line">// 集合包含的元素数量</span><br><span class="line">uint32_t length;</span><br><span class="line"></span><br><span class="line">// 保存元素的数组</span><br><span class="line">int8_t contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><ul><li>contents[]：整数集合中的每个元素都是 contents 数组中的一个数组项，各项在数组中按值的大小从小到大地排列，并且数组中不包含任何重复项。</li><li>encoding：虽然 contents 的属性被声明为 int8_t 类型的数组，但实际上 contents 数组的真正类型取决于 encoding 的值：<ul><li>如果 encoding 的属性为 INTSET_ENC_INT16，则数组的真正类型为 int16_t。</li><li>如果 encoding 的属性为 INTSET_ENC_INT32，则数组的真正类型为 int32_t。</li><li>如果 encoding 的属性为 INTSET_ENC_INT64，则数组的真正类型为 int64_t。</li></ul></li></ul><p>每当需要添加一个新元素到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先对数组进行升级（即给数组重新分配空间，并且移动原来的数据到新的位置），才能将新元素添加到整数集合里。</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>前面介绍完了 Redis 用到的主要数据结构，但是 Redis 并没有直接使用这些数据结构来实现键值对，而是基于这些数据结构创建了一个对象系统，其中包含了字符串对象、列表对象、哈希对象、集合对象和有序集合对象。每种对象都至少用到了一种数据结构。除此之外，Redis 的对象系统还实现了基于引用计数的内存回收机制和对象共享机制。</p><p>Redis使用对象来表示数据库中的键和值，每当我们在 Redis 的数据库中新创建一个键值对时，我们至少会创建两个对象，一个是键对象，一个是值对象。</p><p>Redis中的每个对象都由 redisObject 结构表示，该结构中有三个最重要的属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型</span></span><br><span class="line"><span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码</span></span><br><span class="line"><span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line"><span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后一次访问时间</span></span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><ul><li><p>type记录了对象的类型，这个属性的值可以是：</p><table><thead><tr><th>对象</th><th>type属性的值</th><th>TYPE命令的输出</th></tr></thead><tbody><tr><td>字符串对象</td><td>REDIS_STRING</td><td>“string”</td></tr><tr><td>列表对象</td><td>REDIS_LIST</td><td>“list”</td></tr><tr><td>哈希对象</td><td>REDIS_HASH</td><td>“hash”</td></tr><tr><td>集合对象</td><td>REDIS_SET</td><td>“set”</td></tr><tr><td>有序集对象</td><td>REDIS_ZSET</td><td>“zset”</td></tr></tbody></table><p>对于键对象来说，它的值永远是字符串类型，而键对象对应的值对象可以是以上五种。因此，当我们称呼一个键对象为：“字符串键”或“列表键”时，指的都是这个键对象所对应的值对象。</p></li><li><p>encoding记录了对象所使用的编码，即底层使用的数据结构：</p><table><thead><tr><th>编码常量</th><th>编码对应的底层数据结构</th></tr></thead><tbody><tr><td>REDIS_ENCODING_INT</td><td>long类型整数</td></tr><tr><td>REDIS_ENCODING_EMBSTR</td><td>smbstr编码的简单动态字符串</td></tr><tr><td>REDIS_ENCODING_RAW</td><td>简单动态字符串</td></tr><tr><td>REDIS_ENCODING_HT</td><td>字典</td></tr><tr><td>REDIS_ENCODING_LINKEDLIST</td><td>双端链表</td></tr><tr><td>REDIS_ENCODING_ZIPLIST</td><td>压缩列表</td></tr><tr><td>REDIS_ENCODING_INTSET</td><td>整数集合</td></tr><tr><td>REDIS_ENCODING_SKIPLIST</td><td>跳跃表和字典</td></tr></tbody></table><p>每种对象都至少使用了两种不同的编码：</p><table><thead><tr><th>类型</th><th>编码</th><th>对象</th></tr></thead><tbody><tr><td>REDIS_STRING</td><td>REDIS_ENCODING_INT</td><td>使用整数实现的字符串对象</td></tr><tr><td>REDIS_STRING</td><td>REDIS_ENCODING_EMBSTR</td><td>使用embstr编码的简单动态字符串实现的字符串对象</td></tr><tr><td>REDIS_STRING</td><td>REDIS_ENCODING_RAW</td><td>使用简单动态字符串实现的字符串对象</td></tr><tr><td>REDIS_LIST</td><td>REDIS_ENCODING_ZIPLIS</td><td>使用压缩列表实现的列表对象</td></tr><tr><td>REDIS_LIST</td><td>REDIS_ENCODING_LINKEDLIST</td><td>使用双端链表实现的列表对象</td></tr><tr><td>REDIS_HASH</td><td>REDIS_ENCODING_ZIPLIST</td><td>使用压缩列表实现的哈希对象</td></tr><tr><td>REDIS_HASH</td><td>REDIS_ENCODING_HT</td><td>使用字典实现的哈希对象</td></tr><tr><td>REDIS_SET</td><td>REDIS_ENCODING_INTSET</td><td>使用整数集合实现的集合对象</td></tr><tr><td>REDIS_SET</td><td>REDIS_ENCODING_HT</td><td>使用字典实现的集合对象</td></tr><tr><td>REDIS_ZSET</td><td>REDIS_ENCODING_ZIPLIST</td><td>使用压缩列表实现的有序集合对象</td></tr><tr><td>REDIS_ZSET</td><td>REDIS_ENCODING_SKIPLIST</td><td>使用跳跃表和字典实现的有序集合对象</td></tr></tbody></table><p>可以通过 <code>OBJECT ENCODING key</code> 查看数据库键的值对象编码。</p><p>Redis使用 type 配合 encoding 来设定某个对象的抽象类型和具体实现类型，极大地提升了 Redis 的灵活性和效率。因为 Redis 可以在不同的场景下为一个对象设置不同的 encoding 来切换它的具体实现，从而优化在某一场景下的效率。</p></li></ul><h5 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h5><p>字符串对象对应 Redis 命令中的 String 操作。</p><p>字符串对象的 encoding 属性可以是 int、raw、embstr：</p><ul><li>int：字符串对象保存的是一个可以用 long 类型表示的整数值。字符串对象的 ptr 属性会由 void* 转变为 long，然后将值存在 ptr 属性中。</li><li>raw：字符串对象保存的是一个长度大于 32 字节的字符串。字符串对象的 ptr 属性指向这个字符串SDS的地址。</li><li>embstr：字符串对象保存的是一个长度小于等于 32 字节的字符串。字符串对象的 ptr 属性指向这个字符串SDS的地址。</li></ul><blockquote><p>embstr 是一种专门用于保存短字符串的优化编码方式。这种编码和 raw 编码一样，都使用了 redisObject 结构和 sdshdr 结构。</p><p>但是 raw 编码会调用两次内存分配来分别创建 redisObject 结构和 sdshdr 结构，而 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含 redisObject 和 sdshdr 结构。并且 embstr 是只读的，因为 Redis 中并没有提供修改其值的 API。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301110128268.png" alt="image-20230111012820188"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301110128491.png" alt="image-20230111012831453"></p></blockquote><p>浮点数在 Redis 中也是作为字符串值来保存的。在保存时会将浮点数先转换为字符串值，然后再保存；在有需要时，会将保存的字符串值转换为浮点数值，再执行某些操作。</p><p><strong>编码转换</strong></p><p>当对 int 编码的字符串对象执行了一些命令（例如 append ）时这个对象对象不再是整数，字符串对象的编码就会变为 raw；由于 embstr 编码是只读的，因此对 embstr 编码的字符串对象执行修改操作时，编码也会变成 raw。</p><h5 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h5><p>列表对象对应 Redis 命令中的 list 操作。</p><p>列表对象的 encoding 属性可以是 ziplist、linkedlist：</p><ul><li><p>ziplist：列表对象使用压缩列表作为底层实现。每个压缩列表的节点（entry）保存了一个列表元素。</p><p>执行代码 <code>RPUSH numbers 1 &quot;three&quot; 5</code> 后，将创建如下对象：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301120630884.png" alt="image-20230111175717385"></p></li><li><p>linkedlist：列表对象使用双向链表作为底层实现。每个双向链表的结点（node）保存了一个<strong>字符串对象</strong>。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301120630629.png" alt="image-20230111175730989"></p></li></ul><blockquote><p>图8-6中的 StringObject 表示的是一个字符串对象，即下图的简写。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301111758851.png" alt="image-20230111175823810"></p></blockquote><p><strong>编码转换</strong></p><p>当列表对象满足以下条件时，会优先使用 ziplist 编码以节约内存：</p><ul><li>列表对象所保存的所有字符串元素的长度小于 64 字节。</li><li>列表对象保存的元素数量小于 512 个。</li></ul><p>如果不能同时满足以上条件，则使用 linkedlist 编码。</p><h5 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h5><p>哈希对象对应 Redis 命令中的 hash 操作。</p><p>哈希对象的 encoding 属性可以是 ziplist、hashtable：</p><ul><li><p>ziplist：哈希对象使用压缩列表作为底层实现。每当有新的键值对要加入，程序会先将保存了键的节点推入压缩列表表尾，再将保存了值的节点推入压缩列表表尾。</p><p>执行代码 <code>HSET profile name &quot;Tom&quot;</code>、<code>HSET profile age 25</code>、<code>HSET profile career &quot;Programmer&quot;</code> 后，将创建如下对象：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301112313837.png"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301112317659.png" alt="image-20230111231342321"></p></li><li><p>hashtable：哈希对象使用字典作为底层实现。哈希对象中的每个键值对都用一个字典键值对来保存。字典中的键和值都是字符串对象。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301112346521.png" alt="image-20230111234642471"></p></li></ul><p><strong>编码转换</strong></p><p>当哈希对象同时满足以下两个条件时，使用 ziplist：</p><ul><li>哈希对象保存的所有键和值的字符串长度都小于 64 字节。</li><li>哈希对象保存的键值对数量小于 512 个。</li></ul><p>如果不能同时满足以上条件，则使用 hashtable 编码。</p><h5 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h5><p>集合对象对应 Redis 命令中的 set 操作。</p><p>集合对象的 encoding 属性可以是 intset、hashtable：</p><ul><li><p>intset：集合对象使用整数集合作为底层实现。集合对象保存的所有元素都被保存在整数集合中。</p><p>执行代码 <code>SADD numbers 1 3 5</code> 后，将创建如下对象：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301112354459.png" alt="image-20230111235446411"></p></li><li><p>hashtable：集合对象使用字典作为底层实现。字典的每个键都是一个字符串对象，用于保存集合元素，而字典的值全部被设置为 NULL。</p><p>执行代码 <code>SADD fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</code> 后，将创建如下对象：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301112358752.png" alt="image-20230111235822709"></p></li></ul><p><strong>编码转换</strong></p><p>当集合对象同时满足以下两个条件式，使用 intset：</p><ul><li>集合对象保存的所有元素都是整数值。</li><li>集合对象保存的元素数量不超过 512 个。</li></ul><p>如果不能同时满足以上条件，则使用 hashtable 编码。</p><h5 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h5><p>有序集合对象对应 Redis 命令中的 zset 操作。</p><p>有序集合对象的 encoding 属性可以是 ziplist、skiplist：</p><ul><li><p>ziplist：有序集合对象使用压缩列表作为底层实现。每个有序集合元素占用两个相邻的压缩列表节点，第一个节点用于保存有序集合元素的值，第二个节点用于保存有序集合元素的 score。</p><p>压缩列表内的有序集合元素按照分值从小到大进行排序，分值较小的元素靠近表头，分值较大的元素靠近表尾。</p><p>执行代码 <code>ZADD price 8.5 apple 5.0 banana 6.0 cherry</code> 后，将创建如下对象：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301120606916.png" alt="image-20230112060641853"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301120609250.png" alt="image-20230112060656478"></p></li><li><p>skiplist：有序集合对象使用 zset 结构作为底层实现。一个 zset 结构同时包含一个字典和一个跳跃表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p>zset 结构中的 zsl 跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素。跳跃表节点的 obj 属性保存了元素的值，跳跃表节点的 score 属性保存了元素的 score；zset 结构中的 dict 字典为有序集合创建了一个从值到 score 的映射。同时使用跳跃表和字典，是为了提高有序集合的性能（例如跳跃表可以提供一些范围操作，字典可以提供 O(1) 复杂度的 score 查找）。</p><p>虽然 zset 结构会同时使用字典和跳跃表，但是这两种数据结构会通过指针来共享相同的集合元素值和 score，因此不会浪费内存。</p><p>执行代码 <code>ZADD price 8.5 apple 5.0 banana 6.0 cherry</code> 后，将创建如下对象：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301120659350.png" alt="image-20230112065940303"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301120659181.png" alt="image-20230112065959122"></p></li></ul><p><strong>编码转换</strong></p><p>当有序集合对象同时满足以下两个条件式，使用 ziplist：</p><ul><li>有序集合对象保存的元素数量小于 128 个。</li><li>有序集合对象保存的所有元素的长度都小于 64 字节。</li></ul><p>如果不能同时满足以上条件，则使用 hashtable 编码。</p><h5 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h5><p>Redis 中的命令基本上可以分为两种类型，一种可以用于操作任何类型的键（例如 DEL、EXPIRE 等），另一种只能针对特定类型的键执行（例如 GET 只能针对字符串键，HGET 只能针对哈希键）。</p><p><strong>类型检查</strong>：对于有类型限制的命令，Redis 执行命令前会先检查键的类型即 redisObject 的 type 属性是否正确。正确就执行，不正确则抛出错误。</p><p><strong>命令多态</strong>：对于某些 redisObject，它的底层实现有很多种，例如列表对象的底层实现有 ziplist 和 linkedlist，而命令的执行本质上是调用底层实现提供的 API。对于这种情况，程序在通过 redisObject 的 type 属性检查完类型后，还需要根据 encoding 属性找出具体实现。</p><h5 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h5><p>因为 C 语言不具备自动内存回收的功能，所以 Redis 在自己的对象系统使用了引用计数的方式实现了内存回收。</p><p>每个对象的引用计数信息由 redisObject 的 refcount 属性记录。</p><p>对象的引用技术信息会随着对象的使用状态而不断变化：</p><ul><li>创建的新对象的引用计数值为 1。</li><li>当一个对象被新程序使用，引用计数值 +1；</li><li>当一个对象不再被程序使用，引用计数值 -1；</li><li>当对象的引用计数值变为 0，对象所占用的内存会被释放。</li></ul><h5 id="内存共享"><a href="#内存共享" class="headerlink" title="内存共享"></a>内存共享</h5><p>和 Java 的字符串常量池类似，Redis 中需要使用某个字符串对象时，不会优先去创建这个字符串对象，而是会去查找是否有相同的已创建的字符串对象，如果有，则会进行对象复用而不是创建新对象以节省内存。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h4><p>Redis 服务器将所有数据库都保存在 <code>redis.h/redisServer</code> 结构的 <code>db</code> 数组中，<code>db</code> 数组的每个项都是一个 <code>redis.h/redisDb</code> 结构，每个 <code>redisDb</code> 结构代表一个数据库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存服务器中所有数据库的数组</span></span><br><span class="line">redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器的数据库数量</span></span><br><span class="line">    <span class="type">int</span> dbnum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>服务器初始化时，会根据 <code>dbnum</code> 属性来决定创建多少个数据库。<code>dbnum</code> 属性的值由服务器配置的 <code>database</code> 选项决定，默认情况下，会创建 16 个数据库。</p><h4 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h4><p>每个 Redis 客户端都有自己的目标数据库，每当客户端执行数据库读写命令时，目标数据库就会称为这些命令的操作对象。默认情况下，客户端的目标数据库为 0 号数据库，但客户端可以通过 <code>SELECT</code> 命令来切换目标数据库。</p><p>在服务器内部，有一个 <code>redisClient</code> 结构用于描述客户端的状态，其中的 db 属性就记录了这个客户端当前的目标数据库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 指向当前正在使用的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    </span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><h4 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h4><p>Redis 中使用 <code>redis.h/redisDb</code> 结构来表示数据库，其中的 dict 字典属性保存了这个数据库中保存的所有键值对，这个字典被称为键空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">dict *dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>用户通过 Redis 客户端可见的数据库实际上就是键空间：</p><ul><li>键空间的键是用户可见的数据库的键，每个键都是字符串对象。</li><li>键空间的值是用户可见的数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象等。</li></ul><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301140705201.png"></p><p>所有针对数据库的操作，例如添加一个键值对到数据库中或者从数据库中删除一个键值对，实际上都是通过对键空间字典进行操作来实现的。</p><h4 id="键的过期和删除"><a href="#键的过期和删除" class="headerlink" title="键的过期和删除"></a>键的过期和删除</h4><p>Redis 中可以给键设置生存时间或给键设置过期时间，服务器会定时自动删除过期的键。</p><h5 id="键的过期"><a href="#键的过期" class="headerlink" title="键的过期"></a>键的过期</h5><p>四个设置过期时间或者生存时间的命令：</p><ul><li><code>EXPIRE key ttl</code>：将 key 的生存时间设置为 ttl 秒。</li><li><code>PEXPIRE key ttl</code>：将 key 的生存时间设置为 ttl 毫秒。</li><li><code>EXPIREAT key timestamp</code>：将 key 的过期时间设置为 timestamp 所指定的秒数时间戳。</li><li><code>PEXPIREAT key timestamp</code>：将 key 的过期时间设置为 timestamp 所指定的毫秒数时间戳。</li></ul><p>以上四个命令最终都会转换成 <code>PEXPIREAT</code> 命令来执行。</p><p>每个键的过期时间由 <code>redisDb</code> 结构中的 <code>expires</code> 字典属性保存，这个属性被称为过期字典。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// 过期字典，保存着键的过期时间</span><br><span class="line">dict *expires;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><ul><li>过期字典的键是指针，指向键空间的某个键对象（即某个数据库键）。</li><li>过期字典的值是一个 long long 类型的整数，这个整数保存了键所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</li></ul><h5 id="键的删除"><a href="#键的删除" class="headerlink" title="键的删除"></a>键的删除</h5><p>Redis 中使用的是惰性删除和定期删除两种策略：</p><ul><li>惰性删除：每次从键空间获取键时，都会检查是否过期，如果过期则删除。</li><li>定期删除：每隔一段时间就对数据库进行一次检查，删除其中的过期键。</li></ul><h6 id="惰性删除的实现"><a href="#惰性删除的实现" class="headerlink" title="惰性删除的实现"></a>惰性删除的实现</h6><p>过期键的惰性删除策略由 <code>db.c/expireIfNeeded</code> 函数实现，所有读写数据库的 Redis 命令在执行前都会调用这个函数对键进行检查：</p><ul><li>如果键已过期，则 <code>expireIfNeeded</code> 函数会将其删除。</li><li>如果键未过期，则不进行任何操作。</li></ul><h6 id="定期删除的实现"><a href="#定期删除的实现" class="headerlink" title="定期删除的实现"></a>定期删除的实现</h6><p>过期间的定期删除策略由 <code>redis.c/activeExpireCycle</code> 函数实现。此外，Redis 中还有一个定时函数 <code>redis.c/serverCron</code>，每隔一段时间就会被调用一次，<code>serverCron</code> 会调用 <code>activeExpireCycle</code> 函数。<code>activeExpireCycle</code> 函数会在规定时间内分多次遍历服务器中的各个数据库，从数据库的 expires 字典中随机检查一部分键的过期时间，并且删除其中的过期键。</p><h3 id="服务器线程模型与事件"><a href="#服务器线程模型与事件" class="headerlink" title="服务器线程模型与事件"></a>服务器线程模型与事件</h3><p>Redis 服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p><ul><li>文件事件：客户端或者其他服务器与当前服务器通过 socket 进行连接，文件事件就是对 socket 操作的抽象。</li><li>时间事件：例如定时任务。</li></ul><h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><p>Redis 基于单 Reactor 模型构建了文件事件处理器。Redis 中的 IO 多路复用通过封装 select、epoll、evport、kqueue 等系统调用实现。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301170650368.png" alt="image-20230117065048290"></p><ul><li><p>IO 多路复用程序负责监听多个 socket，并且通过队列向文件事件分派器传送产生了事件的 socket（类似 Java NIO 中的 Selector）。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301170650825.png" alt="image-20230117065037752"></p></li><li><p>文件事件分派器负责根据 socket 所产生的事件的类型，调用对应的事件处理器。</p></li></ul><p>虽然文件事件处理器以单线程方式运行，但是通过 IO 多路复用来监听多个 socket，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他单线程运行的模块进行对接，保持了 Redis 内部单线程设计的简单性。</p><h4 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h4><p>Redis 的时间事件分为两种：</p><ul><li>定时事件：让程序在指定的时间后执行一次。</li><li>周期性事件：让程序每隔指定时间就执行一次。</li></ul><p>一个时间事件由三个属性组成：</p><ul><li>id：时间事件的全局唯一 ID，ID 从小到大顺序递增，新事件的 ID 比旧事件的 ID 大。</li><li>when：毫秒精度的 UNIX 时间戳，记录了时间事件的到达时间。</li><li>timeProc：时间事件处理函数。当时间事件到达时，服务器就会调用这个函数处理时间事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理函数的返回值：</p><ul><li>如果事件处理函数返回值为 <code>ae.h/AE_NOMORE</code>，那么这个事件就是定时事件，该事件到达一次之后就会被删除，不会再次到达。</li><li>如果事件处理函数返回值为非 <code>ae.h/AE_NOMORE</code> 的整数值，那么这个事件为周期性时间。该事件到达后，服务器会根据事件处理函数的返回值对时间事件的 when 属性进行更新。</li></ul><p>所有的时间事件都存放在一个无序链表中（无序指不按 when 排序），新的事件插入到表头。每当时间事件执行器运行时，就会遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理函数。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301170741518.png" alt="image-20230117074123448"></p><blockquote><p>时间事件应用实例：serverCron 函数</p><p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由 <code>redis.c/serverCron</code> 函数负责执行，它的主要工作包括：</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用 情况等。</li><li>清理数据库中的过期键值对。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行AOF或RDB持久化操作。</li><li>如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><p>Redis服务器以周期性事件的方式来运行 serverCron 函数，在服务器运行期间，每隔一段时间，serverCron 就会执行一次，直到服务器关闭为止。 </p><p>在Redis2.6版本，服务器默认规定 serverCron 每秒运行10次，平均每间隔100毫秒运行一次。 </p><p>从Redis2.8开始，用户可以通过修改hz选项来调整 serverCron 的每秒执行次数</p></blockquote><h4 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h4><p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理文件事件，何时又应该处理时间事件，以及花多少时间来处理它们等等。</p><p>事件的调度和执行由 <code>ae.c/aeProcessEvents</code> 函数负责，以下是该函数的伪代码表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">aeProcessEvents</span><span class="params">()</span>:</span><br><span class="line"></span><br><span class="line">#获取到达时间离当前时间最接近的时间事件</span><br><span class="line">time_event = aeSearchNearestTimer()</span><br><span class="line"></span><br><span class="line">#计算最接近的时间事件距离到达还有多少毫秒</span><br><span class="line">remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line"></span><br><span class="line">#如果事件已到达，那么remaind_ms的值可能为负数，将它设定为<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">    remaind_ms = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">#根据remaind_ms的值，创建timeval结构</span><br><span class="line">timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line"></span><br><span class="line">#阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定</span><br><span class="line">#如果remaind_ms的值为<span class="number">0</span>，那么aeApiPoll调用之后马上返回，不阻塞</span><br><span class="line">aeApiPoll(timeval)</span><br><span class="line"></span><br><span class="line">#处理所有已产生的文件事件</span><br><span class="line">processFileEvents()</span><br><span class="line"></span><br><span class="line">#处理所有已到达的时间事件</span><br><span class="line">processTimeEvents()</span><br></pre></td></tr></table></figure><p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，这就构成了Redis服务器的主函数，以下是该函数的伪代码表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">main</span><span class="params">()</span>:</span><br><span class="line"></span><br><span class="line">#初始化服务器</span><br><span class="line"><span class="title function_">init_server</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">#一直处理事件，直到服务器关闭为止</span><br><span class="line"><span class="keyword">while</span> <span class="title function_">server_is_not_shutdown</span><span class="params">()</span>:</span><br><span class="line">       <span class="title function_">aeProcessEvents</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">#服务器关闭，执行清理操作</span><br><span class="line"><span class="title function_">clean_server</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301170751032.png" alt="image-20230117075104979"></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>Redis 服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务 器则接收并处理客户端发送的命令请求，并向客户端返回命令回复。</p><p>Redis 的服务器状态结构中的 clients 属性保存了所有与服务器连接的客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个链表，保存了所有客户端状态</span></span><br><span class="line"><span class="built_in">list</span> *clients;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301180244513.png" alt="image-20230118024444449"></p><p>对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的 <code>redis.h/redisClient</code> 结构（客户端状态），这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构，其中包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisClient &#123;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">// 客户端正在使用的套接字描述符</span><br><span class="line">int fd;</span><br><span class="line"></span><br><span class="line">// 客户端的名字</span><br><span class="line">robj *name;</span><br><span class="line"></span><br><span class="line">// 标志</span><br><span class="line">int flags;</span><br><span class="line"></span><br><span class="line">// 输入缓冲区</span><br><span class="line">sds querybuf;</span><br><span class="line"></span><br><span class="line">// 命令和命令参数</span><br><span class="line">robj **argv;</span><br><span class="line"></span><br><span class="line">// 命令参数个数</span><br><span class="line">int argc;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><ul><li>fd：记录客户端正在使用的套接字描述符。伪客户端的 fd 属性为 -1；普通客户端的 fd 属性值为大于 -1 的整数。</li><li>name：默认情况下，客户端没有蜜罐子，可以通过 <code>CLIENT SETNAME nickname</code> 命令设置名字。</li><li>flags：记录了客户端的角色以及客户端目前所处的状态。flags 属性的值可以是单个标志，也可以是多个标志的二进制或。</li><li>querybuf：保存客户端发送的命令请求。</li><li>argv：服务器将客户端发送的命令请求保存到 querybuf 后，对命令进行分析。将命令参数存放入 argv 数组。argv[0] 存放的是命令，其余的是命令参数。</li><li>argc：记录 argv 的长度。</li></ul><h2 id="Redis进阶使用"><a href="#Redis进阶使用" class="headerlink" title="Redis进阶使用"></a>Redis进阶使用</h2><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis 是一个基于内存的数据库，它将自己的数据库状态（非空数据库和其保存的键值对）存储在内存中，如果不想办法将存储在内存中的数据保存到磁盘中，那么一旦服务器进程退出，服务器中的数据也就消失了。</p><p>为了解决这个问题，Redis 提供了持久化的功能，这个功能可以将 Redis 内存中的数据保存到磁盘中，避免数据意外丢失。</p><p>Redis 中有两种持久化方式：</p><ul><li>RDB：保存数据库中的键值对。</li><li>AOF：保存服务器所执行的写命令。</li></ul><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB 持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个 RDB 文件中，文件名为 <code>dump.rdb</code>。</p><p>RDB 持久化功能所生成的 RDB 文件是一个经过压缩的二进制文件，通过该文件可以还原生成 RDB 文件时的数据库状态。只要 RDB 文件存在，服务器就可以用它来还原数据库状态。</p><h5 id="RDB的创建与载入"><a href="#RDB的创建与载入" class="headerlink" title="RDB的创建与载入"></a>RDB的创建与载入</h5><p>有两个 Redis 命令可以用于生成 RDB 文件：</p><ul><li>SAVE：阻塞 Redis 服务进程，直到 RDB 创建完成。</li><li>BGSAVE：创建子进程执行 RDB 的创建。</li></ul><p>RDB 文件的载入是在服务器启动时自动执行的，Redis 并没有专门用于载入 RDB 文件的命令。当 Redis 服务器启动时检测到有 RDB 文件存在，就会自动载入 RDB 文件。服务器在载入 RDB 文件期间，会一直处于阻塞状态。</p><blockquote><p>通常 AOF 文件的更新频率比 RDB 文件的更新频率高，因此如果服务器开启了 AOF 持久化，则服务器会优先使用 AOF 文件来还原数据。</p></blockquote><p>创建 RDB 文件的实际工作由 <code>rdb.c/rdbSave</code> 函数完成，载入 RDB 文件的实际工作由 <code>rdb.c/rdbLoad</code> 完成。</p><h5 id="RDB自动保存"><a href="#RDB自动保存" class="headerlink" title="RDB自动保存"></a>RDB自动保存</h5><p>用户可以通过在 Redis 的配置文件中配置 save 选项，让服务器在满足条件时自动执行一次 BGSAVE 命令。</p><p>Redis 默认的 save 选项是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>意思是只要满足以下三个条件的任意一个，就会执行 BGSAVE 命令：</p><ul><li>在 900 秒内，对数据库进行了至少 1 次修改。</li><li>在 300 秒内，对数据库进行了至少 10 次修改。</li><li>在 60 秒内，对数据库进行了至少 10000 次修改。</li></ul><h5 id="RDB文件"><a href="#RDB文件" class="headerlink" title="RDB文件"></a>RDB文件</h5><p>RDB文件生成和载入的位置可以在 Redis 配置文件中通过 dir 选项配置，默认值是 <code>./</code> 即 Redis 安装位置。</p><p><strong>RDB 文件的结构</strong></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301160414639.png" alt="image-20230116041414565"></p><ul><li>REDIS：长度为 5 字节。保存着 <code>REDIS</code> 这五个字符，用于让 Redis 判断这个文件是否是 RDB 文件。</li><li>db_version：长度为 4 字节，表示 RDB 文件的版本号。</li><li>databases：保存着非空数据库中的键值对。</li><li>EOF：长度为 1 字节。标志着 RDB 文件正文内容结束。</li><li>check_sum：长度为 8 字节。用于校验 RDB 文件。</li></ul><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>被写入 AOF 的所有命令是以 Redis 的命令请求协议格式保存的，因为 Redis 的命令请求协议是纯文本格式，因此可以直接打开一个 AOF 文件，观察其中的内容。</p><h5 id="AOF文件写入过程"><a href="#AOF文件写入过程" class="headerlink" title="AOF文件写入过程"></a>AOF文件写入过程</h5><p>AOF 文件写入过程可以分为：</p><ul><li><p>命令追加：Redis 在执行完一个写命令，会先将命令追加到服务器状态的 aof_buf 缓冲区末尾：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AOF 缓冲区</span></span><br><span class="line">sds aof_buf;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>文件写入：调用 write 系统调用，将数据写入文件，对于操作系统来说，实际上是将数据写入操作系统的缓冲区。</p></li><li><p>文件同步：将操作系统缓冲区中的数据同步到磁盘中，可以通过调用 fsync 系统调用强制执行。</p></li></ul><p>AOF配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 默认配置</span><br><span class="line">appendonly no   # 是否开启AOF</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;  # AOF文件名</span><br><span class="line">appendfsync everysec  # AOF 同步策略</span><br></pre></td></tr></table></figure><p>appendfsync 策略：</p><ul><li>always：每当触发命令追加，都会同时触发文件写入和文件同步；</li><li>everysec：每当触发命令追加，都会触发文件写入，并且每隔一秒执行一次文件同步；</li><li>no：每当触发命令追加，都会触发文件写入，但是文件同步的具体时间由操作系统决定。</li></ul><h5 id="AOF文件载入过程"><a href="#AOF文件载入过程" class="headerlink" title="AOF文件载入过程"></a>AOF文件载入过程</h5><p>AOF 文件中保存了所有写命令，因此服务器只要读入并重新执行一遍 AOF 文件里保存的写命令，就可以还原服务器关闭之前的数据库状态。</p><p>Redis 读取 AOF 文件并且载入数据的过程：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301160633454.png" alt="image-20230116063347363"></p><h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p>在 Redis 长期运行的过程中，AOF 文件会变得越来越长，导致载入的速度变得很慢。由于 AOF 只是原封不动地追加写命令，因此会有很多冗余的命令占据 AOF 文件。</p><p>为了减小 AOF 文件的大小，Redis 提供了 AOF 重写机制。重写实际上是 Redis 通过当前数据库状态，生成最简短的写命令然后重新生成 AOF 文件的过程。</p><p>可以通过手动执行 <code>BGREWRITEAOF</code> 命令开始重写 AOF 文件，也可以通过配置文件自动触发：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 默认配置</span><br><span class="line">auto-aof-rewrite-percentage 100 # 触发重写所需要的 aof 文件体积百分比，即当AOF文件的增量比上一次 AOF 重写大多少时，才进行重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb # 表示触发AOF重写的最小文件体积,大于或等于64MB自动触发。</span><br></pre></td></tr></table></figure><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>全量备份，一次保存整个数据库</td><td>增量备份，只保存从开启 AOF 后的写命令<br>（当重写后，AOF中的数据也是全量的）</td></tr><tr><td>每次执行持久化操作间隔较久</td><td>保存的间隔短，默认文件同步时间为 1 秒</td></tr><tr><td>数据格式为二进制，还原快</td><td>数据格式为文本，还原慢</td></tr></tbody></table><p>Redis 中关于 RDB 和 AOF 载入，都是在 Redis 服务器启动时自动执行的，并且这个载入的过程实际上是<strong>覆盖原本的数据</strong>，因此在使用时需要特别注意。</p><p>尤其是当原本没有开启 AOF 功能时，如果要开启 AOF 并且要保证数据不丢失，可以通过以下两种方法：</p><ul><li>通过 Redis 的配置文件开启 AOF，并且执行一遍 <code>BGREWRITEAOF</code> 手动重写 AOF，以保证 AOF 文件中的数据是全量的（否则 AOF 文件中还没有数据，此时如果直接重启服务器，服务器从 AOF 文件还原数据，就将数据全部清空了，并且 RDB 也会直接清空）。</li><li>通过 <code>redis-cli config set appendonly yes</code> 命令开启 AOF，这个命令会自动执行一遍 <code>BGREWRITEAOF</code>。</li></ul><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>Redis 中有两种发布订阅模式：</p><ul><li>基于频道（channel）的发布订阅。</li><li>基于模式（pattern）的发布订阅。</li></ul><h4 id="基于频道"><a href="#基于频道" class="headerlink" title="基于频道"></a>基于频道</h4><p>通过执行 <code>SUBSCRIBE</code> 命令，客户端可以订阅一个或多个频道。每当有其他客户端通过 <code>PUBLISH</code> 向频道发送消息时，频道的所有订阅者都会收到这条消息。</p><p>例如客户端 A、B、C 都通过 <code>SUBCRIBE news.it</code> 订阅了 news.it 频道。此时有其他客户端通过 <code>PUBLISH news.it hello</code> 向 news.it 频道发送了 hello 消息，则客户端 A、B、C 都会收到 hello 消息。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301182055642.png" alt="image-20230118205540586"></p><p>当客户端执行完 <code>SUBSCRIBE</code> 命令后，会进入订阅状态，处于此状态下的客户端不能使用除 <code>SUBSCRIBE</code>、<code>UNSUBSCRIBE</code>、<code>PSUBSCRIBE</code> 和 <code>PUNSUBSCRIBE</code> 这四个属于”发布&#x2F;订阅”之外的命令。</p><p>进入订阅状态后客户端可能收到三种类型的回复，每种类型的回复都包含三个值，第一个值是消息的类型，根据消息类型的不同，第二个和第三个参数的含义也不同。</p><p>消息类型的取值可能是以下三个：</p><ul><li>subscribe：表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个是当前客户端订阅的频道数量。</li><li>message：表示接收到的消息，第二个值表示产生消息的频道名称，第三个值是消息的内容。</li><li>unsubscribe：表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为0时客户端会退出订阅状态，之后就可以执行其他非”发布&#x2F;订阅”模式的命令了。</li></ul><h4 id="基于模式"><a href="#基于模式" class="headerlink" title="基于模式"></a>基于模式</h4><p>通过执行 <code>PSUBSCRIBE</code> 命令，客户端可以订阅一个或多个模式。每当有其他客户端通过 <code>PUBLISH</code> 向频道发送消息时，除了该频道的订阅者外，所有符合条件的模式也会收到消息（实际上就是通配符）。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301182343893.png" alt="image-20230118234331833"></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>Redis 中一个事务从开始到解树通常会经过以下三个阶段：事务开始、命令入队，事务执行。</p><h4 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h4><p>MULTI 命令的执行标志着事务的开始：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">MULTI</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>MULTI 命令可以将执行该命令的客户端从非事务状态切换到事务状态。这一切换是通过在客户端状态中的 flags 属性中打开 REDIS_MULTI 标识来完成的。</p><h4 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h4><p>当一个客户端处于正常状态时（非事务），客户端发送的命令会立即被服务器执行。</p><p>当一个客户端切换到事务状态后，服务器会根据这个客户端发来的不同命令执行不同操作：</p><ul><li>如果客户端发送的命令为 <code>EXEC</code>、<code>DISCARD</code>、<code>WATCH</code>、<code>MULTI</code> 四个命令中的一个，那么服务器会立即执行这个命令。</li><li>否则，服务器将命令放入事务队列中，然后向客户端返回 QUEUED 回复。</li></ul><h4 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h4><p>当一个处于事务状态的客户端向服务器发送 <code>EXEC</code> 命令时，这个 <code>EXEC</code> 命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。</p><h4 id="WATCH命令"><a href="#WATCH命令" class="headerlink" title="WATCH命令"></a>WATCH命令</h4><p><code>WATCH</code> 命令是一个乐观锁，它可以在执行 <code>EXEC</code> 命令之前监视任意数量的数据库键。</p><p>当执行 <code>EXEC</code> 命令时，如果程序发现 <code>WATCH</code> 监视的键值对有改动，则 <code>EXEC</code> 命令会执行失败。</p><h3 id="慢查询日志和监视器"><a href="#慢查询日志和监视器" class="headerlink" title="慢查询日志和监视器"></a>慢查询日志和监视器</h3><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>Redis 的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。</p><p>服务器配置有两个和慢查询日志相关的选项： </p><ul><li>slowlog-log-slower-than：指定执行时间超过多少微秒的命令请求会被记录到日志上。</li><li>slowlog-max-len：指定服务器最多保存多少条慢查询日志。</li></ul><p>可以通过 <code>SLOWLOG GET</code> 命令获取慢查询日志，也可以加一个参数表示要获取多少条慢查询日志。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; slowlog get 3</span><br><span class="line">1) 1) (integer) 6107</span><br><span class="line">   2) (integer) 1616398930</span><br><span class="line">   3) (integer) 3109</span><br><span class="line">   4) 1) &quot;config&quot;</span><br><span class="line">      2) &quot;rewrite&quot;</span><br><span class="line">2) 1) (integer) 6106</span><br><span class="line">   2) (integer) 1613701788</span><br><span class="line">   3) (integer) 36004</span><br><span class="line">   4) 1) &quot;flushall&quot;</span><br><span class="line">3) 1) (integer) 6105</span><br><span class="line">   2) (integer) 1608722338</span><br><span class="line">   3) (integer) 20449</span><br><span class="line">   4) 1) &quot;scan&quot;</span><br><span class="line">      2) &quot;0&quot;</span><br><span class="line">      3) &quot;MATCH&quot;</span><br><span class="line">      4) &quot;*comment*&quot;</span><br><span class="line">      5) &quot;COUNT&quot;</span><br><span class="line">      6) &quot;10000&quot;</span><br></pre></td></tr></table></figure><p>每一条慢查询日志都有4个属性组成：</p><ol><li>唯一标识ID</li><li>命令执行的时间戳</li><li>命令执行时长</li><li>执行的命名和参数</li></ol><p>可以通过 <code>SLOWLOG LEN</code> 命令获取慢查询日志的长度，通过 <code>SLOWLOG RESET</code> 命令重置慢查询日志。</p><h4 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h4><p>通过执行 <code>MONITOR</code> 命令，可以让当前的客户端变为监视器，实时地接收并打印出服务器当前处理地命令请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MONITOR</span><br><span class="line">OK</span><br><span class="line">1378822099.421623 [0 127.0.0.1:56604] &quot;PING&quot;</span><br><span class="line">1378822105.089572 [0 127.0.0.1:56604] &quot;SET&quot; &quot;msg&quot; &quot;hello world&quot;</span><br><span class="line">1378822109.036925 [0 127.0.0.1:56604] &quot;SET&quot; &quot;number&quot; &quot;123&quot;</span><br><span class="line">1378822140.649496 [0 127.0.0.1:56604] &quot;SADD&quot; &quot;fruits&quot; &quot;Apple&quot; &quot;Banana&quot; &quot;Cherry&quot;</span><br><span class="line">1378822154.117160 [0 127.0.0.1:56604] &quot;EXPIRE&quot; &quot;msg&quot; &quot;10086&quot;</span><br><span class="line">1378822257.329412 [0 127.0.0.1:56604] &quot;KEYS&quot; &quot;*&quot;</span><br><span class="line">1378822258.690131 [0 127.0.0.1:56604] &quot;DBSIZE&quot;</span><br></pre></td></tr></table></figure><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>虽然 Redis 服务器的性能很高，但是当面对海量数据时，所有的读写压力全部落在一台服务器上，很有可能造成服务器运行效率低下、遇到故障无法快速处理等问题。</p><p>因此 Redis 推出了主从复制功能，它可以通过 <code>REPLICAOF</code> 命令（Redis 5.0 之前是 <code>SLAVEOF</code>）将一台 Redis 服务器的数据，持续地复制到其他的 Redis 服务器。前者称为主节点(master)，后者称为从节点(slave)。一般来说，可以让主节点负责处理写请求，从节点负责处理读取请求，即<strong>读写分离</strong>。</p><p>数据的复制是单向的，只能由主节点到从节点。建立连接后，可以通过 <code>INFO REPLICATION</code> 命令查看当前服务器的主从复制信息。</p><p>主从复制的作用主要包括：</p><ul><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li><li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h4 id="复制功能的实现"><a href="#复制功能的实现" class="headerlink" title="复制功能的实现"></a>复制功能的实现</h4><p>Redis 的复制功能分为<strong>同步</strong>和<strong>命令传播</strong>两个操作。</p><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>当客户端向服务器发送 <code>REPLICAOF</code> 命令，要求从服务器复制主服务器时，从服务器首先要执行同步操作，即将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</p><p>从服务器对主服务的同步操作需要通过向主服务器发送 <code>PSYNC</code> 命令来完成。<code>PSYNC</code> 命令具有完整重同步和部分重同步两种模式：</p><h6 id="完整重同步"><a href="#完整重同步" class="headerlink" title="完整重同步"></a>完整重同步</h6><p>用于处理初次复制的情况。大致过程如下：</p><ol><li>收到 <code>PSYNC</code> 命令的主服务器执行 <code>BGSAVE</code> 命令，在后台生成一个 RDB 文件，并且使用一个缓冲区记录从现在开始执行的所有写命令。</li><li>当主服务器的 <code>BGSAVE</code> 命令执行完后，主服务器会将 <code>BGSAVE</code> 命令生成的 RDB 文件发送给从服务器，从服务器接收载入这个 RDB 文件。此时从服务器的数据库状态和主服务器执行 BGSAVE 命令时的一致。</li><li>主服务器将记录在缓冲区中的所有写命令发送给从服务器，从服务器执行这些命令。此时从服务器的数据库状态更新至主服务器当前所处的状态。</li></ol><h6 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h6><p>用于处理短线重连后的复制情况。</p><p>部分重同步功能由以下三个部分组成：</p><ul><li><p>主服务器和从服务器的复制偏移量</p><p>主服务器和从服务器会分别维护一个复制偏移量。主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N；从服务器每次收到主服务器传播过来的N个字节的数据时，就将自己的复制偏移量的值加上N。</p><p><img src="C:\Users\summer\AppData\Roaming\Typora\typora-user-images\image-20230120045802098.png" alt="image-20230120045802098"></p><p>通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态。</p></li><li><p>主服务器的复制积压缓冲区。</p><p>复制积压缓冲区是由主服务器维护的一个固定长度队列，默认大小为1MB。当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301200500516.png" alt="image-20230120050016455"></p><p>因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301200501301.png" alt="image-20230120050121243"></p><p>当从服务器重新连上主服务器时，从服务器会通过 <code>PSYNC</code> 命令将自己的复制偏移量 offset 发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：</p><ul><li>如果 offset 偏移量之后的数据（也即是偏移量 offset+1 开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作。<strong>即将从服务器断线这段时间，主服务器执行的写命令都传输给从服务器执行，从服务器只需要接收这部分数据即可回到和主服务器一致的状态</strong>。</li><li>如果 offset 偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。</li></ul></li><li><p>服务器的运行ID</p><p>除了复制偏移量和复制积压缓冲区之外，实现部分重同步还需要用到服务器运行ID。每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID，运行ID在服务器启动时自动生成，由40个随机的十六进制字符组 成。</p><p>当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID。如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作；否则，主服务器将对从服务器执行完整重同步操作。</p></li></ul><h5 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h5><p>在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态不再一致。</p><p>为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。</p><h4 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h4><p>给从服务器设置主服务器的三种方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端发送命令</span></span><br><span class="line">127.0.0.1:6379&gt; replicaof 127.0.0.1 6378</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端启动参数</span></span><br><span class="line">[root@fengye ~] redis-server --replicaof 127.0.0.1 6378</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置文件</span></span><br><span class="line">[root@fengye ~] vim redis.conf</span><br><span class="line">replicaof 127.0.0.1 6378</span><br></pre></td></tr></table></figure><p>查看当前服务器的主从复制信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">172.17.0.2:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:172.17.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:down</span><br><span class="line">master_last_io_seconds_ago:-1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:504</span><br><span class="line">slave_repl_offset:504</span><br><span class="line">master_link_down_since_seconds:-1</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:606b845f475010a5b558185924dc555616f912b6</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:504</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:504</span><br></pre></td></tr></table></figure><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>当主从复制中的主服务器出现故障，需要把某台从服务器切换为主服务器，代替主服务器工作的过程，叫故障转移（failover）。</p><p>在 Redis 主从复制模式中，故障转移的过程是手动的。在这个过程中，不仅需要人为干预，而且还会造成一段时间内服务器处于不可用状态，同时数据安全性也得不到保障。</p><p>而 Redis Sentinel 哨兵模式，它弥补了主从模式的不足：哨兵通过发送命令来监控主服务器和从服务器的运行状态。当主服务器宕机时，哨兵会在从服务器中选出一个作为主服务器，并且以发布订阅模式通知其他从服务器，让它们切换主机。</p><p>并且多个哨兵之间还可以互相进行监控，保证了哨兵的高可用。</p><h4 id="配置过程-1"><a href="#配置过程-1" class="headerlink" title="配置过程"></a>配置过程</h4><p>配置3哨兵1主2从的 Redis 服务器</p><table><thead><tr><th>服务类型</th><th>是否是主服务器</th><th>IP地址</th><th>端口</th></tr></thead><tbody><tr><td>Redis</td><td>是</td><td>127.0.0.1</td><td>6379</td></tr><tr><td>Redis</td><td>否</td><td>127.0.0.1</td><td>6378</td></tr><tr><td>Redis</td><td>否</td><td>127.0.0.1</td><td>6377</td></tr><tr><td>Sentinel</td><td>-</td><td>127.0.0.1</td><td>26379</td></tr><tr><td>Sentinel</td><td>-</td><td>127.0.0.1</td><td>26378</td></tr><tr><td>Sentinel</td><td>-</td><td>127.0.0.1</td><td>26377</td></tr></tbody></table><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301210755536.png" alt="image-20230121075547425"></p><h5 id="配置主从服务器"><a href="#配置主从服务器" class="headerlink" title="配置主从服务器"></a>配置主从服务器</h5><p>redis-1.conf：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">requirepass &quot;123456&quot;</span><br></pre></td></tr></table></figure><p>reids-2.conf：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 6378</span><br><span class="line">replicaof 127.0.0.1 6379</span><br><span class="line">requirepass &quot;123456&quot;</span><br><span class="line"></span><br><span class="line"># 主服务器配置了需要密码，这里从服务器就需要配置密码验证</span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure><p>redis-3.conf：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 6377</span><br><span class="line">replicaof 127.0.0.1 6379</span><br><span class="line">requirepass &quot;123456&quot;</span><br><span class="line"></span><br><span class="line"># 主服务器配置了需要密码，这里从服务器就需要配置密码验证</span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure><h5 id="配置哨兵"><a href="#配置哨兵" class="headerlink" title="配置哨兵"></a>配置哨兵</h5><p>sentinel-1.conf：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># 为哨兵配置需要密码认证</span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line"># 配置连接其他哨兵时验证的密码</span><br><span class="line">sentinel sentinel-pass 123456</span><br><span class="line"></span><br><span class="line"># 修改为后台运行</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># 配置监听的主服务器，mymaster 代表服务器的名称，可以自定义。2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行 failover 操作。</span><br><span class="line"># 这里 ip 不能用 127.0.0.1</span><br><span class="line">sentinel monitor mymaster 101.35.46.160 6379 2</span><br><span class="line"></span><br><span class="line"># 配置主服务器密码</span><br><span class="line">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure><p>sentinel-2.conf：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">port 26378</span><br><span class="line"></span><br><span class="line"># 为哨兵配置需要密码认证</span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line"># 配置连接其他哨兵时验证的密码</span><br><span class="line">sentinel sentinel-pass 123456</span><br><span class="line"></span><br><span class="line"># 修改为后台运行</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># 配置监听的主服务器，mymaster 代表服务器的名称，可以自定义。2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行 failover 操作。</span><br><span class="line"># 这里 ip 不能用 127.0.0.1</span><br><span class="line">sentinel monitor mymaster 101.35.46.160 6379 2</span><br><span class="line"></span><br><span class="line"># 配置主服务器密码</span><br><span class="line">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure><p>sentinel-3.conf：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">port 26377</span><br><span class="line"></span><br><span class="line"># 为哨兵配置需要密码认证</span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line"># 配置连接其他哨兵时验证的密码</span><br><span class="line">sentinel sentinel-pass 123456</span><br><span class="line"></span><br><span class="line"># 修改为后台运行</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># 配置监听的主服务器，mymaster 代表服务器的名称，可以自定义。2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行 failover 操作。</span><br><span class="line"># 这里 ip 不能用 127.0.0.1</span><br><span class="line">sentinel monitor mymaster 101.35.46.160 6379 2</span><br><span class="line"></span><br><span class="line"># 配置主服务器密码</span><br><span class="line">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure><h5 id="启动主从服务器和哨兵"><a href="#启动主从服务器和哨兵" class="headerlink" title="启动主从服务器和哨兵"></a>启动主从服务器和哨兵</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /www/server/redis/src</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./redis-server ../redis-1.conf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./redis-server ../redis-2.conf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./redis-server ../redis-3.conf</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./redis-sentinel ../sentinel-1.conf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./redis-sentinel ../sentinel-2.conf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./redis-sentinel ../sentinel-3.conf</span></span><br></pre></td></tr></table></figure><h5 id="整合-Spring-Boot"><a href="#整合-Spring-Boot" class="headerlink" title="整合 Spring Boot"></a>整合 Spring Boot</h5><p>yml配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="comment"># 主服务器的名称</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span></span><br><span class="line">      <span class="comment"># 哨兵节点</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">101.35</span><span class="number">.46</span><span class="number">.160</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">101.35</span><span class="number">.46</span><span class="number">.160</span><span class="string">:26378</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">101.35</span><span class="number">.46</span><span class="number">.160</span><span class="string">:26377</span></span><br><span class="line">      <span class="comment"># 哨兵的密码</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 数据库的密码</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xhn200232</span></span><br></pre></td></tr></table></figure><p>配置读写分离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder -&gt; builder.readFrom(ReadFrom.REPLICA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>哨兵本质上只是一个运行在特殊模式下的 Redis 服务器。</p><h5 id="启动准备"><a href="#启动准备" class="headerlink" title="启动准备"></a>启动准备</h5><p>当一个哨兵启动时，它会根据哨兵配置文件中的配置，创建连向主服务器的网络连接，成为主服务器的客户端。</p><p>对于每个被哨兵监视的主服务器，哨兵会创建两个连向主服务器的异步网络连接：</p><ul><li>一个是命令连接，用于向主服务器发送命令。</li><li>一个是订阅连接，用于订阅主服务器的 <code>__sentinel__:hello</code> 频道。</li></ul><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301220422910.png" alt="image-20230122042210853"></p><h5 id="获取主服务器信息"><a href="#获取主服务器信息" class="headerlink" title="获取主服务器信息"></a>获取主服务器信息</h5><p>Redis 默认会以每十秒一次的频率，通过命令连接向被监视的主服务器发送 INFO 命令，然后对其分析从而获取主服务器的当前信息。</p><p>通过分析主服务器返回的 INFO 命令回复，哨兵可以获取以下信息：                                           </p><ul><li>主服务器本身的信息，例如服务器运行 id，当前服务器的 role。</li><li>主服务器属下的所有从服务器的信息，包括从服务器的 ip、port。根据这些信息，哨兵无须用户提供从服务器的地址信息，就可以自动发现从服务器。</li></ul><p>当哨兵发现主服务器又新的从服务器出现时，就会与新的从服务器创建命令连接和订阅连接。</p><p>当哨兵与从服务器建立命令连接后，会同样以每十秒一次的频率向从服务器发送 INFO 命令。</p><h5 id="向发送信息并接收信息"><a href="#向发送信息并接收信息" class="headerlink" title="向发送信息并接收信息"></a>向发送信息并接收信息</h5><p>在默认情况下，哨兵会以每两秒一次的频率通过命令连接向所有被监视的主服务器和从服务器发送如下格式的命令：<code>PUBLISH __sentinel__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</code>。</p><p>这条命令向服务器的 <code>__sentinel__:hello</code> 频道发送了一条信息，信息的内容由多个参数组成：</p><ul><li>s_ip：当前哨兵的 IP 地址</li><li>s_port：当前哨兵的端口号</li><li>s_runid：当前哨兵的运行 ID</li><li>s_epoch：当前哨兵的配置纪元</li><li>m_name：主服务器的名字</li><li>m_ip：主服务器的 IP 地址</li><li>m_port：主服务器的端口号</li><li>m_epoch：主服务器的配置纪元</li></ul><p>当哨兵和一个服务器建立起订阅连接后，就会通过订阅连接，向服务器发送以下命令：<code>SUBSCRIBE __sentinel__:hello</code>，从而让订阅连接进入订阅模式。</p><p>对于每个与哨兵连接的服务器，哨兵既通过命令连接向服务器的 <code>__sentinel__:hello</code> 频道发送信息，又通过订阅连接从服务器的 <code>__sentinel__:hello</code> 频道接收信息。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301220618943.png" alt="image-20230122061825878"></p><p>对于监视同一个服务器的多个哨兵来说，其中一个哨兵发送的信息会被其他几个哨兵接收到，这些信息会被用于更新其他哨兵对于发送信息哨兵的认知，也会被用于更新其他哨兵对被监视服务器的认知。即实现哨兵之间的互相发现和对服务器状态信息的共享。</p><p>当哨兵通过频道信息发送一个新的哨兵时，会创建一个连向新哨兵的命令连接，而新哨兵也会同样创建连向这个哨兵的命令连接。最终监视同一个主服务器的多个哨兵之间将形成相互连接的网络。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301220622136.png" alt="image-20230122062226079"></p><h5 id="检测下线状态"><a href="#检测下线状态" class="headerlink" title="检测下线状态"></a>检测下线状态</h5><p>在默认情况下，哨兵会以每秒一次的频率向所有与它创建了命令连接的实例（主、从服务器和其他哨兵）发送 PING 命令，并通过实例的回复判断对方是否在线。</p><p>当实例在一段时间内连续向哨兵返回无效回复，那么哨兵就会标记这个实例为<strong>主观下线</strong>。</p><p>当哨兵将一个主服务器判断为主观下线后，为了确认这个主服务器是否真的下线了，它会向同样监视这个主服务器的其他哨兵进行询问。当哨兵从其他哨兵处接收到足够多的主管下线判断时，就会将主服务器判定为<strong>客观下线</strong>。</p><h5 id="选举领头哨兵"><a href="#选举领头哨兵" class="headerlink" title="选举领头哨兵"></a>选举领头哨兵</h5><p>当一个主服务器被判断为<strong>客观下线</strong>时，监视这个下线主服务器的各个哨兵会通过 Raft 算法，选举出一个领头哨兵，并由领头哨兵对下线主服务器执行故障转移操作。</p><blockquote><p>选举规则：</p><ul><li>所有在线的哨兵都有被选为领头哨兵的资格。</li><li>每次进行领头哨兵选举之后，不论选举是否成功，所有哨兵的配置纪元的值都会自增一次。配置纪元实际上就是一个计数器。 </li><li>在一个配置纪元里面，所有哨兵都有一次将某个哨兵设置为局部领头哨兵的机会，并且局部领头一旦设置，在这个配置纪元里面就不能再更改。 </li><li>每个发现主服务器进入客观下线的哨兵都会要求其他哨兵将自己设置为局部领头哨兵。 </li><li>哨兵设置局部领头哨兵的规则是先到先得：最先向目标哨兵发送设置要求的源哨兵将成为目标哨兵的局部领头哨兵，而之后接收到的所有设置要求都会被目标哨兵拒绝。  </li><li>如果有某个哨兵被半数以上的哨兵设置成了局部领头哨兵，那么这个哨兵成为领头哨兵。</li><li>因为领头哨兵的产生需要半数以上哨兵的支持，并且每个哨兵在每个配置纪元里面只能设置一次局部领头哨兵，所以在一个配置纪元里面，只会出现一个领头哨兵。 </li><li>如果在给定时限内，没有一个哨兵被选举为领头哨兵，那么各个哨兵将在一段时间之后再次进行选举，直到选出领头哨兵为止。</li></ul></blockquote><h5 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h5><p>当选举出领头哨兵后，领头哨兵将对已下线的主服务器进行故障转移操作，该操作分为以下三个步骤：</p><ol><li>在已下线主服务器属下的所有从服务器里面，挑选出一个状态良好、数据完整的从服务器，向其发送 <code>REPLICAOF no one</code> 命令，将其设置为主服务器。</li><li>向已下线主服务器属下的所有从服务器发送 <code>REPLICAOF &lt;ip&gt; &lt;port&gt;</code> 命令，令其复制新的主服务器。</li><li>将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</li></ol><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>虽然哨兵+主从复制的模式通过读写分离和自动故障转移在大多数情况下满足了高可用的要求，但是这种模式还是存在着一些问题：</p><ul><li>主从复制虽然实现了读写分离，但是写入操作实际上全部落在了 master 节点上，如果面临同时有大量写请求的高并发场景，很容易造成 master 节点的压力上升。</li><li>无论是从节点还是主节点，本质上都只是用一台 Redis 服务器存储了所有的数据，数据量太大意味着持久化成本高等问题。</li></ul><p>因此 Redis 3.0 正式加入了集群模式，实现了数据的分布式存储，通过对数据进行分片，将不同的数据存储在不同的 master 节点中，从而解决了海量数据的问题。并且集群中也实现了主从复制和自动故障处理。</p><p>Redis 集群采用去中心化的思想，没有中心节点的说法，对于客户端来说，整个集群可以看成一个整体，可以连接任意一个节点进行操作，就像操作单一 Redis 实例一样，不需要任何代理中间件。</p><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h5><p>一个 Redis 集群由多个节点（node）组成，一个节点就是一个运行在集群模式下的 Redis 服务器。当 Redis 服务器启动时，如果 <code>cluster-enabled</code> 配置的选项为 yes，则会开启服务器的集群模式。另外，节点只能使用 0 号数据库，而单机服务器则没有这一限制。</p><p>在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。</p><p>连接各个节点的工作可以用 <code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code> 命令来完成。向一个节点 node 发送 <code>CLUSTER MEET</code> 命令，可以让 node 节点与所指定的节点进行握手。当握手成功后，node 节点就会将所指定的节点添加到 node 节点当前所在的集群中。</p><p>可以使用 <code>CLUSTER NODE</code> 命令查看当前节点所在集群的信息。</p><h5 id="槽"><a href="#槽" class="headerlink" title="槽"></a>槽</h5><p>Redis 集群通过分片的方式保存数据库中的键值对：集群的整个数据库被分为 16384 个槽（slot），数据库中的每个键都被分配到 16384 个槽中的一个，集群中的每个节点可以处理 0 到 16384 个槽。</p><p>当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态（ok）；否则，处于下线状态（fail）。</p><p>通过向节点发送 <code>CLUSTER ADDSLOTS &lt;slot&gt; [slot ...]</code> 命令，可以将一个或多个槽指派给节点负责。</p><h5 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h5><p>当数据库的 16384 个槽都进行指派后，集群就会进入上线状态，这时客户端就可以向集群中的节点发送数据命令了。</p><p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己：</p><ul><li>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。</li><li>如果键所在的槽并没有指派给当前节点，那么当前节点将客户端重定向到至正确的节点，并再次发送之前想要执行的命令。</li></ul><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301230949998.png" alt="image-20230123094910880"></p><blockquote><p>计算 key 属于哪个槽的方式：CRC16(key) &amp; 16383</p></blockquote><h5 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h5><p>Redis 集群的重新分片操作可以将任意数量已经指派给某个节点的槽改为指派给另外一个节点，并且相关槽所属的键值对也会被移动到目标节点。</p><p>重新分片的操作是在线进行的，在重新分配的过程中，集群不需要下线，并且源节点和目标节点可以继续处理命令请求。</p><p>Redis集群的重新分片操作是由 Redis 的集群管理软件 redis-trib 负责执行的，Redis 提供了进行重新分片所需的所有命令，而 redis-trib 则通过向源节点和目标节点发送命令来进行重新分片操作。</p><p>redis-trib 对集群的单个槽 slot 进行重新分片的步骤如下：</p><ol><li>redis-trib 对目标节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code> 命令，让目标节点准备好从源节点导入（import）属于槽 slot 的键值对。</li><li>redis-trib 对源节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code> 命令，让源节点准备好将属于槽slot的键值对迁移（migrate）至目标节点。</li><li>redis-trib 向源节点发送 <code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code> 命令，获得最多count个属于槽slot的键值对的键名（key name）。</li><li>对于步骤3获得的每个键名，redis-trib 都向源节点发送一个 <code>MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;</code> 命令，将被选中的键原子地从源节点迁移至目标节点。</li><li>重复执行步骤3和步骤4，直到源节点保存的所有属于槽 slot 的键 值对都被迁移至目标节点为止。</li><li>redis-trib 向集群中的任意一个节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_id&gt;</code> 命令，将槽 slot 指派给目标节点，这一指派信息会通过消息发送至整个集群，最终集群中的所有节点都会知道槽 slot 已经指派给了目标节点。</li></ol><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202301240210749.png" alt="image-20230124021027665"></p><p>在重新分片期间，源节点向目标节点迁移槽的过程中，会出现这样一种情况：被迁移槽的一部分键值对保存在源节点中，另一部分键值对则保存在目标节点中。</p><p>而此时，如果客户端接收到了一个命令，并且命令所处理的键刚好属于被迁移槽时：</p><ul><li>源节点会现在自己的数据库中查找指定的键，如果找到则正常执行命令。</li><li>如果源节点没能在数据库中找到指定的键，那么就返回一个 ASK 错误，并且将客户端重定向到目标节点，再次发送之前的命令。</li></ul><h5 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h5><p>Redis 集群中的节点分为主节点和从节点，主节点用于处理槽，从节点用于复制某个主节点，并且在主节点下线后，接管原来节点负责处理的槽，代替主节点继续执行命令。而原来的主节点重新上线后，会称为新主节点的从节点。可以向一个节点发送 <code>CLUSTER REPLICATE &lt;node_id&gt;</code>，让这个节点称为指定节点的从节点。</p><h6 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h6><p>集群中的每个节点都会定期地向集群中地其他节点发送 PING 消息，以此来检测对方是否在线。如果接收 PING 消息地节点没有在规定时间内返回 PONG 消息，那么发送 PING 消息地节点就会将接收 PING 消息的节点标记为疑似下线（PFAIL）。</p><p>集群中各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息。在一个集群中，如果半数以上负责负责处理槽的主节点都将某个主节点报告为疑似下线，那么这个主节点 x 将被标记为已下线。将 x 标记为下线的节点会向集群广播一条关于 x 的下线信息，所有收到这条信息的节点都会立即将 x 标记为下线。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </p><h6 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h6><p>故障转移过程：</p><ul><li>下线的主节点的所有从节点中，会有一个从节点通过 Raft 算法被选中。</li><li>被选中的从节点会执行 <code>REPLICAOF no one</code> 命令，成为新的主节点。</li><li>新的主节点将原主节点的所有槽都重新指派给自己</li><li>新主节点向集群中的所有节点广播一条 PONG 消息，通知其他节点，这个节点已经成为了新的主节点。</li><li>新主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li></ul><h5 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h5><p>集群中各个节点通过发送和接收消息来进行通信。称发送消息的节点为发送者，接收消息的节点为接收者。</p><p>节点发送的消息主要有以下五种：</p><ul><li>MEET 消息：当发送者接到客户端发送的 <code>CLUSTER MEET</code> 命令时，发送者会向接收者发送 MEET 消息，请求接收者加入到发送者当前所处的集群里面。 </li><li>PING 消息：集群里的每个节点默认每隔一秒钟就会从已知节点中随机选出五个节点，然后对这五个节点中最长时间没有发送过 PING 消息的节点发送 PING 消息，以此来检测被选中的节点是否在线。除此之外，如果节点 A 最后一次收到节点 B 发送的 PONG 消息的时间距离当前时间已经超过了节点 A 的 <code>cluster-node-timeout</code> 选项设置时长的一半，那么节点 A 也会向节点 B 发送 PING 消息，这可以防止节点 A 因为长时间没有随机选中节点 B 作为 PING 消息的发送对象而导致对节点 B 的信息更新滞后。 </li><li>PONG 消息：当接收者收到发送者发来的 MEET 消息或者 PING 消息时，为了向发送者确认这条 MEET 消息或者 PING 消息已到达，接收者会向发送者返回一条 PONG 消息。另外，一个节点也可以通过向集群广播自己的 PONG 消息来让集群中的其他节点立即刷新关于这个节点的认识，例如当一次故障转移操作成功执行之后，新的主节点会向集群广播一条 PONG 消息，以此来让集群中的其他节点立即知道这个节点已经变成了主节点，并且接管了已下线节点负责的槽。 </li><li>FAIL 消息：当一个主节点 A 判断另一个主节点 B 已经进入 FAIL 状态时，节点 A 会向集群广播一条关于节点 B 的 FAIL 消息，所有收到这条消息的节点都会立即将节点 B 标记为已下线。 </li><li>PUBLISH 消息：当节点接收到一个 PUBLISH 命令时，节点会执行 这个命令，并向集群广播一条 PUBLISH 消息，所有接收到这条 PUBLISH 消息的节点都会执行相同的 PUBLISH 命令。</li></ul><h4 id="配置过程-2"><a href="#配置过程-2" class="headerlink" title="配置过程"></a>配置过程</h4><p>搭建集群有两种方法：手动搭建和自动搭建。主要介绍自动搭建。</p><p>在 Redis 5.0 之前，自动搭建集群通过 src 目录下的 <code>redis-trib.rb</code> 实现。Redis 5.0 之后，自动搭建集群可以直接通过 <code>redis-cli</code> 实现。</p><p>参考：<a href="https://segmentfault.com/a/1190000017151802">spring - 深入理解Redis系列之集群环境搭建 - 后端系列进阶 - SegmentFault 思否</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>配置HTTPS</title>
      <link href="/2023/01/18/%E9%85%8D%E7%BD%AEHTTPS/"/>
      <url>/2023/01/18/%E9%85%8D%E7%BD%AEHTTPS/</url>
      
        <content type="html"><![CDATA[<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>由于 HTTP 本身是使用明文通信的，不加密、无法验证通信方的身份、无法证明报文的完整性，因此 HTTPS 出现了。HTTPS 本质上就是 HTTP 与 SSL&#x2F;TLS 的组合。</p><p><strong>HTTPS要解决的问题：</strong></p><ul><li>加密：保证信息不会泄露</li><li>证明：保证信息来源于目标服务器，并且不被篡改</li></ul><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><h4 id="对称加密-共享密钥加密"><a href="#对称加密-共享密钥加密" class="headerlink" title="对称加密&#x2F;共享密钥加密"></a>对称加密&#x2F;共享密钥加密</h4><p>服务器和客户端使用相同的加密&#x2F;解密密钥。但是密钥需要传递交给对方，而一旦在互联网上传递，密钥就会泄露，也就失去了加密的意义。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202211180100945.png" alt="image-20221118010004817"></p><h4 id="非对称加密-公开密钥加密"><a href="#非对称加密-公开密钥加密" class="headerlink" title="非对称加密&#x2F;公开密钥加密"></a>非对称加密&#x2F;公开密钥加密</h4><p>非对称加密使用的是两把密钥，一把叫私钥（不能公开），一把叫公钥（公开）。信息在经过公钥&#x2F;私钥加密后，需要用另外一把密钥来解密。</p><p>如果两方需要通信，一方可以先将公钥发送给对方，私钥自己保留。需要发送信息时，将待发送信息用自己的密钥进行加密；需要接收信息时，将接收到的信息用自己的密钥进行解密。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202211182042388.png" alt="image-20221118204207303"></p><p>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</p><h4 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h4><p>虽然非对称加密比对称加密要安全，但是处理速度却比对称加密要慢。因此 HTTPS 采用了混合加密机制。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202211182101525.png" alt="image-20221118210152453"></p><p>即<strong>用非对称加密的方式来传递对称加密的密钥，后续通信通过对称加密</strong>。</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p><strong>为了证明客户端收到的公钥是目标服务器的</strong>，服务器会把公钥放在<strong>数字证书</strong>中发送出去。<strong>数字证书是一串包含服务器公钥并且能够证明服务器身份的字符串</strong>，数字证书一般是有权威的CA机构颁发的。</p><p><strong>为了证明数字证书不被篡改</strong>，需要在数字证书中附带<strong>数字签名</strong>。</p><p>CA机构颁发数字证书的流程：</p><ol><li>CA机构有一套自己的公钥和私钥，CA机构先对证书的明文数据（待颁发服务器的公钥、颁发数字证书的机构、签名算法等内容）进行hash运算，并使用私钥对hash运算的结果加密，生成的值就是<strong>数字签名</strong>。</li><li>使用数字证书明文数据和数字签名共同组成数字证书，颁发给目标服务器。</li></ol><p>浏览器验证数字证书的流程：</p><ol><li>从服务器接收到数字证书，获取其中的明文内容和数字签名。</li><li>使用CA机构的公钥（浏览器内置）对数字签名进行解密。</li><li>判断解密出来的值是否等于证书明文部分的hash，如果等于，则表示证书未被篡改并且公钥可信。</li></ol><h2 id="如何给自己的服务器配置数字证书"><a href="#如何给自己的服务器配置数字证书" class="headerlink" title="如何给自己的服务器配置数字证书"></a>如何给自己的服务器配置数字证书</h2><p>CA机构有很多，有免费的也有收费的，<code>Let&#39;s Encrypt</code> 就是其中的一个免费机构。certbot是一个基于 <code>Let&#39;s Encrypt</code> 的自动化申请证书的工具</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>可以在<a href="https://certbot.eff.org/">官网</a>选择自己的操作系统和服务器软件自定义安装。我选择的是 Centos7 和 Nginx。</p><ol><li><p>安装snapd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> yum install snapd</span></span><br></pre></td></tr></table></figure></li><li><p>配置 snap 链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /var/lib/snapd/snap /snap</span></span><br></pre></td></tr></table></figure></li><li><p>通过 snapd 安装 certbot</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> snap install --classic certbot</span></span><br></pre></td></tr></table></figure></li><li><p>配置 certbot 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /snap/bin/certbot /usr/bin/certbot</span></span><br></pre></td></tr></table></figure></li><li><p>申请并安装证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> certbot certonly --nginx --nginx-server-root=/www/server/nginx/conf</span></span><br></pre></td></tr></table></figure></li><li><p>手动修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    # 配置 http 跳转 https</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.fengye404.top fengye404.top;</span><br><span class="line">    return 301 https://$server_name$request_uri; </span><br><span class="line">&#125;</span><br><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name fengye404.top www.fengye404.top;</span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/fengye404.top/fullchain.pem;</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/fengye404.top/privkey.pem;</span><br><span class="line">    index index.php index.html index.htm default.php default.htm default.html;</span><br><span class="line">    root /wordpress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/43789231">彻底搞懂HTTPS的加密原理 - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/jinjiyese153/p/13396918.html">CentOS7下使用Certbot+Nginx搭建Https环境 - 禁忌夜色153 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.jianshu.com/p/116fc2d08165">Nginx强制跳转Https - 简书 (jianshu.com)</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅析网络IO模型</title>
      <link href="/2023/01/17/%E6%B5%85%E6%9E%90%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/01/17/%E6%B5%85%E6%9E%90%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>I&#x2F;O 泛指的是 CPU 向 I&#x2F;O设备（硬盘、网卡）中读取&#x2F;写入数据。而本文主要介绍的是网络 I&#x2F;O，也就是借助于 Socket Api ，从网卡中读取数据。</p><h2 id="Unix网络编程中的五种IO模型"><a href="#Unix网络编程中的五种IO模型" class="headerlink" title="Unix网络编程中的五种IO模型"></a>Unix网络编程中的五种IO模型</h2><blockquote><p>参考：<a href="https://www.jianshu.com/p/486b0965c296">聊聊Linux 五种IO模型 - 简书 (jianshu.com)</a></p></blockquote><p>一个I&#x2F;O操作通常分为两个阶段：</p><ul><li>等待数据准备（从磁盘&#x2F;网卡中读取数据到内核空间中的缓冲区）。</li><li>从内核空间中的缓冲区向用户空间复制数据。</li></ul><h3 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I&#x2F;O"></a>阻塞式I&#x2F;O</h3><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202212011427456.png" alt="img"></p><p>假设在服务器上有一个应用需要接收客户端通过socket传递的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端应用程序伪代码：</span></span><br><span class="line">listen_fd = socket(domain,type,protocol);</span><br><span class="line">bind(listen_fd,server_addr,server_addrlen);</span><br><span class="line">listen(listen_fd,backlog);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//应用执行到accept的时候会被阻塞住，等待客户端的TCP连接</span></span><br><span class="line">accept_fd = accept(listen_id,client_addr,client_addrlen);</span><br><span class="line">    <span class="comment">//建立完TCP连接后，read会再次阻塞应用，等待客户端发送数据</span></span><br><span class="line">read(accept_fd,buf,nbyte);</span><br><span class="line">    <span class="comment">//客户端数据发送完毕后，才能执行逻辑操作</span></span><br><span class="line">logicHandle(buf);</span><br><span class="line">    <span class="comment">//逻辑操作执行完成后，才能重新监听socket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端应用程序伪代码</span></span><br><span class="line">fd = socket(domain,type,protocol);</span><br><span class="line"><span class="comment">//如果此时有其他客户端正在和服务端进行连接，则客户端会被阻塞在connect</span></span><br><span class="line">connect(fd,server_addr,server_addrlen);</span><br><span class="line">write(fd,buf,nbyte);</span><br></pre></td></tr></table></figure><p>通过上述伪代码，不难发现阻塞I&#x2F;O有如下几个问题：</p><ol><li>在同一时间，只能接收一个客户端的连接，如果应用程序是单线程的，就无法实现并发。</li><li>其他客户端必须等待前一个客户端与服务端建立连接+传输数据+逻辑操作全部完成后，才能与服务端执行连接。</li><li>对于服务端来说，虽然应用程序被阻塞，但是CPU任然可以执行其他操作，因此CPU利用率并不低。</li></ol><p>对于阻塞式IO来说，如果想要提高并发能力，同时处理多个服务端请求，就需要对每个服务端的<strong>TCP请求</strong>新建一个线程。如果客户端较多，则会给服务端带来很大的内存和CPU压力。</p><h3 id="非阻塞式I-O"><a href="#非阻塞式I-O" class="headerlink" title="非阻塞式I&#x2F;O"></a>非阻塞式I&#x2F;O</h3><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202212011428391.png" alt="img"></p><p>非阻塞式IO会让accept、read等系统调用不阻塞应用，而是直接返回一个值。可以通过这个值的合法性来判断是否调用成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端应用程序伪代码：</span></span><br><span class="line">listen_fd = socket(domain,type,protocol);</span><br><span class="line">bind(listen_fd,server_addr,server_addrlen);</span><br><span class="line">listen(listen_fd,backlog);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//设置非阻塞</span></span><br><span class="line">    setNonblocking(listen_fd);</span><br><span class="line">    <span class="comment">//接收客户端的连接，非阻塞</span></span><br><span class="line">    accept_fd = accept(listen_fd,client_addr,client_addrlen);</span><br><span class="line">    <span class="comment">//如果返回值合法，则对其进行处理。否则继续循环调用</span></span><br><span class="line">    <span class="keyword">if</span>(accept_fd &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//将socket的fd添加到列表中</span></span><br><span class="line">        fd_list.add(accept_fd);</span><br><span class="line">        <span class="comment">//socket的fd读取客户端发送的数据，</span></span><br><span class="line">        <span class="comment">//这里的read也是非阻塞的</span></span><br><span class="line">        <span class="comment">//实际上现代计算机中的read操作并不是CPU亲自执行，而是委托给DMA处理</span></span><br><span class="line">read(accept_fd,buf,nbyte);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历所有的socket的fd</span></span><br><span class="line">    <span class="keyword">for</span>(fd in fd_list)&#123;</span><br><span class="line">        <span class="comment">//如果fd中的数据准备完毕，则进行对其进行逻辑操作</span></span><br><span class="line">        <span class="keyword">if</span>(read(fd,buf,nbyte) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//这里也可以开启子线程进行逻辑处理，不过这就属于异步的范畴了</span></span><br><span class="line">            logicHandle(buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端应用程序伪代码</span></span><br><span class="line">fd = socket(domain,type,protocol);</span><br><span class="line">connect(fd,server_addr,server_addrlen);</span><br><span class="line">write(fd,buf,nbyte);</span><br></pre></td></tr></table></figure><p>上述伪代码中服务端主要任务是不断接收socket连接并接收其写入的内容，然后<strong>轮询</strong>判断每个socket的fd中的数据是否准备完毕，准备完毕后就执行逻辑操作。</p><p>非阻塞式IO的优点：</p><ul><li>单线程即可处理多个socket连接。</li></ul><p>非阻塞式IO的缺点：</p><ul><li>需要不断进行系统调用(read函数)，导致频繁的内核态、用户态切换，因此CPU利用率反而比阻塞IO低。</li></ul><h3 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I&#x2F;O复用"></a>I&#x2F;O复用</h3><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202212011428975.png" alt="img"></p><p>IO复用即让一个线程可以监听多个IO。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select是Unix提供的一个系统调用函数，其原理与非阻塞式IO相同，只不过是将轮询fd_list的过程从用户态进行系统调用变成直接在内核态判断。select函数是阻塞的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端应用程序伪代码：</span></span><br><span class="line">listen_fd = socket(domain,type,protocol);</span><br><span class="line">bind(listen_fd,server_addr,server_addrlen);</span><br><span class="line">listen(listen_fd,backlog);</span><br><span class="line"><span class="comment">//设置非阻塞</span></span><br><span class="line">setNonblocking(listen_fd);</span><br><span class="line"><span class="comment">//先用非阻塞的形式创建5个socket的fd</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    fd_list[i] = accept(listen_fd,client_addr[i],client_addrlen[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//select会先将fd_list的引用拷贝到内核空间中</span></span><br><span class="line">    <span class="comment">//然后在内核空间对其不断轮询</span></span><br><span class="line">    <span class="comment">//如果有某个fd中存在数据，即客户端建立了连接，则select会返回</span></span><br><span class="line">    select(fd_list_max+<span class="number">1</span>,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//此时用户态的程序并不知道哪个fd中存在数据，因此要遍历一遍</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fd_list[i],&amp;rset))&#123;</span><br><span class="line">        <span class="keyword">for</span>(fd in fd_list)&#123;</span><br><span class="line">            read(fd,buf,nbyte);</span><br><span class="line">            logicHandle(buf);</span><br><span class="line">        &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select的缺点：</p><ul><li>在调用 select 的时候，需要将 fd_list 拷贝到内核空间，产生性能开销。</li><li>在内核态中使用轮询 fd_list 的方式进行监控，占用CPU资源。</li><li>select 返回后，用户态并不知道是哪个 fd 准备就绪，需要再次遍历。</li><li>select 默认只能接收1024个 fd。</li></ul><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 和 select 类似，只是其中的数据结构实现方式不同。</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><blockquote><p>参考：<a href="https://mp.weixin.qq.com/s/OmRdUgO1guMX76EdZn11UQ">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！ (qq.com)</a></p></blockquote><p>epoll 就是为了解决 poll 和 select 的问题而推出的最新的IO复用函数。</p><p>不同于 poll&#x2F;select 在内核态中轮询，epoll 是基于事件回调和中断的。</p><p>epoll包含三个函数：</p><ol><li><p>epoll_create：在内存中创建一个 <code>struct eventpoll</code> 的对象。</p><p>eventpoll 包含三块内容：</p><ul><li><strong>wq</strong>：等待队列。存储阻塞在epoll上的用户进程。</li><li><strong>rbr</strong>：红黑树，节点为 <code>struct epitem</code>。<code>epitem</code> 中有两个重要的元素：<code>socket_fd</code>、<code>ep_poll_callback</code>（<code>ep_poll_callback</code> 是一个回调函数，作用是将这个 <code>socket_fd</code> 添加到 <strong>rdllist</strong> 并唤醒等待队列中的元素）。</li><li><strong>rdllist</strong>：就绪队列。存储准备就绪的 <code>socket_fd</code>。</li></ul></li><li><p>epoll_ctl：注册 <code>socket</code>。</p><p>当使用 <code>epoll_ctl</code> 注册 <code>socket</code> 的时候，内核会将 <code>socket</code> 封装为一个 epitem ，并添加到 <strong>rbr</strong> 中。</p></li><li><p>epoll_wait：获取就绪事件。就绪的事件通过参数回传。</p><p>epoll_wait 被调用时，如果 <strong>rdllist</strong> 中有数据则返回；无数据则将当前线程封装后添加到 <strong>wq</strong> 中，并阻塞当前线程。</p></li></ol><p>客户端发送数据并被 epoll 接收的流程：</p><ol><li>客户端发送数据包到网卡。网卡通过DMA把数据拷贝至内存缓冲区，拷贝完成后发送中断信号。</li><li>CPU接收到中断信号，通过数据包的IP和端口号找到 socket，将数据添加到 socket 中。</li><li>CPU触发回调函数 ep_poll_callback，将 socket 添加到 rdllist 并唤醒等待队列中的线程。</li><li>线程继续执行。</li></ol><p>epoll的优点：</p><ul><li>在 socket 连接较多的情况下，性能优于 select&#x2F;poll。</li></ul><p>epoll的缺点：</p><ul><li>epoll是 linux2.6 内核添加的功能，而 select&#x2F;poll 则是 posix 规范的接口，因此 epoll 只能用于 linux 内核，移植性较差。</li></ul><h4 id="边缘触发和水平触发"><a href="#边缘触发和水平触发" class="headerlink" title="边缘触发和水平触发"></a>边缘触发和水平触发</h4><p>边缘触发和水平触发是两种不同的 I&#x2F;O 处理方式。它们都有各自的优缺点。</p><ul><li>边缘触发（edge-triggered）模式下，选择器会在事件发生时立即触发通知，并且只会触发一次。这种方式可以确保我们在处理事件时不会错过任何数据，但是它可能会导致多次处理同一个事件。</li><li>水平触发（level-triggered）模式下，选择器会在事件发生时立即触发通知，但是会持续触发，直到事件处理完毕。这种方式可以避免多次处理同一个事件，但是它可能会导致数据丢失，因为我们可能在事件发生后处理数据时会错过一些数据。</li></ul><p>通常情况下，我们应该根据具体情况来选择合适的 I&#x2F;O 处理方式。对于实时性要求较高的应用，我们可以使用边缘触发模式；对于需要保证数据不丢失的应用，我们可以使用水平触发模式。</p><h3 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I&#x2F;O"></a>信号驱动I&#x2F;O</h3><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202212011428863.png" alt="img"></p><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p><p>相比于非阻塞式 IO 的轮询方式，信号驱动 IO 的 CPU 利用率更高。</p><h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I&#x2F;O"></a>异步I&#x2F;O</h3><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202212011428396.png" alt="img"></p><p>进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p><p>异步 IO 与信号驱动 IO 的区别在于，异步 IO 的信号是通知应用进程 IO 完成，而信号驱动 IO 的信号是通知应用进程可以开始 IO。</p><h2 id="Java中的IO模型"><a href="#Java中的IO模型" class="headerlink" title="Java中的IO模型"></a>Java中的IO模型</h2><p>Java中的几种IO API：</p><ul><li>阻塞同步IO：BIO</li><li>非阻塞同步IO：NIO</li><li>非阻塞异步IO：AIO</li></ul><p>BIO和NIO的本质区别在于，BIO是面向流（Stream）的，NIO是面向缓冲区（Buffer）的。</p><p>面向流意味着只能单向读取或写入数据，并且每次只能从流中写入&#x2F;读取一个或多个字节，读取和写入时要阻塞至完毕；面向缓冲区则可以双向读取写入，并且数据将会被先读入到缓冲区中，然后再处理。面向缓冲相比于面向流，更加灵活。</p><h3 id="BIO-传统IO模型"><a href="#BIO-传统IO模型" class="headerlink" title="BIO-传统IO模型"></a>BIO-传统IO模型</h3><p>传统IO模型：</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202212030530938.png" alt="image-20221203053005893"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//阻塞监听Socket连接</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot; 连接到服务器&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//每建立一个连接，就创建一个线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//read可能会阻塞</span></span><br><span class="line">                    <span class="keyword">while</span> ((len = inputStream.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot; 发送数据：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>数据传输采用阻塞式IO。</li><li>每个连接需要独立的线程去执行读取、业务逻辑、写入的操作。</li><li>适用于业务逻辑耗时长，低负载、低并发的场景。</li></ul><p>缺点：</p><ul><li>服务端的并发量和线程数成正比。</li><li>由于每个连接都需要独立的线程去处理，因此同时可能会有大量线程被创建，然而这些线程实际上大部分是事件都处于阻塞状态（阻塞在read()）。</li><li>由于accept()是阻塞的，因此可能会存在后面一个连接的请求已经到达，然而前一个连接还没有建立完成，导致接收连接的线程阻塞。（举个例子，假设 ServerSocket 建立每个连接耗时4ms，那么即使CPU性能再高，也会受限于网络的瓶颈，每秒钟最多处理250个连接）</li></ul><h3 id="NIO-Reactor模型"><a href="#NIO-Reactor模型" class="headerlink" title="NIO-Reactor模型"></a>NIO-Reactor模型</h3><p>NIO中的几个概念：</p><ul><li><p>Buffer（缓冲区）</p><p>缓冲区本质上是一块可以读写数据的内存，这块内存被包装成 NIO 的 Buffer 对象，并对外提供一系列方法用于访问该块内存。</p><p>对应于 <code>java.nio.Buffer</code> 抽象类。</p></li><li><p>Channel（通道）</p><p>通道类似 BIO 中的 Stream，用于向 Buffer 中读取或写入数据。</p><p>对应于 <code>java.nio.channels.Channel</code> 接口。</p></li><li><p>Selector（选择器）</p><p>选择器可以检查一个或多个通道，并确定哪些通道已经准备好进行读写。通过 Selector，一个单独的线程可以管理多个 Channel，从而管理多个连接。不过不是所有的 Channel 都可以被 Selector 复用，必须要继承了 SelectableChannel。</p><p>对应于 <code>java.nio.channels.Selector</code> 抽象类。</p></li></ul><p>NIO特点：</p><ul><li>每个 Channel 对应一个 Buffer。</li><li>一个线程对应一个 Selector，一个 Selector 对应多个 Channel。</li><li>Buffer 是一个内存块，底层是数组，可以切换读写模式（实际上是改变参数）。</li></ul><h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p>Buffer的实现类有：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。</p><p>无论是哪一种，管理方式都一致，都是通过 <code>allocate(int capacity)</code> 来获取 Buffer。</p><p><strong>Buffer 的几个重要属性</strong></p><ul><li>capacity：Buffer的最大容量，创建后不能更改。</li><li>limit：缓冲区可以操作的数据大小，index 大于 limit 的数据不能读写。limit 不能为并且不能大于 capacity。在写模式下，limit 等于 capacity；在读模式下，limit 等于当前容量。</li><li>position：下一个要读取或写入的数据的 index。</li><li>mark：标记，可以通过 <code>mark()</code> 方法记录当前 position，然后通过 <code>reset()</code> 恢复 position 的位置。</li></ul><p><strong>Buffer 的几个重要方法</strong></p><ul><li><code>Buffer clear()</code>：清空 Buffer，读模式转变为写模式（position设为0，limit设为capacity，mark设为-1）并返回。</li><li><code>Buffer flip()</code>：写模式转变为读模式（limit设为position，position设为0，mark设为-1）并返回。</li><li><code>get()</code>：获取当前数据类型的一个数据。</li><li><code>put()</code>：存储当前数据类型的一个数据。</li></ul><p><strong>Buffer 读写数据的步骤</strong></p><ol><li>写入数据。</li><li>调用 <code>flip()</code> 切换读取模式。</li><li>读取数据。</li><li>调用 <code>clear()</code> 清除数据。</li></ol><p><strong>直接缓冲区和非直接缓冲区</strong></p><ul><li><p>直接缓冲区：通过 <code>allocate()Direct</code> 创建缓冲区，缓冲区建立在直接内存中。</p><p>直接内存在IO处理时的性能更高，但申请直接内存会耗费更多性能。一般在有大量数据需要存储并且生命周期很长，或者有频繁IO操作时，适合使用直接缓冲区。</p></li><li><p>非直接缓冲区：通过 <code>allocate()</code> 创建缓冲区，缓冲区建立在JVM堆内存中。</p></li></ul><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Channel类似于BIO中的流，用于在支持 Channel 的两个结点中传递数据。但是 Channel 本身并不存储数据，需要配合 Buffer 使用。Channel 的实现类有：FileChannel、SocketChannel、ServerSocketChannel、DatagramChannel。</p><p><strong>获取 Channel 对象的方法</strong></p><ol><li>调用支持 Channel 的对象的 <code>getChannel()</code>。支持 Channel 的对象有：<ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket</li></ul></li><li>通过 Channel 的实现类的静态方法 <code>open()</code>。</li><li><code>Files.newByteChannel()</code></li></ol><p><strong>Channel 的几个重要方法</strong></p><ul><li><code>int read(Buffer dst)</code>：从 Channel 中读取数据到 Buffer。</li><li><code>int write(Buffer src)</code>：将 Buffer 中的数据写入到 Channel 中。</li></ul><p><strong>使用 Channel 完成文件复制的例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 利用通道完成文件的复制(非直接缓冲区)</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fisChannel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">foschannel</span> <span class="operator">=</span> fos.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通道没有办法传输数据，必须依赖缓冲区</span></span><br><span class="line">        <span class="comment">// 分配指定大小的缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将通道中的数据存入缓冲区中</span></span><br><span class="line">        <span class="keyword">while</span> (fisChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;  <span class="comment">// fisChannel 中的数据读到 byteBuffer 缓冲区中</span></span><br><span class="line">            byteBuffer.flip();  <span class="comment">// 切换成读数据模式</span></span><br><span class="line">            <span class="comment">// 将缓冲区中的数据写入通道</span></span><br><span class="line">            foschannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear();  <span class="comment">// 清空缓冲区</span></span><br><span class="line">        &#125;</span><br><span class="line">        foschannel.close();</span><br><span class="line">        fisChannel.close();</span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>Selector 是 Java NIO 中的多路复用器。将 SelectableChannel 注册到 Selector 中，就可以通过一个 Selector 监听多个 SelectableChannel。Selector 和 SelectableChannel 是多对多的关系。</p><p><strong>Selector的基本使用</strong></p><ul><li><p>创建：<code>Selector.open()</code>。由于多路复用需要操作系统提供底层的支持，因此在不同的环境下会提供不同的 Selector 实例。例如 Windows-JDK 下会提供 <code>sun.nio.ch.WindowsSelectorImpl</code>，Linux-JDK 下会提供 <code>sun.nio.ch.EPollSelectorImpl</code>。</p></li><li><p>注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><p>注册到 Selector 的 Channel 必须是非阻塞的，否则会抛出 IllegalBlockingModeException。</p><p><code>register()</code> 的第二个参数表示需要监听的事件，分别为 <code>Connect</code>、<code>Accept</code>、<code>Read</code>、<code>Write</code>，如果需要监听多个事件，可以用 <code>|</code> 分隔。</p></li><li><p>SelectionKey：</p><p>注册后会返回 SelectionKey 的对象，这个对象表示了一个 Channel 和 一个 Selector 的对应关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key.attachment(); <span class="comment">//返回SelectionKey的attachment，attachment可以在注册channel的时候指定。</span></span><br><span class="line">key.channel(); <span class="comment">//返回该SelectionKey对应的channel。</span></span><br><span class="line">key.selector(); <span class="comment">//返回该SelectionKey对应的Selector。</span></span><br><span class="line">key.interestOps(); <span class="comment">//返回监听的事件的bit mask，对应channel.register()的第二个参数</span></span><br><span class="line">key.readyOps(); <span class="comment">//返回已准备就绪的事件的bit mask</span></span><br></pre></td></tr></table></figure></li><li><p>获取就绪的Channel：</p><p>先调用 select() 获取准备就绪的通道数量。select() 相关的几个方法：</p><ul><li>select()：阻塞获取就绪的通道数量。</li><li>select(long timeout)：阻塞获取就绪的通道数量，如果超时则返回0。</li><li>selectNow()：非阻塞获取就绪通道数量。</li></ul><p>（select() 表示从上次调用 select() 后新增了多少已准备就绪的通道）</p><p>如果 select() 返回值不为0，说明有已准备就绪的通道，调用 selector.selectedKeys() 获取通道集合。</p></li></ul><p><strong>NIO基本服务端代码编写</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//使用一个ServerSocketChannel来负责监听accept事件</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (selector.select() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isValid() &amp;&amp; key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">//监听到连接事件，则把这个连接的Channel也注册到selector中</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isValid() &amp;&amp; key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">//监听到读取事件，则进行数据拷贝和逻辑操作</span></span><br><span class="line">                    <span class="comment">//这里可以创建另外的线程去处理，也可以考虑池化</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((len = socketChannel.read(byteBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        byteBuffer.flip();</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array(), <span class="number">0</span>, len));</span><br><span class="line">                        byteBuffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理完后移除当前的SelectionKey</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>由于是非阻塞IO，每当一个连接请求到达，只需要将其注册到 Selector 中，因此单线程可以一直处理连接请求。</li><li>读取数据和逻辑操作与BIO一样，因此NIO的优势在于对连接的处理，即在等待某个连接建立的过程中可以继续和其他请求建立连接。</li><li>适用于业务逻辑耗时短，高负载高并发的场景</li></ul><h4 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h4><p>Reactor模型是基于 NIO 提出的一套IO模型。本质上是把上面编写的NIO服务端代码进行组件拆分和抽象化：</p><ul><li>Reactor：负责接收用户端连接</li><li>Acceptor：负责建立连接</li><li>Hispatch：负责处理请求</li></ul><p>客户端测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">while</span> ((len = socketChannel.read(byteBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            byteBuffer.flip();</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array(), <span class="number">0</span>, len));</span><br><span class="line">                            byteBuffer.clear();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                    byteBuffer.put(s.getBytes());</span><br><span class="line">                    byteBuffer.flip();</span><br><span class="line">                    socketChannel.write(byteBuffer);</span><br><span class="line">                    byteBuffer.flip();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单Reactor单线程"><a href="#单Reactor单线程" class="headerlink" title="单Reactor单线程"></a>单Reactor单线程</h5><p>单Reactor单线程实际上就是之前的NIO服务端代码。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202212070017765.png" alt="image-20221207001700692"></p><p>流程：</p><ol><li>Reactor 对象使用 select 监听客户端连接请求，触发事件后将其交给 dispatch() 分发</li><li>如果是建立连接请求事件，则分发给 Acceptor 通过 accept() 处理连接请求事件，然后创建 Handler 处理后续事件。</li><li>如果不是建立连接事件，则会分发给之前创建的 Handler 处理。</li><li>Handler 负责处理读取、业务逻辑、写入。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reactor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ServerSocketChannel serverSocketChannel;</span><br><span class="line">    Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Reactor</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            selectionKey.attach(<span class="keyword">new</span> <span class="title class_">Acceptor</span>(selector, serverSocketChannel));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    dispatcher(selectionKey);</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatcher</span><span class="params">(SelectionKey selectionKey)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> (Runnable) selectionKey.attachment();</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Acceptor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Acceptor</span><span class="params">(Selector selector, ServerSocketChannel serverSocketChannel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.selector = selector;</span><br><span class="line">        <span class="built_in">this</span>.serverSocketChannel = serverSocketChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;有客户端连接上来了,&quot;</span> + socketChannel.getRemoteAddress());</span><br><span class="line">            socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            selectionKey.attach(<span class="keyword">new</span> <span class="title class_">Handler</span>(socketChannel));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(SocketChannel socketChannel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socketChannel = socketChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = socketChannel.read(byteBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array(), <span class="number">0</span>, len));</span><br><span class="line">                socketChannel.write(byteBuffer);</span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h5><p>在上面的单Reactor单线程模型中，Handler部分执行代码都是单线程的，因此可能会导致一个Handler执行事件过久而阻塞其他的Acceptor和Handler，即服务端同时能进行逻辑处理的用户端只有一个。因此可以考虑在Handler部分加入线程池。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202212072216548.png" alt="image-20221207221606497"></p><p>Reactor和Acceptor部分代码不变，Handler代码变动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(SocketChannel socketChannel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socketChannel = socketChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行Handler&quot;</span>);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.read(byteBuffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool.execute(<span class="keyword">new</span> <span class="title class_">Process</span>(socketChannel, byteBuffer));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            socketChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Process</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer byteBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Process</span><span class="params">(SocketChannel socketChannel, ByteBuffer byteBuffer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socketChannel = socketChannel;</span><br><span class="line">        <span class="built_in">this</span>.byteBuffer = byteBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//正常逻辑操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Process thread:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="主从Reactor模型"><a href="#主从Reactor模型" class="headerlink" title="主从Reactor模型"></a>主从Reactor模型</h5><p>在上面的单Reactor多线程模型中，虽然把逻辑处理交给了线程池，但是读写操作还是由 Reactor（主线程）来处理。因此单个 Reactor 需要同时处理连接请求和读写，执行压力很大。于是便有了主从 Reactor 模型。其中一个Reactor负责处理连接，另一个负责处理客户端的读写。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202212072215954.png" alt="image-20221207221539904"></p><ol><li>Reactor 主线程 MainReactor 对象通过 Select 监控建立连接事件，收到事件后通过 Acceptor 接收，处理建立连接事件；</li><li>Acceptor 处理建立连接事件后，MainReactor 将连接分配 Reactor 子线程给 SubReactor 进行处理；</li><li>SubReactor 将连接加入连接队列进行监听，并创建一个 Handler 用于处理各种连接事件；</li><li>当有新的事件发生时，SubReactor 会调用连接对应的 Handler 进行响应；</li><li>Handler 通过 Read 读取数据后，会分发给后面的 Worker 线程池进行业务处理；</li><li>Worker 线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给 Handler 进行处理；</li><li>Handler 收到响应结果后通过 Send 将响应结果返回给 Client。</li></ol><blockquote><p>参考：</p><p><a href="https://www.bilibili.com/video/BV1qJ411w7du/">【并发】IO多路复用select&#x2F;poll&#x2F;epoll介绍_哔哩哔哩_bilibili</a></p><p><a href="https://zhuanlan.zhihu.com/p/127170201">Linux的5种IO模型梳理 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/179071801">「Linux」——select和epoll详解 - 知乎 (zhihu.com)</a></p><p><a href="https://mp.weixin.qq.com/s/OmRdUgO1guMX76EdZn11UQ">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！ (qq.com)</a></p><p><a href="https://www.jianshu.com/p/486b0965c296">聊聊Linux 五种IO模型 - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/K_520_W/article/details/123454627">java之NIO简介_爱上口袋的天空的博客-CSDN博客_java nio</a></p><p><a href="https://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">nio.pdf (oswego.edu)</a></p><p><a href="https://www.cnblogs.com/CodeBear/p/12567022.html">Reactor模型 - CodeBear - 博客园 (cnblogs.com)</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring异步任务和定时任务线程池</title>
      <link href="/2022/10/19/Spring%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2022/10/19/Spring%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道在Spring中，想要启用异步任务和定时任务非常简单，只要在配置类或者启动类上添加<code>@EnableAsync</code>和<code>@EnableScheduling</code>，然后在对应方法上添加<code>@Async</code>和<code>@Schedule</code>即可。那么<code>@Async</code>和<code>@Schedule</code>默认是在什么线程池中运行的呢？默认的线程池是什么配置？如何修改其配置？如何自定义线程池？</p><h2 id="异步任务执行器-TaskExecutor"><a href="#异步任务执行器-TaskExecutor" class="headerlink" title="异步任务执行器 TaskExecutor"></a>异步任务执行器 TaskExecutor</h2><p>异步任务执行器的接口是 <code>TaskExecutor</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TaskExecutor</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TaskExecutor</code> 继承了 JDK 的 <code>Executor</code>（即平时经常使用的 <code>ExecutorService</code> 的父接口）。<code>TaskExecutor</code> 有很多实现类，Spring Boot默认提供的实现类是 <code>ThreadPoolTaskExecutor</code>，默认的配置：</p><p>核心线程数：8，最大线程数：Integet.MAX_VALUE，队列使用LinkedBlockingQueue，队列容量：Integet.MAX_VALUE，空闲线程保留时间：60s，线程池拒绝策略：AbortPolicy。</p><h3 id="修改默认线程池配置"><a href="#修改默认线程池配置" class="headerlink" title="修改默认线程池配置"></a>修改默认线程池配置</h3><p>在 SpringBoot 中可以通过 application.properties 修改其配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#核心线程数</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.core-size</span>=<span class="string">200</span></span><br><span class="line"><span class="comment">#最大线程数</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.max-size</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment">#空闲线程保留时间</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.keep-alive</span>=<span class="string">3s</span></span><br><span class="line"><span class="comment">#队列容量</span></span><br><span class="line"><span class="attr">spring.task.execution.pool.queue-capacity</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment">#线程名称前缀</span></span><br><span class="line"><span class="attr">spring.task.execution.thread-name-prefix</span>=<span class="string">my-task-thread-pool-</span></span><br></pre></td></tr></table></figure><h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><h4 id="添加自定义线程池"><a href="#添加自定义线程池" class="headerlink" title="添加自定义线程池"></a>添加自定义线程池</h4><p>可以添加一个Executor的实现类的Bean，同时在使用 <code>@Aysnc</code> 时指定调用哪个线程池执行。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskExecutorConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">myTaskAsyncPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">//核心线程池大小</span></span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最大线程数</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//队列容量</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//活跃时间</span></span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        <span class="comment">//线程名字前缀</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;MyExecutor-&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// setRejectedExecutionHandler：当pool已经达到max size的时候，如何处理新任务</span></span><br><span class="line">        <span class="comment">// CallerRunsPolicy：不在新线程中执行任务，而是由调用者所在的线程来执行</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);</span><br><span class="line">        executor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService</span>&#123;</span><br><span class="line">    <span class="meta">@Aysnc(&quot;myTaskAsyncPool&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改默认线程池"><a href="#修改默认线程池" class="headerlink" title="修改默认线程池"></a>修改默认线程池</h4><p>如果想把添加的线程池作为默认执行的线程池而不用每次都在 <code>@Async</code> 时指定，可以实现 AsyncConfigurer 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskExecutorConfig</span> <span class="keyword">implements</span> <span class="title class_">AsyncConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">//核心线程池大小</span></span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最大线程数</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//队列容量</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//活跃时间</span></span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        <span class="comment">//线程名字前缀</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;MyExecutor-&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// setRejectedExecutionHandler：当pool已经达到max size的时候，如何处理新任务</span></span><br><span class="line">        <span class="comment">// CallerRunsPolicy：不在新线程中执行任务，而是由调用者所在的线程来执行</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);</span><br><span class="line">        executor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService</span>&#123;</span><br><span class="line">    <span class="meta">@Aysnc</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定时任务执行器-TaskScheduler"><a href="#定时任务执行器-TaskScheduler" class="headerlink" title="定时任务执行器 TaskScheduler"></a>定时任务执行器 TaskScheduler</h2><p>定时任务执行器的接口是 <code>TaskScheduler</code> 。<code>ThreadPoolTaskScheduler</code> 是它的一个重要实现，也是SpringBoot提供的默认定时任务线程池。需要注意的是，SpringBoot提供的 <code>ThreadPoolTaskScheduler</code> 默认线程池大小为1，因此如果不对定时任务线程池进行额外配置，定时任务都是串行排队执行的。在某些场景下可能导致定时任务并没有按时执行等情况。当然，也可以配合@Async，将定时任务都提交给异步线程池去执行，但是可能会遇到新的问题，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTask</span> &#123;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;*/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);        <span class="comment">//模拟定时任务执行时长</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;*/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//普通任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，如果希望test1()之间是串行排队执行的话，即上一个test1()执行完之后，再执行下一个test1()，@Async就无法实现了。但是配置了定时任务线程池后，由于每个定时任务是由同一个线程来执行的，因此可以实现这样的需求。</p><h3 id="修改默认线程池配置-1"><a href="#修改默认线程池配置-1" class="headerlink" title="修改默认线程池配置"></a>修改默认线程池配置</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.task.scheduling.pool.size</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">spring.task.scheduling.thread-name-prefix</span>=<span class="string">my-scheduling-thread-pool-</span></span><br></pre></td></tr></table></figure><h3 id="自定义默认线程池"><a href="#自定义默认线程池" class="headerlink" title="自定义默认线程池"></a>自定义默认线程池</h3><p>直接添加一个新的 <code>TaskScheduler</code> 的 Bean，覆盖 Spring 默认提供的 <code>ThreadPoolTaskScheduler</code> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskScheduleConfig</span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TaskScheduler <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskScheduler</span> <span class="variable">threadPoolTaskScheduler</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskScheduler</span>();</span><br><span class="line">        <span class="comment">// 配置线程池大小</span></span><br><span class="line">        threadPoolTaskScheduler.setPoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 设置线程名</span></span><br><span class="line">        threadPoolTaskScheduler.setThreadNamePrefix(<span class="string">&quot;my-scheduling-thread-pool-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者实现 <code>SchedulingConfigurer</code> ，向其中注册新的 <code>TaskScheduler</code> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        taskRegistrar.setScheduler(taskScheduler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TaskScheduler <span class="title function_">taskScheduler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskScheduler</span> <span class="variable">threadPoolTaskScheduler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskScheduler</span>();</span><br><span class="line">        <span class="comment">// 配置线程池大小</span></span><br><span class="line">        threadPoolTaskScheduler.setPoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 设置线程名</span></span><br><span class="line">        threadPoolTaskScheduler.setThreadNamePrefix(<span class="string">&quot;my-scheduling-thread-pool-&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> threadPoolTaskScheduler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="易混淆概念"><a href="#易混淆概念" class="headerlink" title="易混淆概念"></a>易混淆概念</h2><p>几个容易混淆的概念：</p><ul><li><p><code>Executor</code>：JDK提供的用于封装 <strong>线程（池）执行某个操作</strong> 的执行器接口</p></li><li><p><code>ExecutorService</code>：JDK提供的对 <code>Executor</code> 进一步封装的接口，用于执行普通线程池任务</p></li><li><p><code>ScheduledExecutorService</code>：JDK提供的对 <code>Executor</code> 进一步封装的接口，用于执行定时任务</p></li><li><p><code>ThreadPoolExecutor</code>：JDK提供的 <code>ExecutorService</code> 的实现类，也是<code>Executors.newFixedThreadPool(10)</code>之类的Executors工具类的返回</p></li><li><p><code>ScheduledThreadPoolExecutor</code>：JDK提供的 <code>ExecutorService</code> 的实现类</p></li><li><p><code>TaskExecutor</code>：Spring提供的用于封装异步任务线程池的执行器接口，本质和 <code>Executor</code> 相同</p></li><li><p><code>TaskSchedule</code>：Spring提供的用于封装定时任务线程池的执行器接口</p></li><li><p><code>ThreadPoolTaskExecutor</code>：Spring提供的 <code>TaskExecutor</code> 的实现类，本质也是对 <code>ThreadPoolExecutor</code> 的封装</p></li><li><p><code>ThreadPoolTaskScheduler</code>：Spring提供的 <code>TaskSchedule</code> 的实现类，本质也是对 <code>ScheduledThreadPoolExecutor</code> 的封装</p></li></ul><blockquote><p>参考：<a href="https://fookwood.com/spring-boot-tutorial-21-executor">默认线程池 – Spring Boot教程(21) | 闷瓜蛋子的BLOG (fookwood.com)</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud笔记</title>
      <link href="/2022/10/06/SpringCloud%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/06/SpringCloud%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是SpringCloud？"><a href="#什么是SpringCloud？" class="headerlink" title="什么是SpringCloud？"></a>什么是SpringCloud？</h3><p>Spring Cloud 被称为构建分布式微服务系统的“全家桶”，它并不是某一门技术，而是一系列微服务解决方案或框架的有序集合。它将市面上成熟的、经过验证的微服务框架整合起来，并通过 Spring Boot 的思想进行再封装，屏蔽调其中复杂的配置和实现原理，最终为开发人员提供了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><p>虽然 Spring Cloud 提供了很强大的功能，但是并没有提供所有的实现。其中的部分中间件只提供了统一的抽象API。不同厂商结合自身中间件，提供了自己的 Spring Cloud 套件。例如 <code>Spring Cloud Netflix</code> 、<code>Spring Cloud Alibaba</code>。（Netflix由于开源策略的调整，部分组件已经开始停止维护，因此不再适用于长久使用）</p><h3 id="不同SpringCloud套件的常用组件"><a href="#不同SpringCloud套件的常用组件" class="headerlink" title="不同SpringCloud套件的常用组件"></a>不同SpringCloud套件的常用组件</h3><table><thead><tr><th align="center"></th><th align="center">Spring Cloud 官方</th><th align="center">Spring Cloud Netflix</th><th align="center">Spring Cloud Alibaba</th></tr></thead><tbody><tr><td align="center">配置中心</td><td align="center">Spring Cloud Config&#x2F;<br />Spring Cloud Vault</td><td align="center">Archaius</td><td align="center">Nacos</td></tr><tr><td align="center">注册中心</td><td align="center">–</td><td align="center">Eureka</td><td align="center">Nacos</td></tr><tr><td align="center">服务调用</td><td align="center">RestTemplate&#x2F;<br />Spring Cloud OpenFegin</td><td align="center">–</td><td align="center">Dubbo</td></tr><tr><td align="center">负载均衡</td><td align="center">Spring Cloud Load Balancer</td><td align="center">Ribbon</td><td align="center">Dubbo</td></tr><tr><td align="center">服务容错</td><td align="center">–</td><td align="center">Hystrix</td><td align="center">Sentinel</td></tr><tr><td align="center">网关</td><td align="center">Spring Cloud Gateway</td><td align="center">Zuul</td><td align="center">–</td></tr><tr><td align="center">消息队列</td><td align="center">Spring Cloud Stream RabbitMQ&#x2F;<br />Spring Cloud Stream Kafka</td><td align="center">–</td><td align="center">Spring Cloud Stream RocketMQ</td></tr><tr><td align="center">事件总线</td><td align="center">Spring Cloud Bus RabbitMQ&#x2F;<br />Spring Cloud Bus Kafka</td><td align="center">–</td><td align="center">Spring Cloud Bus RocketMQ</td></tr><tr><td align="center">链路追踪</td><td align="center">Spring Cloud Sleuth</td><td align="center">–</td><td align="center">–</td></tr><tr><td align="center">分布式事务</td><td align="center">–</td><td align="center">–</td><td align="center">Seata</td></tr><tr><td align="center">分布式调度</td><td align="center">–</td><td align="center">–</td><td align="center">SchedulerX</td></tr></tbody></table><p>不同套件的组件之间可以互相混合使用。 </p><h3 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h3><p>SpringCloud和SpringBoot版本</p><table><thead><tr><th align="left">Release Train</th><th align="left">Boot Version</th></tr></thead><tbody><tr><td align="left"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2021.0-Release-Notes">2021.0.x</a> aka Jubilee</td><td align="left">2.6.x, 2.7.x (Starting with 2021.0.3)</td></tr><tr><td align="left"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes">2020.0.x</a> aka Ilford</td><td align="left">2.4.x, 2.5.x (Starting with 2020.0.3)</td></tr><tr><td align="left"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-Hoxton-Release-Notes">Hoxton</a></td><td align="left">2.2.x, 2.3.x (Starting with SR5)</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes">Greenwich</a></td><td align="left">2.1.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes">Finchley</a></td><td align="left">2.0.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes">Edgware</a></td><td align="left">1.5.x</td></tr><tr><td align="left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes">Dalston</a></td><td align="left">1.5.x</td></tr></tbody></table><p>SpringCloudAlibaba和SpringCloud版本</p><blockquote><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">版本说明 · alibaba&#x2F;spring-cloud-alibaba Wiki (github.com)</a></p></blockquote><h3 id="SpringCloud环境搭建"><a href="#SpringCloud环境搭建" class="headerlink" title="SpringCloud环境搭建"></a>SpringCloud环境搭建</h3><p><strong>版本选择：</strong></p><p>​SpringCloud：Hoxton.SR12</p><p>​SpringBoot：2.3.12.RELEASE</p><p>​SpringCloudAlibaba：2.2.9.RELEASE</p><p><strong>引入maven依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR12<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud-alibaba.version</span>&gt;</span>2.2.9.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud-alibaba.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h2><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p>属于 Spring Cloud Netflix 套件。不推荐：1、最新版本停止更新。2、注册中心的Server端还需要手动编写。</p><h3 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h3><p>服务端由 HashiCorp 公司用 Go 语言开发。不需要编写代码开发，只需要下载启动即可向其中注册服务。客户端由 Spring Cloud 提供。</p><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p><strong>下载安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo https://rpm.releases.hashicorp.com/RHEL/hashicorp.repo</span><br><span class="line">sudo yum -y install consul</span><br></pre></td></tr></table></figure><p><strong>运行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -dev -client 0.0.0.0</span><br></pre></td></tr></table></figure><ul><li><code>-dev</code> 表示以开发模式运行，是单节点。也可以用 <code>-server</code> 以服务模式运行，需要配置多节点。</li><li><code>-client 0.0.0.0</code> 表示外网访问</li></ul><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p><strong>pom.xml 需要导入两个新依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个包是用做健康度监控的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>修改配置文件 application.properties</strong> </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">consul-demo-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 指定注册的服务名</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.service-name</span>=<span class="string">consul-demo</span></span><br><span class="line"><span class="comment"># 指定consul的ip和port</span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">192.168.71.128</span></span><br><span class="line"><span class="attr">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="comment"># 是否使用ip注册。默认为false，使用hostname注册</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.prefer-ip-address</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p><strong>启动类添加注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsulDemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConsulDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>访问web管理页面</strong></p><p>启动SpringBoot，进入consul web页面（默认端口8500）查看当前注册的服务 </p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/oud%E7%AC%94%E8%AE%B0/202209240324263.png" alt="image-20220924032449140"></p><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><p><strong>下载安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/alibaba/nacos/releases/download/2.1.1/nacos-server-2.1.1.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xvf nacos-server-2.1.1.tar.gz</span><br></pre></td></tr></table></figure><p><strong>启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd nacos/bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动 standalone表示单机模式，非集群</span></span><br><span class="line">sh startup.sh -m standalone</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭</span></span><br><span class="line">sh shutdown.sh</span><br></pre></td></tr></table></figure><p><strong>访问web管理页面</strong></p><p><code>http://192.168.71.128:8848/nacos</code>，默认用户名密码都是nacos</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/oud%E7%AC%94%E8%AE%B0/202210031652418.png" alt="image-20221003165237312"></p><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><p><strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>修改配置文件</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8088</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">nacos-discovery-demo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># nacos server总地址，编写了这项即代表服务注册和配置管理都用这个地址（前提是同时引入了服务注册和配置管理依赖）</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.server-addr</span>=<span class="string">192.168.71.128:8848</span></span><br><span class="line"><span class="comment"># spring.cloud.nacos.discovery.server-addr=$&#123;spring.cloud.nacos.server-addr&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 注册时的服务名</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.discovery.service</span>=<span class="string">nacos-discovery-demo</span></span><br></pre></td></tr></table></figure><p><strong>入口类上的 @EnableDiscoveryClient 注解可加可不加</strong></p><p>启动服务查看效果：<img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/oud%E7%AC%94%E8%AE%B0/202210042214781.png" alt="image-20221004221453650"></p><blockquote><p>踩坑：nacos2.0之后添加了gRPC的通信方式，服务端和客户端需要额外开两个端口。默认为服务注册端口偏移1000和1001，即9848和9849</p></blockquote><h2 id="负载均衡组件"><a href="#负载均衡组件" class="headerlink" title="负载均衡组件"></a>负载均衡组件</h2><h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h3><p>Ribbon 是 Spring Cloud Netflix 中的一个负载均衡组件。Ribbon会根据所调用的服务的名称去服务注册中心获取对应的服务列表，并将服务列表在本地进行缓存，并且按照负载均衡策略进行调用。</p><p>consul client &#x2F; nacos client 中自带 Ribbon 的依赖。</p><p>Ribbon 中提供了三种使用方式：DiscoveryClient、LoadBalanceClient、@LoadBalance。</p><p><strong>DiscoveryClient</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取服务列表</span></span><br><span class="line">    List&lt;ServiceInstance&gt; products = discoveryClient.getInstances(<span class="string">&quot;consul-demo&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (ServiceInstance product : products) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;服务主机:[&#123;&#125;]&quot;</span>,product.getHost());</span><br><span class="line">      log.info(<span class="string">&quot;服务端口:[&#123;&#125;]&quot;</span>,product.getPort());</span><br><span class="line">      log.info(<span class="string">&quot;服务地址:[&#123;&#125;]&quot;</span>,product.getUri());</span><br><span class="line">      log.info(<span class="string">&quot;====================================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LoadBalanceClient</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//根据负载均衡策略选取某一个服务调用</span></span><br><span class="line">    <span class="type">ServiceInstance</span> <span class="variable">product</span> <span class="operator">=</span> loadBalancerClient.choose(<span class="string">&quot;consul-demo&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;服务主机:[&#123;&#125;]&quot;</span>,product.getHost());</span><br><span class="line">    log.info(<span class="string">&quot;服务端口:[&#123;&#125;]&quot;</span>,product.getPort());</span><br><span class="line">    log.info(<span class="string">&quot;服务地址:[&#123;&#125;]&quot;</span>,product.getUri());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@LoadBalance</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.加在创建 RestTemplate Bean 的方法上</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.注入RestTemplate</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//3.直接通过服务名调用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">forObject</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://consul-demo/test&quot;</span>, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改负载均衡策略</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8082</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">ribbon-demo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.service-name</span>=<span class="string">ribbon-demo</span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">192.168.71.128</span></span><br><span class="line"><span class="attr">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.prefer-ip-address</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 固定写法：</span></span><br><span class="line"><span class="comment"># &#123;服务名&#125;.ribbon.NFLoadBalancerRuleClassName=com.netflix.loadbalancer.&#123;负载均衡策略&#125;</span></span><br><span class="line"><span class="comment"># 表示当前这个服务访问调用其他服务时的负载均衡策略</span></span><br><span class="line"><span class="attr">consul-demo.ribbon.NFLoadBalancerRuleClassName</span>=<span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><p>Ribbon中提供的几种负载均衡策略：</p><ul><li><p>RoundRobinRule（轮训策略）：按顺序循环选择。</p></li><li><p>RandomRule（随机策略）：随机选择。</p></li><li><p>AvailabilityFilteringRule（可用过滤策略）：会先过滤由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问。</p></li><li><p>WeightedResponseTimeRule（响应时间加权策略）：根据平均响应的时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越高，刚启动时如果统计信息不足，则使用RoundRobinRule策略，等统计信息足够会切换回去。</p></li><li><p>RetryRule（重试策略）：先按照RoundRobinRule的策略获取服务，如果获取失败则在制定时间内进行重试，获取可用的服务。</p></li><li><p>BestAviableRule（最低并发策略）：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务。</p></li></ul><h2 id="服务调用组件"><a href="#服务调用组件" class="headerlink" title="服务调用组件"></a>服务调用组件</h2><h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><p>需要直接通过写死的路径调用服务，虽然简单易用，但是可拓展性低。</p><h3 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><p>由 Spring Cloud 官方推出的，基于 Netflix 的 Feign 进行二次封装开发的服务调用组件。OpenFeign 是一个声明式的伪 Http 客户端。OpenFeign 还支持 SpringMVC 的注解，支持可插拔的编码器和解码器，默认集成了 Ribbon。</p><h4 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h4><p>例如要调用的接口（在 <code>consul-demo</code> 模块中）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;demo1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>修改配置文件</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8083</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">openfeign-demo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.service-name</span>=<span class="string">openfeign-demo</span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">192.168.71.128</span></span><br><span class="line"><span class="attr">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.prefer-ip-address</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p><strong>启动类添加注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenFeignDemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OpenFeignDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编写 OpenFeignClint 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要调用的服务的名称</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;consul-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConsulDemo1Client</span> &#123;</span><br><span class="line">    <span class="comment">//注解中填需要调用的接口的path</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    String <span class="title function_">test</span><span class="params">()</span>;<span class="comment">//返回值类型要和调用的接口的返回值类型一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>直接调用 OpenFeignClint 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConsulDemoClient consulDemoClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">openFeignTest1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//直接调用，发现默认用了轮询的负载均衡</span></span><br><span class="line">        <span class="comment">//说明OpenFeign集成了Ribbon</span></span><br><span class="line">        <span class="keyword">return</span> consulDemoClient.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><h5 id="Get传递参数"><a href="#Get传递参数" class="headerlink" title="Get传递参数"></a>Get传递参数</h5><h6 id="query传参"><a href="#query传参" class="headerlink" title="query传参"></a>query传参</h6><p>需要调用的接口（在 <code>consul-demo</code> 模块中）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/paramTest1&quot;)</span></span><br><span class="line"><span class="comment">//接口上的@RequestParam(&quot;name&quot;)可以省略</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paramTest1</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span> &#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;demo1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要调用的服务的名称</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;consul-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConsulDemoClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/paramTest1&quot;)</span></span><br><span class="line">    <span class="comment">//client上的@RequestParam(&quot;name&quot;)不能省略，并且一定要写value属性</span></span><br><span class="line">    String <span class="title function_">paramTest1</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConsulDemoClient consulDemoClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">openFeignTest2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> consulDemoClient.paramTest1(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="path传参"><a href="#path传参" class="headerlink" title="path传参"></a>path传参</h6><p>需要调用的接口（在 <code>consul-demo</code> 模块中）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/paramTest2/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paramTest2</span><span class="params">(<span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;demo1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要调用的服务的名称</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;consul-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConsulDemoClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/paramTest2/&#123;name&#125;&quot;)</span></span><br><span class="line">    String <span class="title function_">paramTest2</span><span class="params">(<span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConsulDemoClient consulDemoClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test3&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">openFeignTest3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> consulDemoClient.paramTest2(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Post参数传递"><a href="#Post参数传递" class="headerlink" title="Post参数传递"></a>Post参数传递</h5><h6 id="json传参"><a href="#json传参" class="headerlink" title="json传参"></a>json传参</h6><p>需要调用的接口（在 <code>consul-demo</code> 模块中）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/postTest1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">postTest1</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要调用的服务的名称</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;consul-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConsulDemoClient</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/postTest1&quot;)</span></span><br><span class="line">    <span class="comment">//待调用的接口是用@RequestBody即json接收参数的，因此调用的时候也要用@RequestBody</span></span><br><span class="line">    String <span class="title function_">postTest1</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConsulDemoClient consulDemoClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test4&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">openFeignTest4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> consulDemoClient.postTest1(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="form传参"><a href="#form传参" class="headerlink" title="form传参"></a>form传参</h6><p>需要调用的接口（在 <code>consul-demo</code> 模块中）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/postTest1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">postTest1</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要调用的服务的名称</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;consul-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConsulDemoClient</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/postTest1&quot;)</span></span><br><span class="line">    <span class="comment">//待调用的接口是用@RequestBody即json接收参数的，因此调用的时候也要用@RequestBody</span></span><br><span class="line">    String <span class="title function_">postTest1</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConsulDemoClient consulDemoClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test4&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">openFeignTest4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> consulDemoClient.postTest1(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h4><h5 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h5><p>默认情况下，OpenFeign进行调用时，如果1S未响应，则会直接报错。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign.client.config.consul-demo.connectTimeout</span>=<span class="string">5000  </span></span><br><span class="line"><span class="comment">#配置指定服务连接超时时间</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feign.client.config.consul-demo.readTimeout</span>=<span class="string">5000  </span></span><br><span class="line"><span class="comment">#配置指定服务连接超时时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#feign.client.config.default.connectTimeout=5000  </span></span><br><span class="line"><span class="comment">#配置指定服务连接超时时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#feign.client.config.default.readTimeout=5000</span></span><br><span class="line"><span class="comment">#配置指定服务连接超时时间</span></span><br></pre></td></tr></table></figure><h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><p>开启日志</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign.client.config.consul-demo.loggerLevel</span>=<span class="string">full  </span></span><br><span class="line"><span class="comment">#开启指定服务日志展示</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#feign.client.config.default.loggerLevel=full  </span></span><br><span class="line"><span class="comment">#全局开启服务日志展示</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging.level.top.fengye.client</span>=<span class="string">debug    </span></span><br><span class="line"><span class="comment">#指定feign调用客户端对象所在包,必须是debug级别</span></span><br></pre></td></tr></table></figure><h5 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h5><p>openfeign 内置了 ribbon，因此配置负载均衡方法和 ribbon 相同</p><h2 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h2><p>网关（网关&#x3D;路由转发+拦截器）作用：</p><ul><li>统一所有微服务入口，实现请求路由转发和负载均衡。</li><li>在网关中对请求进行校验、鉴权等操作。</li></ul><h3 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h3><h4 id="基础使用-1"><a href="#基础使用-1" class="headerlink" title="基础使用"></a>基础使用</h4><p><strong>引入依赖</strong></p><blockquote><p>注意 SpringCloudGateway 是基于webflux的，与传统的MVC冲突，因此需要排除 Spring-Boot-Stater-Web 依赖或者在配置文件中指定<code>spring.main.web-application-type=reactive</code></p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入gateway网关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置路由转发规则</strong></p><ol><li><p>在配置文件中配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">web-application-type:</span> <span class="string">reactive</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">springcloud-gateway-demo</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">springcloud-gateway-demo</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.71</span><span class="number">.128</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user</span>  <span class="comment"># 路由id，没有固定规则但是需要唯一，建议和服务名对应</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8080</span></span><br><span class="line">          <span class="comment"># SpringCloud Gateway 也集成了Ribbon，配置负载均衡策略的方式也相同</span></span><br><span class="line">          <span class="comment"># 如果需要负载均衡，可以写成 uri: lb://服务名</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">admin</span>  <span class="comment">#路由对象唯一标识</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8081</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/admin/test,/admin/demo</span></span><br></pre></td></tr></table></figure></li><li><p>在配置类中配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">customRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.routes()</span><br><span class="line">                .route(<span class="string">&quot;user&quot;</span>,</span><br><span class="line">                        r -&gt; r.path(<span class="string">&quot;/user/**&quot;</span>)</span><br><span class="line">                                .uri(<span class="string">&quot;http://localhost:8080&quot;</span>))</span><br><span class="line">                .route(<span class="string">&quot;admin&quot;</span>,</span><br><span class="line">                        r -&gt; r.path(<span class="string">&quot;/admin/test&quot;</span>,<span class="string">&quot;/admin/demo&quot;</span>)</span><br><span class="line">                                .uri(<span class="string">&quot;http://localhost:8081&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>在之前的基础使用中，配置文件里配置了一项 <code>predicate</code> ，中文翻译叫断言，即路由转发的条件。</p><p>如果同时配置了多种predicate，则表示 <code>与</code> ，即全部满足时才触发。</p><p>除了之前介绍的 <strong>Path</strong> ，其他几种常用的predicate：</p><ol><li><p><strong>After&#x2F;Before&#x2F;Between</strong>：在指定时刻后&#x2F;前&#x2F;之间转发。例如 <code>After=2022-10-13T21:57:33.993+08:00[Asia/Shanghai]</code> 表示匹配时间为 <code>2022-10-13 21:57:33.993</code> 后&#x2F;前&#x2F;之间的请求。用 Between 的话则用 <code>,</code> 隔开两个时间。</p></li><li><p><strong>Host</strong>：根据主机名进行匹配转发。例如 <code>Host=**.fengye404.top</code> 表示匹配域名为 <code>**.fengye404.top</code> 的请求。</p></li><li><p><strong>Method</strong>：匹配指定的Http方法。例如 <code>Method=GET,POST</code> 表示匹配 GET 和 POST。</p></li><li><p><strong>Cookie</strong>：请求包含指定的Cookie，并且其值等于指定的值（或满足指定的正则表达式）。例如 <code>Cookie=name,123</code> 表示匹配包含指定的Cookie并且其内容等于123的请求。</p></li><li><p><strong>Header</strong>：与Cookie一致，区别在于匹配的是请求头。</p></li><li><p><strong>Query</strong>：与Cookie一致，区别在于匹配的是请求参数。</p></li><li><p><strong>Weight</strong>：这个断言不是匹配规则，而是负载均衡权重。例如有如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-1</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8080</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Weight=user,2</span></span><br><span class="line">            </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-2</span> </span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8081</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Weight=user,1</span></span><br><span class="line">            </span><br></pre></td></tr></table></figure><p>则表示三个请求，有两个会发送到user-1，一个会发送到user-2。</p></li></ol><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>SpringCloud-Gateway中的过滤器和Spring中的过滤器类似。可以用于参数校验、权限校验、流量监控、日志输出、协议转换等。</p><h5 id="内置过滤器"><a href="#内置过滤器" class="headerlink" title="内置过滤器"></a>内置过滤器</h5><p>使用方式同predicate。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-1</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8080</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=token,</span> <span class="number">123</span></span><br></pre></td></tr></table></figure><p>常见的内置过滤器：</p><ol><li><strong>AddRequestHeader</strong>：添加请求头。例如：<code>AddRequestHeader=token, 123</code></li><li><strong>AddRequestParameter</strong>：添加请求参数。</li><li><strong>AddResponseHeader</strong>：添加响应头。</li><li><strong>PrefixPath</strong>：添加前缀。例如：<code>PrefixPath=/test</code></li><li><strong>StripPrefix</strong>：去掉前缀。</li></ol><h5 id="自定义全局过滤器"><a href="#自定义全局过滤器" class="headerlink" title="自定义全局过滤器"></a>自定义全局过滤器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//相当于servlet的HttpRequest对象</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相当于servlet的HttpRequest对象</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相当于servlet filter的doFilter，即继续向后执行其他的filter</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请求发送前执行...&quot;</span>);</span><br><span class="line">        Mono&lt;Void&gt; filter = chain.filter(exchange);</span><br><span class="line">        System.out.println(<span class="string">&quot;响应回来后执行...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//过滤器执行顺序，默认按照自然顺序。即 1 在 2之前执行</span></span><br><span class="line">    <span class="comment">//如果返回的是 -1 则表示在所有过滤器之前执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>配置中心顾名思义，就是将配置统一管理。日后需要修改某个服务的配置时，只需要在配置中心修改，即可让服务的每个实例自动同步，省去手动修改配置文件。</p><h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><p>Spring Cloud Config 的配置文件一般可以给Github等代码托管平台管理，需要修改配置文件时只需要到代码托管平台修改即可。</p><p>Spring Cloud Config 组件分为两块：server和client。server负责从代码托管平台将配置文件同步到本地仓库；client集成在服务中，负责在服务启动时从server同步配置文件。</p><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动类添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="comment">//添加为统一配置中心</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringCloudcConfigServerDemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringCloudcConfigServerDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8085</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">springcloud-config-server-demo</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">springcloud-config-server-demo</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.71</span><span class="number">.128</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">server:</span></span><br><span class="line">      <span class="attr">git:</span></span><br><span class="line">        <span class="comment"># 仓库url</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://gitee.com/fengye404/spring-cloud-config-test.git</span></span><br><span class="line">        <span class="comment"># 分支</span></span><br><span class="line">        <span class="attr">default-label:</span> <span class="string">master</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">******</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">******</span></span><br></pre></td></tr></table></figure><blockquote><p>指定本地仓库位置</p><p>spring.cloud.config.server.git.basedir&#x3D;&#x2F;localresp</p><p>一定要是一个空目录,在首次会将该目录清空</p></blockquote><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><p><strong>引入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>在远程仓库中编写application.properties</strong></p><p>例如创建了两个配置文件：</p><p>springcloudconfigclientdemo-dev.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8086</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">springcloud-config-client-demo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 测试用例子</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure><p>springcloudconfigclientdemo-prod.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8085</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">springcloud-config-client-demo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 测试用例子</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">prod</span></span><br></pre></td></tr></table></figure><p><strong>编写bootstrap.properties</strong></p><p>因为使用了配置中心，所以服务本地并没有application.properties，而bootstrap.properties用于指定这个服务作为配置中心的微服务的一些基础信息，例如注册中心地址、配置中心服务名等</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注册中心的配置信息必须要写在服务自身的配置文件中</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.service-name</span>=<span class="string">springcloud-config-client-demo</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.prefer-ip-address</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">192.168.71.128</span></span><br><span class="line"><span class="attr">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 让当前服务去注册中心去找 config server</span></span><br><span class="line"><span class="attr">spring.cloud.config.discovery.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 告诉当前服务，config server的服务id</span></span><br><span class="line"><span class="attr">spring.cloud.config.discovery.service-id</span>=<span class="string">springcloud-config-server-demo</span></span><br><span class="line"><span class="comment"># 指定从哪个分支拉取配置</span></span><br><span class="line"><span class="attr">spring.cloud.config.label</span>=<span class="string">master</span></span><br><span class="line"><span class="comment"># 指定拉取的配置文件的名称</span></span><br><span class="line"><span class="attr">spring.cloud.config.name</span>=<span class="string">springcloudconfigclientdemo</span></span><br><span class="line"><span class="comment"># 指定拉取的配置文件的环境</span></span><br><span class="line"><span class="attr">spring.cloud.config.profile</span>=<span class="string">dev</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 上述配置表示去拉取springcloudconfigclientdemo-dev.properties</span></span><br></pre></td></tr></table></figure><h4 id="手动刷新配置文件"><a href="#手动刷新配置文件" class="headerlink" title="手动刷新配置文件"></a>手动刷新配置文件</h4><p>使用配置中心的好处在于，如果后期一个服务有多个实例在运行，此时需要修改这个服务的配置文件，就不需要一个个地手动给每个实例修改，而只需要修改配置中心中的配置文件，再由每个实例去刷新配置文件即可。</p><p><strong>接口类上添加注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;当前加载配置文件信息为:[&#123;&#125;]&quot;</span>,name);</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置文件添加web暴露</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management.endpoints.web.exposure.include</span>=<span class="string">*          </span></span><br><span class="line"><span class="comment">#开启所有web端点暴露</span></span><br></pre></td></tr></table></figure><p><strong>手动调用刷新配置接口完成刷新</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:9099/actuator/refresh</span><br></pre></td></tr></table></figure><h3 id="Nacos-1"><a href="#Nacos-1" class="headerlink" title="Nacos"></a>Nacos</h3><p>Nacos 作为统一配置中心，会自行创建版本库，因此不需要借助其他代码托管平台。 </p><h4 id="Server-1"><a href="#Server-1" class="headerlink" title="Server"></a>Server</h4><p>和前面的服务注册中心的 nacos server 一样启动即可</p><h4 id="Client-1"><a href="#Client-1" class="headerlink" title="Client"></a>Client</h4><p><strong>在 Server 添加配置文件</strong></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/oud%E7%AC%94%E8%AE%B0/202210052231518.png" alt="image-20221005223117406"></p><p>Data ID即文件名，Nacos强制要求文件名需要带有环境名。例如 <code>application-prod.properties</code> 中的prod。</p><p><strong>修改配置文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>编写bootstrap.properties</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注册时的服务名</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.discovery.service</span>=<span class="string">nacos-config-demo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># nacos server总地址，编写了这项即代表服务注册和配置管理都用这个地址（前提是引入了服务注册/配置管理依赖）</span></span><br><span class="line"><span class="comment"># spring.cloud.nacos.discovery.server-addr=$&#123;spring.cloud.nacos.server-addr&#125;</span></span><br><span class="line"><span class="comment"># spring.cloud.nacos.config.server-addr=$&#123;spring.cloud.nacos.server-addr&#125;</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.server-addr</span>=<span class="string">192.168.71.128:8848</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 当前服务所属的 namespace 的id，不填则为 public</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.namespace</span>=<span class="string">public</span></span><br><span class="line"><span class="comment"># 当前服务所属的 group ，默认为 DEFAULT_GROUP</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.group</span>=<span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># nacos server 中的 data id = prefix + environment + file-extension</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 第一种获取配置文件的方式：</span></span><br><span class="line"><span class="comment"># name = prefix + environment</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.name</span>=<span class="string">application-prod</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.file-extension</span>=<span class="string">properties</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 第二种获取配置文件的方式：</span></span><br><span class="line"><span class="comment"># spring.cloud.nacos.config.prefix=nacos_config_demo</span></span><br><span class="line"><span class="comment"># spring.cloud.nacos.config.environment=prod</span></span><br><span class="line"><span class="comment"># spring.cloud.nacos.config.file-extension=properties</span></span><br></pre></td></tr></table></figure><h4 id="自动刷新配置"><a href="#自动刷新配置" class="headerlink" title="自动刷新配置"></a>自动刷新配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="comment">//接口上添加注解实现自动刷新</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;test-attribute&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String testAttribute;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> testAttribute;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h4><p>nacos的配置文件默认存放在nacos内置的derby数据库中。推荐在生产情况下，使用MySQL数据库来持久化</p><p><strong>创建并初始化数据库</strong></p><p>数据库编码必须为UFT-8。初始化的sql文件为nacos安装目录中的conf&#x2F;nacos-mysql.sql。</p><p><strong>修改nacos配置文件</strong></p><p>配置文件为nacos安装目录中的conf&#x2F;properties。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">db.url.0</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">db.user.0</span>=<span class="string">用户名</span></span><br><span class="line"><span class="attr">db.password.0</span>=<span class="string">密码</span></span><br></pre></td></tr></table></figure><p>然后重启nacos即可。注意修改持久化数据库后，原来的配置文件不会自动导入到新数据库中，记得手动备份导入。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GithubActions进行CICD一键部署</title>
      <link href="/2022/09/04/GithubActions%E8%BF%9B%E8%A1%8CCICD%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/09/04/GithubActions%E8%BF%9B%E8%A1%8CCICD%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Github Actions 是 Github 推出的持续集成工具</p><ol><li><code>workflow</code>: 一个 <code>workflow</code> 工作流就是一个完整的过程，每个<code>workflow</code> 包含一组 <code>jobs</code>任务。</li><li><code>job : jobs</code>任务包含一个或多个<code>job</code> ，每个 <code>job</code>包含一系列的 <code>steps</code> 步骤。</li><li><code>step</code> : 每个 <code>step</code> 步骤可以执行指令或者使用一个 <code>action</code> 动作。</li><li><code>action</code> : 每个 <code>action</code> 动作就是一个通用的基本单元。</li></ol><p><code>workflow</code> 必须存储在项目根路径下的 <code>.github/workflows</code> 中，每个workflow对应一个具体的 <code>.yml</code> 文件</p><h3 id="workflow-文件"><a href="#workflow-文件" class="headerlink" title="workflow 文件"></a>workflow 文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 工作流程的名字</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">summerbot&#x27;s</span> <span class="string">CI/CD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发时机： push 到 main 分支</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">main</span> ]</span><br><span class="line"><span class="comment">#  pull_request:</span></span><br><span class="line"><span class="comment">#    branches: [main]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要执行的任务</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="comment"># 配置job任务运行的虚拟机环境</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 运行步骤</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">JDK</span> <span class="number">11</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-java@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">java-version:</span> <span class="string">&#x27;11&#x27;</span></span><br><span class="line">          <span class="attr">distribution:</span> <span class="string">&#x27;temurin&#x27;</span></span><br><span class="line">          <span class="attr">cache:</span> <span class="string">&#x27;maven&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 在工作目录下执行，生成的 jar 文件在 target 下</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">with</span> <span class="string">Maven</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">mvn</span> <span class="string">-B</span> <span class="string">-DskipTests=true</span> <span class="string">package</span> <span class="string">--file</span> <span class="string">pom.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#      # secrets 需要自行在 github 仓库中设置</span></span><br><span class="line"><span class="comment">#      - name: Deploy jar to server</span></span><br><span class="line"><span class="comment">#        # 本质上是把虚拟机中 jar 包通过 secure copy 复制到远程仓库</span></span><br><span class="line"><span class="comment">#        uses: garygrossgarten/github-action-scp@release</span></span><br><span class="line"><span class="comment">#        with:</span></span><br><span class="line"><span class="comment">#          # 虚拟机中 jar 包的位置（就在工作目录下）</span></span><br><span class="line"><span class="comment">#          local: target/summerbot.jar</span></span><br><span class="line"><span class="comment">#          # 远程仓库中需要复制的位置</span></span><br><span class="line"><span class="comment">#          remote: /home/summerbot/summerbot.jar</span></span><br><span class="line"><span class="comment">#          host: $&#123;&#123; secrets.HOST &#125;&#125;</span></span><br><span class="line"><span class="comment">#          username: $&#123;&#123; secrets.SSH_USERNAME &#125;&#125;</span></span><br><span class="line"><span class="comment">#          password: $&#123;&#123; secrets.SSH_PASSWORD &#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">server</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">easingthemes/ssh-deploy@v2.2.11</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">ARGS:</span> <span class="string">&#x27;-avz --delete&#x27;</span></span><br><span class="line">          <span class="attr">SOURCE:</span> <span class="string">&#x27;target/summerbot.jar&#x27;</span></span><br><span class="line">          <span class="attr">TARGET:</span> <span class="string">&#x27;/home/summerbot&#x27;</span></span><br><span class="line">          <span class="attr">REMOTE_HOST:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">REMOTE_USER:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">SSH_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span>  <span class="comment"># 登录服务器的私钥</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">java</span> <span class="string">-jar</span></span><br><span class="line">        <span class="comment"># 上一个步骤执行成功后会返回 true</span></span><br><span class="line">        <span class="attr">if:</span> <span class="string">success()</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">fifsky/ssh-action@master</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">user:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">screen</span> <span class="string">-R</span> <span class="string">summerbot</span> <span class="string">-X</span> <span class="string">stuff</span> <span class="string">$&#x27;^C</span>  <span class="string">java</span> <span class="string">-jar</span> <span class="string">/home/summerbot/summerbot.jar\n&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="workflow-文件（docker）"><a href="#workflow-文件（docker）" class="headerlink" title="workflow 文件（docker）"></a>workflow 文件（docker）</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">summerbot&#x27;s</span> <span class="string">docker</span> <span class="string">CI/CD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发时机： push 到 main 分支</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">main</span> ]</span><br><span class="line">  <span class="comment">#  pull_request:</span></span><br><span class="line">  <span class="comment">#    branches: [main]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义环境变量</span></span><br><span class="line"><span class="comment"># DOCKER_USER：用户名</span></span><br><span class="line"><span class="comment"># SERVICE_CONTAINER_NAME：summerbot-docker</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">IMAGE_TOTAL_NAME:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_USER</span> <span class="string">&#125;&#125;/$&#123;&#123;</span> <span class="string">secrets.SERVICE_CONTAINER_NAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">IMAGE_TAG:</span> <span class="string">latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="comment"># 配置job任务运行的虚拟机环境</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 运行步骤</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">JDK</span> <span class="number">11</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-java@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">java-version:</span> <span class="string">&#x27;11&#x27;</span></span><br><span class="line">          <span class="attr">distribution:</span> <span class="string">&#x27;temurin&#x27;</span></span><br><span class="line">          <span class="attr">cache:</span> <span class="string">&#x27;maven&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">with</span> <span class="string">Maven</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">mvn</span> <span class="string">-B</span> <span class="string">package</span> <span class="string">--file</span> <span class="string">pom.xml</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># docker 构建多平台</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">QEMU</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/setup-qemu-action@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 初始化构建环境</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Docker</span> <span class="string">Buildx</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/setup-buildx-action@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Login</span> <span class="string">to</span> <span class="string">DockerHub</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/login-action@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKER_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">push</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/build-push-action@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="comment"># 当前工作目录</span></span><br><span class="line">          <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">          <span class="comment"># 构建完成后 push</span></span><br><span class="line">          <span class="attr">push:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># github 账号 tag</span></span><br><span class="line">          <span class="attr">tags:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.IMAGE_TOTAL_NAME</span> <span class="string">&#125;&#125;:$&#123;&#123;</span> <span class="string">env.IMAGE_TAG</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">executing</span> <span class="string">docker</span> <span class="string">container</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@master</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            docker login -u $&#123;&#123; secrets.DOCKER_USER &#125;&#125; -p $&#123;&#123; secrets.DOCKER_PASSWORD &#125;&#125;</span></span><br><span class="line"><span class="string">            docker pull $&#123;&#123; env.IMAGE_TOTAL_NAME &#125;&#125;:$&#123;&#123; env.IMAGE_TAG &#125;&#125;</span></span><br><span class="line"><span class="string">            docker stop $&#123;&#123; secrets.SERVICE_CONTAINER_NAME &#125;&#125;</span></span><br><span class="line"><span class="string">            docker rm $&#123;&#123; secrets.SERVICE_CONTAINER_NAME &#125;&#125;</span></span><br><span class="line"><span class="string">            docker run -d \</span></span><br><span class="line"><span class="string">              --name $&#123;&#123; secrets.SERVICE_CONTAINER_NAME &#125;&#125; \</span></span><br><span class="line"><span class="string">              -p 23333:8080 \</span></span><br><span class="line"><span class="string">              $&#123;&#123; env.IMAGE_TOTAL_NAME &#125;&#125;:$&#123;&#123; env.IMAGE_TAG &#125;&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>参考文章:</p><p><a href="https://www.jianshu.com/p/adf755f2ebf9">让你满意的GitHub Actions详解 - 简书 (jianshu.com)</a></p><p><a href="https://blog.51cto.com/johnsteven/1323942">给screen发送一个命令运行，并保持screen不退出。51CTO博客</a></p><p><a href="https://hexo.cxy621.top/2021/12/09/lun-bu-shu-hou-duan-xiang-mu/#toc-heading-25">论部署后端项目 | 经验分享博客 (cxy621.top)</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch笔记</title>
      <link href="/2022/04/25/ElasticSearch%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/25/ElasticSearch%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装-ES"><a href="#安装-ES" class="headerlink" title="安装 ES"></a>安装 ES</h3><p>下载压缩包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.14.0-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf elasticsearch-7.14.0-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>修改配置文件，开启远程访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim elasticsearch-7.14.0/config</span><br><span class="line"></span><br><span class="line">修改</span><br><span class="line">network.host: 0.0.0.0</span><br></pre></td></tr></table></figure><p>由于 <code>ElasticSearch</code> 不能在 <code>root</code> 用户下启动，所以需要创建一个新用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useradd temp</span><br><span class="line"></span><br><span class="line">passwd temp</span><br><span class="line"></span><br><span class="line">su temp</span><br></pre></td></tr></table></figure><p>启动 <code>ElasticSearch</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd elasticsearch-7.14.0/bin</span><br><span class="line"></span><br><span class="line">./elasticsearch</span><br></pre></td></tr></table></figure><blockquote><p>port:  http 9200   tcp 9300</p></blockquote><p>可能遇到的问题：</p><ol><li><p>如果启动后 ES 被 <code>killed</code> ，可能是服务器内存不够，可以修改分配给 ES 的 JVM 内存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim elasticsearch-7.14.0/config/jvm.options</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改</span></span><br><span class="line">-Xms1g</span><br><span class="line">-Xmx1g</span><br></pre></td></tr></table></figure></li><li><p>报错：在 <code>root</code> 用户安装了 <code>JDK</code> 的情况下，普通用户运行报错 <code>could not find java in bundled JDK at /home/ElasticSearch</code></p><p>这是因为 root 用户安装的 JDK 是局部环境变量，不是全局的。需要在 <code>/etc/profile</code> 中配置全局环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vi  /etc/profile</span><br><span class="line"></span><br><span class="line">添加如下内容</span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-11.0.14.1.1-1.el7_9.x86_64 #安装的jdk的位置</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">:wq</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>报错：AccessDeniedException</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 /home/ElasticSearch/elasticsearch-7.14.0  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 ES 目录权限</span></span><br></pre></td></tr></table></figure></li><li><p>报错：<a href="https://www.cnblogs.com/linzepeng/p/12084734.html">关于elasticsearch boostrap checks failed错误类型整理及解决方法 - linzepeng - 博客园 (cnblogs.com)</a></p></li><li><p>报错：<a href="https://blog.csdn.net/lizz861109/article/details/112532473">(34条消息) ES启动异常：the default discovery settings are unsuitable for production use； at least…_lizz666的博客-CSDN博客</a></p></li></ol><p> <del><em>这tm绝对是我部署过踩坑最多的中间件，太草了</em></del></p><h3 id="docker-安装-ES"><a href="#docker-安装-ES" class="headerlink" title="docker 安装 ES"></a>docker 安装 ES</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:7.14.0</span><br><span class="line"></span><br><span class="line">docker run -d -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e &quot;ES_JAVA_OPTS=-Xms1g -Xmx1g&quot; elasticsearch:7.14.0</span><br></pre></td></tr></table></figure><p> <del><em>不得不说这种中间件还是docker方便</em></del></p><h3 id="安装-Kibana"><a href="#安装-Kibana" class="headerlink" title="安装 Kibana"></a>安装 Kibana</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-7.14.0-linux-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xvzf kibana-7.14.0-linux-x86_64/config/kibana.yml</span><br><span class="line"></span><br><span class="line">vim kibana-7.14.0-linux-x86_64/config/kibana.yml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 server.host: <span class="string">&quot;0.0.0.0&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 elasticsearch.hosts: [<span class="string">&quot;http://localhost:9200&quot;</span>] （默认不用改）</span></span><br><span class="line"></span><br><span class="line">cd kibana-7.14.0-linux-x86_64/bin</span><br><span class="line"></span><br><span class="line">./kibana</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kibana也不能运行在 root 用户上</span></span><br></pre></td></tr></table></figure><blockquote><p>port: 5601</p></blockquote><h3 id="docker-安装-Kibana"><a href="#docker-安装-Kibana" class="headerlink" title="docker 安装 Kibana"></a>docker 安装 Kibana</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker pull kibana:7.14.0</span><br><span class="line"></span><br><span class="line">docker run -d --name kibana -p 5601:5601 kibana:7.14.0</span><br><span class="line"></span><br><span class="line">docker exec -it kibana bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入 kibana 的容器</span></span><br><span class="line"></span><br><span class="line">vi config/kibana.yml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改配置文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 elasticsearch.hosts: [ <span class="string">&quot;ES运行的地址&quot;</span> ]</span></span><br><span class="line"></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">docker restart kibana</span><br></pre></td></tr></table></figure><h3 id="docker-compose-安装-ES-Kibana"><a href="#docker-compose-安装-ES-Kibana" class="headerlink" title="docker-compose 安装 ES &amp; Kibana"></a>docker-compose 安装 ES &amp; Kibana</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd /home</span><br><span class="line"></span><br><span class="line">mkdir ES-Kibana</span><br><span class="line"></span><br><span class="line">cd ES-Kibana</span><br><span class="line"></span><br><span class="line">vim docker-compose.yml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内容如下</span></span><br><span class="line"></span><br><span class="line">vim kibana.yml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内容如下</span></span><br></pre></td></tr></table></figure><p>docker-compose.yml</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3.8&quot;</span></span><br><span class="line">volumes:</span><br><span class="line">  data:</span><br><span class="line">  config:</span><br><span class="line">  plugin:</span><br><span class="line">networks:</span><br><span class="line">  es:</span><br><span class="line">services:</span><br><span class="line">  elasticsearch:</span><br><span class="line">    image: elasticsearch:<span class="number">7.14</span>.<span class="number">0</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;9200:9200&quot;</span></span><br><span class="line">      - <span class="string">&quot;9300:9300&quot;</span></span><br><span class="line">    networks:</span><br><span class="line">      - <span class="string">&quot;es&quot;</span></span><br><span class="line">    environment:</span><br><span class="line">      - <span class="string">&quot;discovery.type=single-node&quot;</span></span><br><span class="line">      - <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx1g&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - data:/usr/share/elasticsearch/data</span><br><span class="line">      - config:/usr/share/elasticsearch/config</span><br><span class="line">      - plugin:/usr/share/elasticsearch/plugins</span><br><span class="line">    </span><br><span class="line">  kibana:</span><br><span class="line">    image: kibana:<span class="number">7.14</span>.<span class="number">0</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;5601:5601&quot;</span></span><br><span class="line">    networks:</span><br><span class="line">      - <span class="string">&quot;es&quot;</span></span><br><span class="line">    depends_on:</span><br><span class="line">      - elasticsearch</span><br><span class="line">    environment:</span><br><span class="line">      I18N_LOCALE: zh-CN  <span class="comment"># 7.X  后切换中文</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./kibana.yml:/usr/share/kibana/config/kibana.yml</span><br></pre></td></tr></table></figure><p>kibana.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.host:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="attr">server.shutdownTimeout:</span> <span class="string">&quot;5s&quot;</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> [ <span class="string">&quot;http://elasticsearch:9200&quot;</span> ]</span><br><span class="line"><span class="comment"># 由于 kibana 和 ES 在 docker-compose 文件中指定了处于同一个network</span></span><br><span class="line"><span class="comment"># 因此可以用 ES 的服务名来作为 IP 指定服务</span></span><br><span class="line"><span class="attr">monitoring.ui.container.elasticsearch.enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="设置用户名密码"><a href="#设置用户名密码" class="headerlink" title="设置用户名密码"></a>设置用户名密码</h3><p>在 &#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml 中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xpack.security.enabled: true</span><br><span class="line">xpack.security.transport.ssl.enabled: true</span><br></pre></td></tr></table></figure><p>在 &#x2F;usr&#x2F;share&#x2F;kibana&#x2F;config&#x2F;kibana.yml 中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch.username: &quot;elastic&quot;</span><br><span class="line">elasticsearch.password: &quot;后面要设置的&quot;</span><br></pre></td></tr></table></figure><p>重启 ES ，进入 ES 容器，设置用户名密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@f42838410089 elasticsearch]# ./bin/elasticsearch-setup-passwords interactive</span><br><span class="line"># 然后依次设置密码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Initiating the setup of passwords for reserved users elastic,apm_system,kibana,kibana_system,logstash_system,beats_system,remote_monitoring_user.</span><br><span class="line">You will be prompted to enter passwords as the process progresses.</span><br><span class="line">Please confirm that you would like to continue [y/N]y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Enter password for [elastic]: </span><br><span class="line">Reenter password for [elastic]: </span><br><span class="line">Enter password for [apm_system]: </span><br><span class="line">Reenter password for [apm_system]: </span><br><span class="line">Enter password for [kibana_system]: </span><br><span class="line">Reenter password for [kibana_system]: </span><br><span class="line">Enter password for [logstash_system]: </span><br><span class="line">Reenter password for [logstash_system]: </span><br><span class="line">Enter password for [beats_system]: </span><br><span class="line">Reenter password for [beats_system]: </span><br><span class="line">Enter password for [remote_monitoring_user]: </span><br><span class="line">Reenter password for [remote_monitoring_user]: </span><br><span class="line">Changed password for user [apm_system]</span><br><span class="line">Changed password for user [kibana_system]</span><br><span class="line">Changed password for user [kibana]</span><br><span class="line">Changed password for user [logstash_system]</span><br><span class="line">Changed password for user [beats_system]</span><br><span class="line">Changed password for user [remote_monitoring_user]</span><br><span class="line">Changed password for user [elastic]</span><br></pre></td></tr></table></figure><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="索引-index"><a href="#索引-index" class="headerlink" title="索引 index"></a>索引 index</h3><p>一群相似的文档的集合，索引由名字来标识（全小写）</p><p>相当于 MySQL 的表</p><h4 id="索引基础操作"><a href="#索引基础操作" class="headerlink" title="索引基础操作"></a>索引基础操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有索引</span><br><span class="line">GET /_cat/indices    </span><br><span class="line"></span><br><span class="line"># 创建索引</span><br><span class="line">PUT /索引名</span><br><span class="line"># 默认创建的索引会在本地创建主数据块和副本数据块，</span><br><span class="line"># 由于主从都在一个服务器上，因此索引的 health 状态会变为 yellow</span><br><span class="line"># 可以暂时设置从索引数量为 0 ，解决这个问题</span><br><span class="line"># PUT /索引名</span><br><span class="line"># &#123;</span><br><span class="line">#&quot;settings&quot;:&#123;</span><br><span class="line">#     &quot;number_of_shards&quot;: 1,</span><br><span class="line">#&quot;number_of_replicas&quot;: 0</span><br><span class="line">#&#125;</span><br><span class="line"># &#125;</span><br><span class="line"></span><br><span class="line"># 删除索引</span><br><span class="line">DELETE /索引名</span><br></pre></td></tr></table></figure><h3 id="文档-document"><a href="#文档-document" class="headerlink" title="文档 document"></a>文档 document</h3><p>一条条基础的数据，用 json 表示 </p><p>相当于 MySQL 的数据</p><h4 id="文档基础操作"><a href="#文档基础操作" class="headerlink" title="文档基础操作"></a>文档基础操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 添加文档，手动指定 _id</span><br><span class="line">POST /索引名/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">&quot;xxx&quot;:&quot;xxxx&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 添加文档，自动生成 _id (UUID)</span><br><span class="line">POST /索引名/_doc</span><br><span class="line">&#123;</span><br><span class="line">&quot;xxx&quot;:&quot;xxxx&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 查询文档  基于 _id 查询</span><br><span class="line">GET /索引名/_doc/&lt;id&gt;</span><br><span class="line"></span><br><span class="line"># 删除文档  基于 _id 删除</span><br><span class="line">DELETE /索引名/_doc/&lt;id&gt;</span><br><span class="line"></span><br><span class="line"># 更新文档  基于 _id 更新 (删除原始文档，重新添加)</span><br><span class="line">PUT /索引名/_doc/&lt;id&gt;</span><br><span class="line">&#123;</span><br><span class="line">&quot;xxx&quot;:&quot;xxxx&quot;</span><br><span class="line">&#125;</span><br><span class="line"># 更新文档  基于 _id 更新 (在原文档的基础上更新)</span><br><span class="line">POST /索引名/_doc/&lt;id&gt;/_update</span><br><span class="line">&#123;</span><br><span class="line">&quot;xxx&quot;:&quot;xxxx&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="映射-mapping"><a href="#映射-mapping" class="headerlink" title="映射 mapping"></a>映射 mapping</h3><p>定义一个文档和他所包含的字段如何被存储和索引 </p><p>相当于 MySQL 的表结构</p><h4 id="映射基础操作"><a href="#映射基础操作" class="headerlink" title="映射基础操作"></a>映射基础操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 创建索引的同时创建 mapping 映射</span><br><span class="line">PUT /索引名</span><br><span class="line">&#123;</span><br><span class="line">&quot;mappings&quot;: &#123;</span><br><span class="line">&quot;properties&quot;:&#123;</span><br><span class="line">&quot;id&quot;:&#123;</span><br><span class="line">&quot;type&quot;:&quot;integer&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;title&quot;:&#123;</span><br><span class="line">&quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;price&quot;:&#123;</span><br><span class="line">&quot;type&quot;:&quot;double&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;description&quot;:&#123;</span><br><span class="line">&quot;type&quot;:&quot;text&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;created_at&quot;:&#123;</span><br><span class="line">&quot;type&quot;:&quot;date&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 查看某个索引的映射信息</span><br><span class="line">GET /索引名/_mapping</span><br></pre></td></tr></table></figure><h3 id="ES的基本数据类型"><a href="#ES的基本数据类型" class="headerlink" title="ES的基本数据类型"></a>ES的基本数据类型</h3><p>字符串类型：keyword 关键字      text 文本</p><p>数字类型：integer long float double</p><p>布尔类型：boolean</p><p>日期类型：date</p><h2 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h2><p>推荐 IK 分词器</p><p><a href="https://github.com/medcl/elasticsearch-analysis-ik">medcl&#x2F;elasticsearch-analysis-ik: The IK Analysis plugin integrates Lucene IK analyzer into elasticsearch, support customized dictionary. (github.com)</a></p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ul><li>IK 分词器版本需要与 ES 版本一致</li><li>Docker 容器运行 ES 安装插件目录为 <code>/usr/share/elasticsearch/plugins</code> (docker-compose中已经创建数据卷映射)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@fengye ~]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     es-kibana_config</span><br><span class="line">local     es-kibana_data</span><br><span class="line">local     es-kibana_plugin</span><br><span class="line">[root@fengye ~]# docker volume inspect es-kibana_plugin </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2022-03-29T23:49:42+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;</span><br><span class="line">            &quot;com.docker.compose.project&quot;: &quot;es-kibana&quot;,</span><br><span class="line">            &quot;com.docker.compose.version&quot;: &quot;2.2.3&quot;,</span><br><span class="line">            &quot;com.docker.compose.volume&quot;: &quot;plugin&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/www/server/docker/volumes/es-kibana_plugin/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;es-kibana_plugin&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">[root@fengye ~]# cd /www/server/docker/volumes/es-kibana_plugin/_data</span><br><span class="line">[root@fengye _data]# wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.14.0/elasticsearch-analysis-ik-7.14.0.zip</span><br><span class="line">[root@fengye _data]# mkdir ik-7.14.0</span><br><span class="line">[root@fengye _data]# mv elasticsearch-analysis-ik-7.14.0.zip ik-7.14.0/</span><br><span class="line">[root@fengye _data]# cd ik-7.14.0/</span><br><span class="line">[root@fengye _data]# unzip elasticsearch-analysis-ik-7.14.0.zip</span><br></pre></td></tr></table></figure><p>用kibana进行测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 请求</span><br><span class="line">POST /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;嘉然可爱捏&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 响应：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;嘉&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 1,</span><br><span class="line">      &quot;type&quot; : &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;然&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 1,</span><br><span class="line">      &quot;end_offset&quot; : 2,</span><br><span class="line">      &quot;type&quot; : &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;可爱&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 2,</span><br><span class="line">      &quot;end_offset&quot; : 4,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;捏&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 4,</span><br><span class="line">      &quot;end_offset&quot; : 5,</span><br><span class="line">      &quot;type&quot; : &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># ik_max_word 拆分力度比 ik_smart 更细 </span><br></pre></td></tr></table></figure><h3 id="创建索引时使用-IK-分词器"><a href="#创建索引时使用-IK-分词器" class="headerlink" title="创建索引时使用 IK 分词器"></a>创建索引时使用 IK 分词器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引名</span><br><span class="line">&#123;</span><br><span class="line">&quot;mappings&quot;:&#123;</span><br><span class="line">&quot;description&quot;:&#123;</span><br><span class="line">&quot;type&quot;:&quot;text&quot;,</span><br><span class="line">&quot;analyzer&quot;:&quot;ik_max_word&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展-停用词典"><a href="#扩展-停用词典" class="headerlink" title="扩展|停用词典"></a>扩展|停用词典</h3><p>修改 ik 解压目录的 config&#x2F;IKAnalyzer.cfg.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>test.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加拓展词典 test.dic ，创建 test.dic 文件，写入内容（一行一个词）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">嘉然</span><br></pre></td></tr></table></figure><p>测试效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;嘉然可爱捏&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;嘉然&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 2,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;可爱&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 2,</span><br><span class="line">      &quot;end_offset&quot; : 4,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;捏&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 4,</span><br><span class="line">      &quot;end_offset&quot; : 5,</span><br><span class="line">      &quot;type&quot; : &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询-Query-DSL"><a href="#查询-Query-DSL" class="headerlink" title="查询 Query DSL"></a>查询 Query DSL</h2><p>通过 rest api 传递 json 数据进行高级查询</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_doc/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;xxxx&quot;:&quot;xxxx&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用查询语句"><a href="#常用查询语句" class="headerlink" title="常用查询语句"></a>常用查询语句</h3><h4 id="查询一个索引的所有文档-march-all"><a href="#查询一个索引的所有文档-march-all" class="headerlink" title="查询一个索引的所有文档 march_all"></a>查询一个索引的所有文档 march_all</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;match_all&quot;:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于关键词查询-term"><a href="#基于关键词查询-term" class="headerlink" title="基于关键词查询 term"></a>基于关键词查询 term</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;term&quot;:&#123;</span><br><span class="line">&quot;description&quot;:&#123;</span><br><span class="line">&quot;value&quot;:&quot;test&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"># text 默认的分词器是 中文单字，英文单词</span><br><span class="line"># 除了 text ，其余都不分词</span><br></pre></td></tr></table></figure><h4 id="范围查询-range"><a href="#范围查询-range" class="headerlink" title="范围查询 range"></a>范围查询 range</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;range&quot;:&#123;</span><br><span class="line">&quot;price&quot;:&#123;</span><br><span class="line">&quot;gte&quot;:1400,</span><br><span class="line">&quot;lte&quot;:9999</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"># gt 大于  gte 大于等于</span><br><span class="line"># lt 小于  lte 小于等于</span><br></pre></td></tr></table></figure><h4 id="前缀查询-prefix"><a href="#前缀查询-prefix" class="headerlink" title="前缀查询 prefix"></a>前缀查询 prefix</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;prefix&quot;:&#123;</span><br><span class="line">&quot;title&quot;:&#123;</span><br><span class="line">&quot;value&quot;:&quot;ipho&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"># gt 大于  gte 大于等于</span><br><span class="line"># lt 小于  lte 小于等于</span><br></pre></td></tr></table></figure><h4 id="通配符查询-wildcard"><a href="#通配符查询-wildcard" class="headerlink" title="通配符查询 wildcard"></a>通配符查询 wildcard</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;wildcard&quot;:&#123;</span><br><span class="line">&quot;description&quot;:&#123;</span><br><span class="line">&quot;value&quot;:&quot;ipho*&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"># ? 匹配任意字符    * 匹配多个字符</span><br></pre></td></tr></table></figure><h4 id="多id查询-ids"><a href="#多id查询-ids" class="headerlink" title="多id查询 ids"></a>多id查询 ids</h4><p>获取多个指定 id 的文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;ids&quot;:&#123;</span><br><span class="line">&quot;description&quot;:&#123;</span><br><span class="line">&quot;values&quot;:[&quot;123&quot;,&quot;124&quot;,&quot;125&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模糊查询-fuzzy"><a href="#模糊查询-fuzzy" class="headerlink" title="模糊查询 fuzzy"></a>模糊查询 fuzzy</h4><p>模糊查询含有指定关键字的文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;fuzzy&quot;:&#123;</span><br><span class="line">&quot;title&quot;:&quot;hello&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"># 搜索关键词长度小于等于 2 不允许模糊 </span><br><span class="line"># 搜索关键词长度为 3-5 允许一次模糊 </span><br><span class="line"># 搜索关键词长度大于 5 允许两次模糊 </span><br></pre></td></tr></table></figure><h4 id="布尔查询-bool"><a href="#布尔查询-bool" class="headerlink" title="布尔查询 bool"></a>布尔查询 bool</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;bool&quot;:&#123;</span><br><span class="line">&quot;must&quot;:[</span><br><span class="line">&#123;&quot;term&quot;:&#123;</span><br><span class="line">&quot;price&quot;:&#123;</span><br><span class="line">&quot;value&quot;:4999</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"># must 相当于 &amp;&amp;      全真</span><br><span class="line"># should 相当于 ||   一个真</span><br><span class="line"># must_not 相当于 !   全假</span><br></pre></td></tr></table></figure><h4 id="多字段查询-multi-match"><a href="#多字段查询-multi-match" class="headerlink" title="多字段查询 multi_match"></a>多字段查询 multi_match</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;multi_match&quot;:&#123;</span><br><span class="line">&quot;query&quot;:&quot;iphone&quot;,</span><br><span class="line">&quot;fields&quot;:[&quot;title&quot;,&quot;description&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"># 如果字段类型 field 分词，那么查询的 query 也会分词后进行查询</span><br></pre></td></tr></table></figure><h4 id="默认字段分词查询-query-string"><a href="#默认字段分词查询-query-string" class="headerlink" title="默认字段分词查询 query_string"></a>默认字段分词查询 query_string</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;query_string&quot;:&#123;</span><br><span class="line">&quot;default_field&quot;:&quot;description&quot;,</span><br><span class="line">&quot;query&quot;:&quot;test&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"># 如果字段分词，查询条件也分词</span><br></pre></td></tr></table></figure><h4 id="高亮查询-highlight"><a href="#高亮查询-highlight" class="headerlink" title="高亮查询 highlight"></a>高亮查询 highlight</h4><p>将指定字段中的关键词高亮显示（只有能分词的字段才可以高亮）</p><p>默认使用 <code>&lt;em&gt;</code> 标签将关键词包裹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;term&quot;:&#123;</span><br><span class="line">&quot;description&quot;:&#123;</span><br><span class="line">&quot;value&quot;:&quot;iphone&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;highlight&quot;:&#123;</span><br><span class="line">&quot;pre_tags&quot;:[&quot;&lt;span style=&#x27;color:red;&#x27;&gt;&quot;],</span><br><span class="line">&quot;post_tags&quot;:[&quot;&lt;/span&gt;&quot;]</span><br><span class="line">&quot;fields&quot;:&#123;</span><br><span class="line">&quot;*&quot;:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"># 如果字段分词，查询条件也分词</span><br></pre></td></tr></table></figure><h4 id="分页查询-from-size"><a href="#分页查询-from-size" class="headerlink" title="分页查询 from size"></a>分页查询 from size</h4><p>默认查询只返回前十条</p><p>size: 每一页多少个数据</p><p>from: 起始位置  from &#x3D; (pageNum-1)*size</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;term&quot;:&#123;</span><br><span class="line">&quot;description&quot;:&#123;</span><br><span class="line">&quot;value&quot;:&quot;iphone&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;size&quot;:100,</span><br><span class="line">&quot;from&quot;:0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序查询-from"><a href="#排序查询-from" class="headerlink" title="排序查询 from"></a>排序查询 from</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;term&quot;:&#123;</span><br><span class="line">&quot;description&quot;:&#123;</span><br><span class="line">&quot;value&quot;:&quot;iphone&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;sort&quot;:[</span><br><span class="line">&#123;</span><br><span class="line">&quot;price&quot;:&#123;</span><br><span class="line">&quot;order&quot;:&quot;desc&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"># 降序 desc      升序 asc</span><br></pre></td></tr></table></figure><h4 id="返回指定字段-source"><a href="#返回指定字段-source" class="headerlink" title="返回指定字段 _source"></a>返回指定字段 _source</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;term&quot;:&#123;</span><br><span class="line">&quot;description&quot;:&#123;</span><br><span class="line">&quot;value&quot;:&quot;iphone&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;_source&quot;:[&quot;title&quot;,&quot;description&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回结果样例"><a href="#返回结果样例" class="headerlink" title="返回结果样例"></a>返回结果样例</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;took&quot;</span> <span class="punctuation">:</span> <span class="number">346</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> <span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;eq&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> <span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;products&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;HnOeWYABh7tgu1RN4hRV&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> <span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;title&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;test&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;price&quot;</span> <span class="punctuation">:</span> <span class="number">123</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="过滤查询-filter"><a href="#过滤查询-filter" class="headerlink" title="过滤查询 filter"></a>过滤查询 filter</h2><p>ES中有两种查询：query 和 filter </p><p>query 查询出来的结果会根据索引出现的次数、位置等信息进行打分，然后根据得分进行排名后返回结果</p><p>filter 则直接返回结果，因此 filter 效率要高于 query（同时 ES 也会缓存常用的 filter ）</p><p>一般应用时，应先使用过滤操作过滤数据，然后使用查询匹配数据。</p><p>filter 必须配合 bool 查询使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /索引名/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;bool&quot;:&#123;</span><br><span class="line">&quot;must&quot;:[</span><br><span class="line">&#123;</span><br><span class="line">&quot;match_all&quot;:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&quot;filter&quot;:&#123;</span><br><span class="line">&quot;term&quot;:&#123;</span><br><span class="line">&quot;description&quot;:&quot;iphone&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤类型：term、terms、ranage、exists、ids、bool</p><h2 id="整合-SpringBoot"><a href="#整合-SpringBoot" class="headerlink" title="整合 SpringBoot"></a>整合 SpringBoot</h2><p>引入依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ESClientConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractElasticsearchConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">elasticsearchClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ClientConfiguration</span> <span class="variable">clientConfiguration</span> <span class="operator">=</span> ClientConfiguration.builder()</span><br><span class="line">                .connectedTo(host + <span class="string">&quot;:&quot;</span> + port)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> RestClients.create(clientConfiguration).rest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端对象</p><ul><li>ElasticsearchOperations   通过偏向 oop 的方式操作</li><li>RestHighLevelClient  类似 kibana ，通过rest操作（推荐）</li></ul><h3 id="ElasticsearchOperations"><a href="#ElasticsearchOperations" class="headerlink" title="ElasticsearchOperations"></a>ElasticsearchOperations</h3><p>创建映射实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Document;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Field;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.FieldType;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Document(indexName = &quot;products&quot;)</span></span><br><span class="line"><span class="comment">// 指定文档的索引名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="comment">// 指定字段作为 _id</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Field(type = FieldType.Float)</span></span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text,analyzer = &quot;ik_max_word&quot;)</span></span><br><span class="line">    <span class="comment">// 指定映射类型和分词器</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">//get set...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ElasticsearchOperations elasticsearchOperations;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">        product.setId(<span class="number">1</span>);</span><br><span class="line">        product.setTitle(<span class="string">&quot;iphone&quot;</span>);</span><br><span class="line">        product.setPrice(<span class="number">9999.0</span>);</span><br><span class="line">        product.setDescription(<span class="string">&quot;iphone with IOS&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        elasticsearchOperations.save(product);</span><br><span class="line">        <span class="comment">// save() 当文档 id 不存在时，创建文档</span></span><br><span class="line">        <span class="comment">// 当文档 id 存在时，更新文档</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Product</span> <span class="variable">res</span> <span class="operator">=</span> elasticsearchOperations.get(<span class="string">&quot;1&quot;</span>, Product.class);</span><br><span class="line">        </span><br><span class="line">        elasticsearchOperations.delete(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RestHighLevelClient"><a href="#RestHighLevelClient" class="headerlink" title="RestHighLevelClient"></a>RestHighLevelClient</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.elasticsearch.action.delete.DeleteRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.get.GetRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.get.GetResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.index.IndexRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.search.SearchRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.search.SearchResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.update.UpdateRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RequestOptions;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.indices.CreateIndexRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.indices.GetIndexRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.XContentType;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.QueryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.QueryBuilders;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.search.builder.SearchSourceBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 風楪fy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022/4/24 10:47</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ESService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断索引是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexName 索引名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIndexExist</span><span class="params">(String indexName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">GetIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(indexName);</span><br><span class="line">        <span class="keyword">return</span> restHighLevelClient.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建索引</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexName   索引名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mappingJson 映射</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createIndex</span><span class="params">(String indexName, String mappingJson)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">CreateIndexRequest</span> <span class="variable">createIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(indexName);</span><br><span class="line">        <span class="keyword">if</span> (mappingJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            createIndexRequest.mapping(mappingJson, XContentType.JSON);</span><br><span class="line">        &#125;</span><br><span class="line">        restHighLevelClient.indices().create(createIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向指定索引中添加文档</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexName 索引名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> document  被添加的 JSON 文档</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id        指定要添加的文档的 id，为 null 时 ES 会自动生成</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDocument</span><span class="params">(String indexName, String document, String id)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(indexName);</span><br><span class="line">        request.id(id).source(document, XContentType.JSON);</span><br><span class="line">        restHighLevelClient.index(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 id 更新文档 (在原文档的基础上更新)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexName 索引名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id        id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> document  更新内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateDocument</span><span class="params">(String indexName, String id, String document)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">UpdateRequest</span> <span class="variable">updateRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(indexName, id);</span><br><span class="line">        updateRequest.doc(document, XContentType.JSON);</span><br><span class="line">        restHighLevelClient.update(updateRequest, RequestOptions.DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定文档</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteDocument</span><span class="params">(String indexName, String id)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DeleteRequest</span> <span class="variable">deleteRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(indexName, id);</span><br><span class="line">        restHighLevelClient.delete(deleteRequest, RequestOptions.DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 id 返回文档</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getDocumentById</span><span class="params">(String indexName, String id)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">GetRequest</span> <span class="variable">getRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(indexName, id);</span><br><span class="line">        <span class="type">GetResponse</span> <span class="variable">documentFields</span> <span class="operator">=</span> restHighLevelClient.get(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> documentFields.getSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装分页条件查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryBuilder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageNum      起始位置（从0开始）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize     每一页的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SearchResponse <span class="title function_">query</span><span class="params">(String indexName, QueryBuilder queryBuilder, <span class="type">int</span> pageNum, <span class="type">int</span> pageSize)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(indexName);</span><br><span class="line"></span><br><span class="line">        <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">        searchSourceBuilder.query(queryBuilder)</span><br><span class="line">                .from((pageNum - <span class="number">1</span>) * pageSize)</span><br><span class="line">                .size(pageSize);</span><br><span class="line"></span><br><span class="line">        searchRequest.source(searchSourceBuilder);</span><br><span class="line">        <span class="keyword">return</span> restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * term 查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> terms</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> SearchResponse <span class="title function_">termQuery</span><span class="params">(String indexName, String fieldName, String... terms)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.query(indexName, QueryBuilders.termsQuery(fieldName, terms), <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker-compose部署SpringBoot项目</title>
      <link href="/2022/04/23/docker-compose%E9%83%A8%E7%BD%B2SpringBoot%E9%A1%B9%E7%9B%AE/"/>
      <url>/2022/04/23/docker-compose%E9%83%A8%E7%BD%B2SpringBoot%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="docker-compose部署SpringBoot项目"><a href="#docker-compose部署SpringBoot项目" class="headerlink" title="docker-compose部署SpringBoot项目"></a>docker-compose部署SpringBoot项目</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>docker-compose 是 Docker 官方的开源项目，主要用于实现对 Docker 容器集群的快速编排。</p><p>用户可以通过 <code>docker-compose.yml</code> 来定义一组相关联的容器作为一个项目(<code>project</code>)</p><p>docker-compose的两个概念:</p><ul><li>服务(<code>service</code>)：应用的容器</li><li>项目(<code>project</code>)：一组关联的服务组成，在 <code>docker-compose.yml</code> 中定义</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载最新版的docker-compose文件 (截止2022.1.28)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/v2.2.3/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>*下载慢换国内源</p><p><a href="http://get.daocloud.io/#install-compose">DaoCloud | Docker 极速下载</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https://get.daocloud.io/docker/compose/releases/download/v2.2.3/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>添加可执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>检查是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@fengye]docker-compose --version</span><br><span class="line">Docker Compose version v2.2.3</span><br></pre></td></tr></table></figure><h2 id="编写docker-compose-yml文件"><a href="#编写docker-compose-yml文件" class="headerlink" title="编写docker-compose.yml文件"></a>编写docker-compose.yml文件</h2><p>模板：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">example:</span>                     <span class="comment">#服务名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tomcat:8.0-jre8</span>     <span class="comment">#使用的镜像</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">example_container_name</span>    <span class="comment">#容器启动时的名字</span></span><br><span class="line">    <span class="attr">ports:</span>                     <span class="comment">#容器端口映射，前面的是主机端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span>                   <span class="comment">#容器中的哪个路径和宿主中的路径进行数据卷映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/apps:/usr/local/tomcat/webapps</span>     <span class="comment">#手动映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tomcatwebapps:/usr/local/tomcat/webapps</span>  <span class="comment">#自动创建数据卷映射，需要在后面声明数据卷</span></span><br><span class="line">    <span class="attr">networks:</span>                  <span class="comment">#指定容器启动使用的网桥</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">aa</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">xxxxx</span>             <span class="comment">#用于覆盖容器默认启动指令</span></span><br><span class="line">    <span class="attr">envoriment:</span>                <span class="comment">#指定容器启动时的环境参数</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">xxxxx=xxxx</span></span><br><span class="line">       <span class="comment">#env_file:                 使用环境变量文件，书写格式和环境参数相同</span></span><br><span class="line">        <span class="comment">#  - ./xxx.env</span></span><br><span class="line">    <span class="attr">depends_on:</span>                <span class="comment">#设置这个服务依赖的服务名称（即启动优先级）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">xxxxx</span></span><br><span class="line">    <span class="comment">#sysctls:                  #修改容器内部参数</span></span><br><span class="line">    <span class="comment">#  - xxxx=xxxx</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">   <span class="attr">tomcatwebapps:</span></span><br><span class="line">   <span class="comment">#external:       默认卷名会带上项目名(yml文件所在文件夹名)，</span></span><br><span class="line">   <span class="comment">#  true          可以声明使用外部以存在的卷</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">   <span class="attr">aa:</span>                <span class="comment">#创建逻辑同volume</span></span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 表示后台启动</span></span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>初始文件结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">`-- freshcup</span><br><span class="line">    |-- data</span><br><span class="line">    |   |-- mysql</span><br><span class="line">    |   |   `-- initsql</span><br><span class="line">    |   |       `-- freshcup.sql</span><br><span class="line">    |   `-- redis</span><br><span class="line">    |       `-- conf</span><br><span class="line">    |           `-- redis.conf</span><br><span class="line">    |-- docker-compose.yml</span><br><span class="line">    |-- Dockerfile</span><br><span class="line">    `-- freshcup.jar</span><br></pre></td></tr></table></figure><p>Dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> adoptopenjdk/openjdk11:alpine-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> freshcup.jar .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">10101</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span> ,<span class="string">&quot;-jar&quot;</span> ,<span class="string">&quot;freshcup.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>docker-compose.yml文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">freshcup:</span>                        <span class="comment">#自己写的web服务</span></span><br><span class="line">    <span class="attr">build:</span>                         <span class="comment">#根据指定的Dockerfile构建镜像</span></span><br><span class="line">      <span class="attr">context:</span>  <span class="string">.</span>                  <span class="comment">#指定dockerfile所在目录作为docker构建镜像的context环境</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span>       <span class="comment">#指定dockerfile的文件，默认为Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">freshcup</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10000:10101&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">freshcup</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.34</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">freshcup_mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10001:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=freshcup</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mysql/initsql:/docker-entrypoint-initdb.d</span>    <span class="comment">#用于初始化mysql数据库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mysql/db:/var/lib/mysql</span>                      <span class="comment">#mysql数据文件挂载</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mysql/conf:/etc/mysql</span>                        <span class="comment">#mysql配置文件挂载</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mysql/log:/var/log/mysql</span>                     <span class="comment">#mysql日志文件挂载</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">freshcup</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">reids:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">freshcup_redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10002:6379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/redis/db:/data</span>                                    <span class="comment">#redis数据文件挂载</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/redis/conf/redis.conf:/etc/redis/redis.conf</span>       <span class="comment">#redis配置文件挂载</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sh</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">        redis-server /etc/redis/redis.conf                       </span></span><br><span class="line"><span class="string">        redis-server --requirepass *********</span></span><br><span class="line"><span class="string">        redis-server --appendonly yes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">freshcup:</span></span><br></pre></td></tr></table></figure><p>踩坑：command指令如果有多条，不能使用这种形式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">command:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;redis-server --appendonly yes&quot;</span>      <span class="comment">#开启AOF持久化</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;redis-server --requirepass *****&quot;</span>   <span class="comment">#设置redis密码</span></span><br></pre></td></tr></table></figure><p>解决方案：<a href="https://blog.csdn.net/whatday/article/details/108863389">docker-compose command 执行多条指令</a></p><h2 id="docker-compose常用命令"><a href="#docker-compose常用命令" class="headerlink" title="docker-compose常用命令"></a>docker-compose常用命令</h2><h3 id="UP"><a href="#UP" class="headerlink" title="UP"></a>UP</h3><p>格式为<code>docker-compose up [options] [service]</code></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose <span class="meta">up</span>    对整个项目操作启动</span><br><span class="line">docker-compose <span class="meta">up</span> -d 后台启动</span><br></pre></td></tr></table></figure><h3 id="Down"><a href="#Down" class="headerlink" title="Down"></a>Down</h3><p>停止和删除容器、网络、卷、镜像</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose <span class="meta">down</span> 关闭所有容器</span><br><span class="line">docker-compose <span class="meta">down</span> 服务id 关闭某一个服务</span><br></pre></td></tr></table></figure><h3 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a>Exec</h3><p>进入某个服务的内部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose <span class="built_in">exec</span> [服务<span class="built_in">id</span>] bash</span><br></pre></td></tr></table></figure><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>列出当前项目所有运行的服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps </span><br></pre></td></tr></table></figure><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><p>重启服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose restart [服务id]</span><br></pre></td></tr></table></figure><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><p>停止服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop [服务<span class="built_in">id</span>]</span><br></pre></td></tr></table></figure><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除停止状态的整个项目或者某个服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose <span class="built_in">rm</span> [服务<span class="built_in">id</span>]</span><br></pre></td></tr></table></figure><p>强制删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose <span class="built_in">rm</span> -f [服务<span class="built_in">id</span>]</span><br></pre></td></tr></table></figure><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>查看整个项目所有服务的进程或者某个指定服务的进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose top [服务<span class="built_in">id</span>]</span><br></pre></td></tr></table></figure><h3 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a>unpause</h3><p>恢复处于暂停状态中的服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose unpause [服务<span class="built_in">id</span>]</span><br></pre></td></tr></table></figure><h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h3><p>暂停所有服务或者某一个服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose pause [服务<span class="built_in">id</span>]</span><br></pre></td></tr></table></figure><h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><p>查看容器的日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose  logs [服务<span class="built_in">id</span>]</span><br></pre></td></tr></table></figure><p>查看实时日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose  logs  -f [服务<span class="built_in">id</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java反射</title>
      <link href="/2022/04/14/Java%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/04/14/Java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h1><h2 id="反射介绍"><a href="#反射介绍" class="headerlink" title="反射介绍"></a>反射介绍</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>反射机制允许程序在执行期间借助于 Reflection Api 获取任何类的内部信息（成员变量、构造器、成员方法等），并能直接操作任意对象的内部属性和方法。</p></li><li><p>当一个类被加载之后，就在堆内存的方法区中产生了一个相应的 Class 类型的对象（一个类只有一个Class对象），这个对象包含了完整的类的结构信息，可以通过这个对象看到类的结构。</p></li><li><p>加载到内存中的运行时类会缓存一段时间，在此时间之内，通过不同方式获取到的都是同一个运行时类。（即同一个Class类的对象）</p></li></ul><h3 id="反射相关类吧"><a href="#反射相关类吧" class="headerlink" title="反射相关类吧"></a>反射相关类吧</h3><p>java.lang.Class：标识某个类加载后在堆中的对象</p><p>java.lang.reflect.Method：代表类的方法</p><p>java.lang.reflect.Field：代表类的成员变量</p><p>java.lang.reflect.Constructor：代表成员的构造方法</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><ol><li>Class 类也是类，继承 Object 类</li><li>Class 类的实例不是 new 出来的，而是在类被加载时由系统创建的</li><li>对于某个类的 Class 类实例，内存是单例的，因为类只加载一次</li><li>可以通过类的实例获取到类的 Class 实例</li><li>Class 实例存在于堆中</li></ol><h3 id="Class类常用方法"><a href="#Class类常用方法" class="headerlink" title="Class类常用方法"></a>Class类常用方法</h3><p>Test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">classAllPath</span> <span class="operator">=</span> <span class="string">&quot;com.example.demo.Test&quot;</span>;</span><br><span class="line"><span class="comment">//获取 Test 的 Class 对象</span></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(classAllPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过 cls 创建 Test 的实例</span></span><br><span class="line"><span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> aClass.getDeclaredConstructor().newInstance();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//通过反射获取属性(只能获取public)</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">testField</span> <span class="operator">=</span> aClass.getField(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">System.out.println(testField.get(test));</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射给属性赋值</span></span><br><span class="line">testField.set(test,<span class="string">&quot;demo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射调用方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">method.invoke(test);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class类可以添加泛型</span><br><span class="line">//方式一：调用运行时类的属性：class</span><br><span class="line">Class clazz1 = Person.class;</span><br><span class="line"></span><br><span class="line">//方式二：通过运行时类的对象的方法：getClass()</span><br><span class="line">Person p1 = new Person();</span><br><span class="line">Class clazz2 = p1.getClass();</span><br><span class="line"></span><br><span class="line">//方式三：调用Class的静态方法：forName(String classPath)</span><br><span class="line">Class.forName(&quot;com.example.demo.java.Person&quot;);//写类的全类名</span><br><span class="line"></span><br><span class="line">//方式四：使用类加载器ClassLoader（仅作了解）</span><br><span class="line">ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">classLoader.loadClass(&quot;com.example.demo.java.Person&quot;);</span><br></pre></td></tr></table></figure><h3 id="获取-Class-对象的方式"><a href="#获取-Class-对象的方式" class="headerlink" title="获取 Class 对象的方式"></a>获取 Class 对象的方式</h3><h4 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName()"></a>Class.forName()</h4><p>前提：已知类的全类名，并且该类在类路径下</p><p>应用场景：用于配置文件，读取类全路径，加载类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.example.demo.Test&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="类-class"><a href="#类-class" class="headerlink" title="类.class"></a>类.class</h4><p>前提：已知具体的类，通过类的 class 获取</p><p>应用场景：用于参数传递，比如通过反射得到对应构造器对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Test.class;</span><br></pre></td></tr></table></figure><h4 id="对象-getClass"><a href="#对象-getClass" class="headerlink" title="对象.getClass()"></a>对象.getClass()</h4><p>前提：已知某个类的实例</p><p>应用场景：通过创建好的对象，获取 Class 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">Class&lt;?&gt; aClass = test.getClass();</span><br></pre></td></tr></table></figure><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> test.getClass().getClassLoader();</span><br><span class="line">Class&lt;?&gt; aClass = classLoader.loadClass(<span class="string">&quot;com.example.demo.Test&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><ul><li>静态加载：<strong>编译时</strong>加载相关的类，<code>Person person = new Person()</code></li><li>动态加载：<strong>运行时</strong>加载所需的类，<code>Class&lt;?&gt; clazz = Class.forName(&quot;Person&quot;)</code></li></ul><h3 id="类加载过程："><a href="#类加载过程：" class="headerlink" title="类加载过程："></a>类加载过程：</h3><p><img src="http://fengye404.top/wp-content/uploads/2022/04/KRL6VBSUHE3M7P1Z8NU6.png"></p><h4 id="加载-Loading："><a href="#加载-Loading：" class="headerlink" title="加载 Loading："></a>加载 Loading：</h4><ul><li>将 Java 字节码从不同数据源（class文件、jar包、网络）转化为二进制字节流加载到内存中，并为每个字节码中的类生成一个代表该类的 <code>java.lang.Class</code> 对象</li></ul><h4 id="验证-Verification："><a href="#验证-Verification：" class="headerlink" title="验证 Verification："></a>验证 Verification：</h4><ul><li>确保加载到内存中的二进制字节流符合当前 JVM 虚拟机的要求，并且不会危害 JVM 的安全</li></ul><h4 id="准备-Preparation："><a href="#准备-Preparation：" class="headerlink" title="准备 Preparation："></a>准备 Preparation：</h4><ul><li>对静态变量分配内存并默认初始化</li></ul><h4 id="解析-Resolution"><a href="#解析-Resolution" class="headerlink" title="解析 Resolution"></a>解析 Resolution</h4><ul><li>将常量池内的符号引用替换为直接引用</li></ul><h4 id="初始化-Initialization"><a href="#初始化-Initialization" class="headerlink" title="初始化 Initialization"></a>初始化 Initialization</h4><ul><li><p>编译期按照语句在源文件中出现的顺序，依次收集类中所有的静态变量的赋值和静态代码块中的语句进行合并执行（线程安全）</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span>&#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;static代码块被加载&quot;</span>);</span><br><span class="line">a = <span class="number">300</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;构造方法被调用&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 执行顺序:</span><br><span class="line"># 加载Test类：</span><br><span class="line"># System.out.println(<span class="string">&quot;static代码块被加载&quot;</span>);</span><br><span class="line"># <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">300</span></span><br><span class="line"># a = <span class="number">100</span></span><br><span class="line"># 构造方法调用：</span><br><span class="line"># System.out.println(<span class="string">&quot;构造方法被调用&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer刷题记录</title>
      <link href="/2022/04/05/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/04/05/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03 数组中重复的数字"></a>03 数组中重复的数字</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>初步想法是创建一个Set，然后遍历数组并把数字添加入Set，每次添加的时候如果数字已经存在，就返回该数字。</p><p>但是这样的话时间复杂度和空间复杂度太高了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">repeat</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(num)) &#123;</span><br><span class="line">                repeat = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：4 ms, 在所有 Java 提交中击败了53.18%的用户</p><p>内存消耗：48.4 MB, 在所有 Java 提交中击败了8.69%的用户</p><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><h4 id="用数组代替set"><a href="#用数组代替set" class="headerlink" title="用数组代替set"></a>用数组代替set</h4><p>此时注意到题目中说所有数字都在0到n-1之间，那只需要构建一个长度为n的数组map，数组中每个元素的初始值为0；</p><p>然后遍历nums数组，每次遍历到的值就是map数组中对应的下标，让其+1；</p><p>如果map中有某个下标的值&gt;1，则说明有重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            map[num]++;</span><br><span class="line">            <span class="keyword">if</span> (map[num] &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了81.07%的用户</p><p>内存消耗：46 MB, 在所有 Java 提交中击败了78.04%的用户</p><p>时间复杂度O(n)</p><p>空间复杂度O(n)</p><p>虽然与set同是O(n),但是性能还是提高了</p><h4 id="原地交换"><a href="#原地交换" class="headerlink" title="原地交换"></a>原地交换</h4><p>由于nums长度为n，其中数字也是0到n-1，所以其中每个数字可以有一个对应的下标；</p><p>要进行的操作就是遍历nums，然后把每个数字与对应下标位置的数字交换；</p><p>如果对应下标处已经有一个相同的值，则说明重复了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> nums[i];<span class="comment">//当前位置的值</span></span><br><span class="line">            <span class="comment">//如果当前位置的值等于i，则不需要进行操作</span></span><br><span class="line">            <span class="keyword">if</span> (cur == i) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">//这个地方很关键，只有当一个元素被放到正确的位置才让i+1</span></span><br><span class="line">                <span class="comment">//可以保证当前位置数字和目标位置数字交换时，目标位置的数字会被放到当前位置，继续交换，而不是被跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//nums[cur]表示要交换的目标位置</span></span><br><span class="line">            <span class="comment">//如果目标位置已经有一个相等的值，则表示重复</span></span><br><span class="line">            <span class="keyword">if</span> (nums[cur] == cur)</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> cur;</span><br><span class="line">            nums[i] = nums[cur];</span><br><span class="line">            nums[cur] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：46 MB, 在所有 Java 提交中击败了84.17%的用户</p><p>时间O(n)</p><p>空间O(1)</p><hr><h1 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04 二维数组中的查找"></a>04 二维数组中的查找</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给定 target &#x3D; 5，返回 true。</p><p>给定 target &#x3D; 20，返回 false。</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>暴力解法就不说了。</p><p>本来想用一维数组中的二分查找的方法来写这道题，但是写着写着人就麻了；</p><p>后来参考力扣的题解，发现了一种不错的方法。</p><p>大致思路：</p><p>从二维数组的右上角开始遍历；</p><p>如果当前数字比target小，就向下移动一格；</p><p>如果当前数字比target大，就向前移动一格；</p><p>由于从右上角开始，左边的数一定比这个位置小，下边的数一定比这个位置大，因此一定不会错过目标值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">columns</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (rows &lt;= matrix.length - <span class="number">1</span> &amp;&amp; columns &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[rows][columns] &gt; target)</span><br><span class="line">                columns--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[rows][columns] &lt; target)</span><br><span class="line">                rows++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[rows][columns] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：44.2 MB, 在所有 Java 提交中击败了49.71%的用户</p><hr><h1 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05 替换空格"></a>05 替换空格</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>创建一个StringBuilder，然后遍历原字符串，遇到其他字符原样append()，遇到空格则append(“%20”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                stringBuilder.append(cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stringBuilder.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：35.9 MB, 在所有 Java 提交中击败了97.71%的用户</p><p>还有一种思路是创建一个s三倍长度的字符数组来操作，也是可以的</p><hr><h1 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06 从尾到头打印链表"></a>06 从尾到头打印链表</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><h3 id="初步思路"><a href="#初步思路" class="headerlink" title="初步思路"></a>初步思路</h3><p>初步思路是定义一个List，储存每一个节点的值，最后反转一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：3 ms, 在所有 Java 提交中击败了6.82%的用户</p><p>内存消耗：39 MB, 在所有 Java 提交中击败了47.28%的用户</p><p>这耗时确实铸币了。。。。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>用一个栈来实现反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[stack.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pointer</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            res[pointer++] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了73.77%的用户</p><p>内存消耗：39.1 MB, 在所有 Java 提交中击败了41.07%的用户</p><hr><h1 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07 重建二叉树"></a>07 重建二叉树</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><p><strong><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/%E9%A2%98%E8%AE%B0%E5%BD%95/tree.jpg" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [-1], inorder = [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><h4 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h4><p>前序遍历性质： 节点按照 <code>[ 根节点 | 左子树 | 右子树 ]</code> 排序。<br>中序遍历性质： 节点按照 <code>[ 左子树 | 根节点 | 右子树 ]</code> 排序。</p><p>根据这两个性质，可以有以下推论：</p><p>1、前序遍历的第一个元素是树的根节点</p><p>2、根据推论<code>1</code>又可以找到中序遍历数组中的根节点的位置，从而将其划分为<code>[ 左子树 | 根节点 | 右子树 ]</code></p><p>3、根据推论<code>2</code>可以知道中序遍历中左&#x2F;右子树节点的节点数量，从而将前序遍历数组划分为<code>[ 根节点 | 左子树 | 右子树 ]</code></p><p>通过<code>1,2,3</code>推论，可以确定出三个节点：<code>树的根节点、左子树的根节点、右子树的根节点</code></p><p>对于树的左&#x2F;右子树，可以再次使用上述步骤确定点。</p><h4 id="详细思路"><a href="#详细思路" class="headerlink" title="详细思路"></a>详细思路</h4><p><strong>前序遍历</strong></p><table><thead><tr><th align="center">根节点</th><th align="center">左子树</th><th align="center">右子树</th></tr></thead><tbody><tr><td align="center">3</td><td align="center">9</td><td align="center">20，15，7</td></tr></tbody></table><p><strong>中序遍历</strong></p><table><thead><tr><th align="center">左子树</th><th align="center">根节点</th><th align="center">右子树</th></tr></thead><tbody><tr><td align="center">9</td><td align="center">3</td><td align="center">15，20，7</td></tr></tbody></table><p>重建一棵二叉树，需要三个点（用索引表示）：</p><p>1、根节点<code>root</code>：前序遍历中的第一个点</p><p>2、左节点<code>left</code>：前序遍历中左子树的第一个点，即<code>left=root+1</code></p><p>3、右节点<code>right</code>：前序遍历中右子树的第一个点，等于root+左子树的长度+1</p><p>左子树的长度&#x3D;中序遍历中根节点的索引-中序遍历的左边界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//前序遍历性质： 节点按照 [ 根节点 | 左子树 | 右子树 ] 排序。</span></span><br><span class="line">    <span class="comment">//中序遍历性质： 节点按照 [ 左子树 | 根节点 | 右子树 ] 排序。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用map存中序遍历的数组的指对应的索引，方便找到某个数在中序数组中的下标</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//保存一下前序遍历的数组，主要是方便传参</span></span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个参数：当前根节点在前序遍历中的索引</span></span><br><span class="line">        <span class="comment">//第二个参数：当前树在中序遍历中的左边界</span></span><br><span class="line">        <span class="comment">//第三个参数：当前树在中序遍历中的右边界</span></span><br><span class="line">        <span class="keyword">return</span> rebuild(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">rebuild</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//建立根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[root]);</span><br><span class="line">        <span class="comment">//找到根节点在中序遍历中的下标位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> map.get(preorder[root]);</span><br><span class="line">        <span class="comment">//找node的左节点，即左子树的根节点</span></span><br><span class="line">        <span class="comment">//根节点索引是前序遍历中 左子树 部分的第一个，也就是root+1</span></span><br><span class="line">        <span class="comment">//左边界不变，右边界为根节点在中序遍历的索引-1，因为进入这个分治递归后，主体是左子树</span></span><br><span class="line">        node.left = rebuild(root + <span class="number">1</span>, left, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//找node的右节点，即右子树的根节点</span></span><br><span class="line">        <span class="comment">//根节点索引是前序遍历中 右子树部分的第一个，也就是root+i+1</span></span><br><span class="line">        <span class="comment">//左边界是中序遍历中右子树的第一个，也就是i+1，右边界不变</span></span><br><span class="line">        node.right = rebuild(root + (i - left) + <span class="number">1</span>, i + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了96.38%的用户</p><p>内存消耗：38.1 MB, 在所有 Java 提交中击败了92.77%的用户</p><hr><h1 id="09-双栈实现队列"><a href="#09-双栈实现队列" class="headerlink" title="09 双栈实现队列"></a>09 双栈实现队列</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><h3 id="初步思路-1"><a href="#初步思路-1" class="headerlink" title="初步思路"></a>初步思路</h3><p>这道题思路很简单，我们定义两个栈分别叫<strong>stack1</strong>和<strong>stack2</strong>;</p><p>当在尾部插入元素事，就push进stack1，要删除头部元素时，就将stack1一个个pop并push入stack2，此时stack2的栈顶元素就是一开始的队列头部元素，将其pop后再把stack2还原入stack1即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stack2.isEmpty())</span><br><span class="line">            num = stack2.pop();</span><br><span class="line">        <span class="keyword">while</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：233 ms, 在所有 Java 提交中击败了8.27%的用户</p><p>内存消耗：46.6 MB, 在所有 Java 提交中击败了61.03%的用户</p><p>可以看到时间复杂度有些高了。</p><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>主要时间复杂度出在删除头部元素这个方法；</p><p>我们每次通过stack2把头部元素删除后，又重新把stack2还原回了stack1，其实这一步是没必要的；</p><p>只要stack2不为空，那么stack2栈顶的元素始终是头部元素。</p><p>根据这个思路我们可以优化一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack1.isEmpty())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：43 ms, 在所有 Java 提交中击败了79.66%的用户</p><p>内存消耗：46.6 MB, 在所有 Java 提交中击败了61.50%的用户</p><hr><h1 id="10-I-斐波那契数列"><a href="#10-I-斐波那契数列" class="headerlink" title="10 I 斐波那契数列"></a>10 I 斐波那契数列</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><p>F(0) &#x3D; 0,   F(1) &#x3D; 1<br>F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><h3 id="初步思路-2"><a href="#初步思路-2" class="headerlink" title="初步思路"></a>初步思路</h3><p>简单的动态规划，但是有几个小细节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//新建数组大小是n+1，因为输入的n表示的第n项是从1开始的</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">            dp[i] %= <span class="number">1000000007</span>;</span><br><span class="line">            <span class="comment">//取模，不光是题目要求，也是为了防止越界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：35.3 MB, 在所有 Java 提交中击败了25.87%的用户</p><h3 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h3><p>其实类似的动态规划的优化思路都相似；</p><p>由状态转移方程<code>dp[n] = dp[n - 1] + dp[n - 2]</code>可知，每一步要求得<code>dp[n]</code>其实只是要知道前两个位置的值就可以了，因此没必要创建<code>n+1</code>大小的数组。</p><p>这种优化有几个细节需要注意。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//a相当于F(0)，b相当于F(1);</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//要计算出F(n)，只要循环n-1次，</span></span><br><span class="line">        <span class="comment">//因为sum一开始就是a+b，相当于已经算过F(1)了</span></span><br><span class="line">        <span class="comment">//也正是因为如此，上面需要特判一下n=1的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：35.2 MB, 在所有 Java 提交中击败了54.16%的用户</p><hr><h1 id="10-II-青蛙跳台阶问题"><a href="#10-II-青蛙跳台阶问题" class="headerlink" title="10 II 青蛙跳台阶问题"></a>10 II 青蛙跳台阶问题</h1><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>0 &lt;= n &lt;= 100</code></p><h2 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h2><h3 id="初步思路-3"><a href="#初步思路-3" class="headerlink" title="初步思路"></a>初步思路</h3><p>其实这题和<code>10II</code>一模一样</p><p>创建一个数组dp，dp[n]表示跳上第n级有多少种跳法</p><p>状态转移方程：<code>dp[n]=dp[n-1]+dp[n-2]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">            dp[i] %= <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：35.3 MB, 在所有 Java 提交中击败了26.45%的用户</p><h3 id="优化-3"><a href="#优化-3" class="headerlink" title="优化"></a>优化</h3><p>其实类似的动态规划的优化思路都相似；</p><p>由状态转移方程<code>dp[n] = dp[n - 1] + dp[n - 2]</code>可知，每一步要求得<code>dp[n]</code>其实只是要知道前两个位置的值就可以了，因此没必要创建<code>n+1</code>大小的数组。</p><p>这种优化有几个细节需要注意。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//c初始化成n=0的情况，这样就免去了n=0的特判</span></span><br><span class="line">        /</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            c = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：35.1 MB, 在所有 Java 提交中击败了63.06%的用户</p><hr><h1 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11 旋转数组的最小数字"></a>11 旋转数组的最小数字</h1><p>tag:</p><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h2 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h2><p>用二分法，但是和普通二分有些区别。</p><p>只要找出被旋转的位置，就相当于找出了最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[middle] &lt; numbers[right]) &#123;</span><br><span class="line">                <span class="comment">//如果numbers[middle]&lt;numbers[right]</span></span><br><span class="line">                <span class="comment">//说明被旋转的位置区间在[left,middle]</span></span><br><span class="line">                <span class="comment">//注意这个地方不是middle-1，因为middle本身就有可能是最小的值</span></span><br><span class="line">                right = middle;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[middle] &gt; numbers[right]) &#123;</span><br><span class="line">                <span class="comment">//如果numbers[middle]&lt;numbers[right]</span></span><br><span class="line">                <span class="comment">//说明被旋转的位置区间在[middle+1,right]</span></span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果numbers[middle]=numbers[right]</span></span><br><span class="line">                <span class="comment">//此时不好判断旋转点在左边还是右边，就可以让right--，再继续</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.3 MB, 在所有 Java 提交中击败了31.42%的用户</p><hr><h1 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12 矩阵中的路径"></a>12 矩阵中的路径</h1><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/%E9%A2%98%E8%AE%B0%E5%BD%95/word2.jpg" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>1 &lt;= board.length &lt;= 200</code><br><code>1 &lt;= board[i].length &lt;= 200</code><br><code>board 和 word 仅由大小写英文字母组成</code></p><h2 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h2><h3 id="回溯-递归"><a href="#回溯-递归" class="headerlink" title="回溯&#x2F;递归"></a>回溯&#x2F;递归</h3><p>需要<code>board[i][j]=words[k]</code>的原因：</p><blockquote><p>递归搜索匹配字符串过程中，需要 <code>board[i][j] = &#39;\0&#39;</code> 来防止在<strong>当前这次递归</strong>中 ”走回头路“ 。当匹配字符串不成功时，会回溯返回，此时需要<code>board[i][j] = words[k]</code> 来”取消对此单元格的标记”。 在DFS过程中，每个单元格会多次被访问的， <code>board[i][j] = &#39;/&#39;</code>只是要保证在<strong>当前匹配方案中不要走回头路</strong>，当初始i j变化时，又开始了另一次搜索过程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, word.toCharArray(), i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">char</span>[] words, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//先判断i，j是否越界，board[i][j]是否不等于word[k]</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != words[k]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果k=words.length-1，说明已经匹配完成，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (k == words.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//暂时将board[i][j]赋值为空，来表示已经访问过</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">//向当前元素的上下左右不同方向开始进行下一层的递归，使用||连接，</span></span><br><span class="line">        <span class="comment">//（代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> dfs(board, words, i - <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(board, words, i + <span class="number">1</span>, j, k + <span class="number">1</span>) ||</span><br><span class="line">                dfs(board, words, i, j - <span class="number">1</span>, k + <span class="number">1</span>) || dfs(board, words, i, j + <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将当前位置还原</span></span><br><span class="line">        board[i][j] = words[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行用时：8 ms, 在所有 Java 提交中击败了19.14%的用户</p><p>内存消耗：39.2 MB, 在所有 Java 提交中击败了93.75%的用户</p><hr><h1 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13 机器人的运动范围"></a>13 机器人的运动范围</h1><h2 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h2><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 1, k = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>1 &lt;= n,m &lt;= 100</code><br><code>0 &lt;= k &lt;= 20</code></p><h3 id="回溯-递归-1"><a href="#回溯-递归-1" class="headerlink" title="回溯&#x2F;递归"></a>回溯&#x2F;递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> m, n, k;</span><br><span class="line">    <span class="type">boolean</span>[][] visited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.m = m;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="comment">//访问s</span></span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回溯函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">//如果i、j越界 或 i，j的位数和大于k 或 i，j已经访问过，则返回0；</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= m || j &gt;= n || getSum(i) + getSum(j) &gt; k || visited[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前位置标记为访问过</span></span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j) + dfs(i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算位数和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：35.2 MB, 在所有 Java 提交中击败了81.27%的用户</p><hr><h1 id="14-I-剪绳子"><a href="#14-I-剪绳子" class="headerlink" title="14 I 剪绳子"></a>14 I 剪绳子</h1><h2 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 <code>k[0]*k[1]*...*k[m-1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>2 &lt;= n &lt;= 58</code></p><h2 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h2><blockquote><p>数学推论：</p><p>1、将绳子以相等的长度等分成多段，得到的乘积最大</p><p>2、尽可能将绳子以长度3等分</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="type">int</span>) Math.pow(<span class="number">3</span>, a);</span><br><span class="line">        <span class="comment">//余1，拆分出一个3，然后再乘4</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="type">int</span>) Math.pow(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//余2</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) Math.pow(<span class="number">3</span>, a) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：35.1 MB, 在所有 Java 提交中击败了76.10%的用户</p><hr><h1 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15 二进制中1的个数"></a>15 二进制中1的个数</h1><h2 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>).）。</p><p><strong>提示：</strong></p><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 11 (控制台输入 00000000000000000000000000001011)</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 128 (控制台输入 00000000000000000000000010000000)</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>输入必须是长度为 32 的 二进制串 。</code></p><h2 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h2><h3 id="逐位判断"><a href="#逐位判断" class="headerlink" title="逐位判断"></a>逐位判断</h3><p>若n&amp;1&#x3D;0，则n二进制最右边一位为0；</p><p>若n&amp;1&#x3D;1，则n二进制最右边一位为1；</p><p>每次判断最右一位后，将n右移一位</p><blockquote><p>java中的<code>&gt;&gt;</code>表示有符号右移，</p><p><code>&gt;&gt;&gt;</code>表示无符号右移，高位补0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            res += n &amp; <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：35.4 MB, 在所有 Java 提交中击败了38.60%的用户</p><h3 id="n-n-1"><a href="#n-n-1" class="headerlink" title="n&amp;(n-1)"></a>n&amp;(n-1)</h3><blockquote><p>n&amp;(n-1)的结果是将n的最右边的1变成0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：35.2 MB, 在所有 Java 提交中击败了82.41%的用户</p><hr><h1 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16 数值的整数次方"></a>16 数值的整数次方</h1><h2 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h2><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.10000, n = 3</span><br><span class="line">输出：9.26100</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.00000, n = -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>-100.0 &lt; x &lt; 100.0</code><br><code>-231 &lt;= n &lt;= 231-1</code><br><code>-104 &lt;= xn &lt;= 104</code></p><h2 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h2><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速幂的大致思路：</p><p><img src="https://fengyeblog-img.oss-cn-beijing.aliyuncs.com/img/image-20210915003526615.png" alt="image-20210915003526615"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果b的最后一位为1，则给res乘上x</span></span><br><span class="line">            <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                res *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：36.5 MB, 在所有 Java 提交中击败了84.57%的用户</p><blockquote><p>参考：<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/jian-dan-li-jie-kuai-su-mi-by-ollieq-rl74/">简单理解快速幂 - 数值的整数次方 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><hr><h1 id="18-删除列表的节点"><a href="#18-删除列表的节点" class="headerlink" title="18 删除列表的节点"></a>18 删除列表的节点</h1><h2 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p><h2 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//如果要删除的是head，则直接返回head.next</span></span><br><span class="line">        <span class="keyword">if</span> (head.val == val)</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.val == val) &#123;</span><br><span class="line">                slow.next = fast.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：37.9 MB, 在所有 Java 提交中击败了37.42%的用户</p><hr><h1 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19 正则表达式匹配"></a>19 正则表达式匹配</h1><h2 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#x27;*&#x27; 表示零个或多个，这里 &#x27;c&#x27; 为 0 个, &#x27;a&#x27; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br><span class="line">s 可能为空，且只包含从 a-z 的小写字母。</span><br><span class="line">p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 &#x27;*&#x27;。</span><br></pre></td></tr></table></figure><h2 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>定义动态规划矩阵 <code>dp</code> , <code>dp[i][j]</code> 表示字符串 <code>s </code> 的前 <code>i</code> 个字符和字符串 <code>p</code> 的前 <code>j</code> 个字符能否匹配</p><p><code>dp[0][0]</code>表示空串</p><p>状态转移方程推导：</p><ol><li>当<code>p[j-1]</code>为字母时</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : pushed) &#123;</span><br><span class="line">            <span class="comment">//将pushed中的num压入stack</span></span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="comment">//如果stack不为空并且stack顶的元素等于popped[index]，</span></span><br><span class="line">            <span class="comment">//则弹出栈顶并让index++；</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[index]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最后stack为空，说明true</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了88.16%的用户</p><p>内存消耗：38 MB, 在所有 Java 提交中击败了63.24%的用户</p><blockquote><p>参考：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/mian-shi-ti-31-zhan-de-ya-ru-dan-chu-xu-lie-mo-n-2/">面试题31. 栈的压入、弹出序列（模拟，清晰图解） - 栈的压入、弹出序列 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><hr><h1 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20 表示数值的字符串"></a>20 表示数值的字符串</h1><h2 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p><p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p><ol><li>若干空格</li><li>一个 小数 或者 整数</li><li>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数</li><li>若干空格</li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（’+’ 或 ‘-‘）</li><li>下述格式之一：<ol><li>至少一位数字，后面跟着一个点 ‘.’</li><li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li><li>一个点 ‘.’ ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li><p>（可选）一个符号字符（’+’ 或 ‘-‘）</p></li><li><p>至少一位数字</p></li></ol><p>部分<strong>数值</strong>列举如下：</p><ul><li>[“+100”, “5e2”, “-123”, “3.1416”, “-1E-16”, “0123”]</li></ul><p>部分<strong>非数值</strong>列举如下：</p><ul><li>[“12e”, “1a3.14”, “1.2.3”, “+-5”, “12e+5.4”]</li></ul><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;0&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;e&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;.&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;    .1  &quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>1 &lt;= s.length &lt;= 20</code><br><code>s 仅含英文字母（大写和小写），数字（0-9），加号 &#39;+&#39; ，减号 &#39;-&#39; ，空格 &#39; &#39; 或者点 &#39;.&#39; 。</code></p><h2 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h2><p>归纳各种正确的情况，排除了正确情况之外的就直接return false就好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">numFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">dotFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">eFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果当前为数字，则numFlag标记为true</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                numFlag = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//如果当前为&#x27;.&#x27;且没有出现过&#x27;.&#x27;或&#x27;E&#x27;、&#x27;e&#x27;，则dotFlag标记为true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;.&#x27;</span> &amp;&amp; !dotFlag &amp;&amp; !eFlag) &#123;</span><br><span class="line">                dotFlag = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//如果当前为&#x27;e&#x27;，并且没有出现过&#x27;e&#x27;同时出现过数字，则eFlag标记为true，numFlag标记为true</span></span><br><span class="line">            <span class="comment">//或当前i==0（因为e1000这种也算数字）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((s.charAt(i) == <span class="string">&#x27;e&#x27;</span> || s.charAt(i) == <span class="string">&#x27;E&#x27;</span>) &amp;&amp; !eFlag &amp;&amp; numFlag || i==<span class="number">0</span>) &#123;</span><br><span class="line">                eFlag = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//由于题目要求中e后面必须要有数字，因此如果这一位为1，则暂时把numFlag改成false</span></span><br><span class="line"></span><br><span class="line">                numFlag = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//如果当前为&#x27;+&#x27;或&#x27;-&#x27;，则必须是在第一位或者在&#x27;e&#x27;后面</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((s.charAt(i) == <span class="string">&#x27;+&#x27;</span> || s.charAt(i) == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (i == <span class="number">0</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;e&#x27;</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;E&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">//其他情况都不是数字</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后返回numFlag</span></span><br><span class="line">        <span class="comment">//主要是为了防止E出现在最后一位的情况</span></span><br><span class="line">        <span class="keyword">return</span> numFlag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了99.11%的用户</p><p>内存消耗：38.2 MB, 在所有 Java 提交中击败了78.13%的用户</p><hr><h1 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21 调整数组顺序使奇数位于偶数前面"></a>21 调整数组顺序使奇数位于偶数前面</h1><h2 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>0 &lt;= nums.length &lt;= 50000</code><br><code>1 &lt;= nums[i] &lt;= 10000</code></p><h2 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h2><h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h3><ul><li>定义头指针 p1 ，尾指针 p2 </li><li>p1 一直往右移，直到它指向的值为偶数</li><li>p2 一直往左移， 直到它指向的值为奇数</li><li>交换 nums[p1] 和 nums[p2] </li><li>重复上述操作，直到 p1&#x3D;&#x3D;p2</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>, p2 = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; p2) &#123;</span><br><span class="line">            <span class="comment">//如果p1指向的位置是奇数，则往右移动一格并跳过这次循环</span></span><br><span class="line">            <span class="keyword">if</span> (nums[p1] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                p1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果p2指向的位置是偶数，则往右移动一格并跳过这次循环</span></span><br><span class="line">            <span class="keyword">if</span> (nums[p2] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                p2--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当执行到这一步时，p1指向的是偶数，p2指向的是奇数</span></span><br><span class="line">            <span class="comment">//交换p1和p2上的数字</span></span><br><span class="line">            temp = nums[p1];</span><br><span class="line">            nums[p1] = nums[p2];</span><br><span class="line">            nums[p2] = temp;</span><br><span class="line">            <span class="comment">//当p1和p2上的位置交换后，</span></span><br><span class="line">            <span class="comment">//p1指向的就已经是奇数了，p2指向的也已经是偶数了，</span></span><br><span class="line">            <span class="comment">//直接让p1++，p2--跳过dang&#x27;qian</span></span><br><span class="line">            p1++；</span><br><span class="line">            p2--；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了89.24%的用户</p><p>内存消耗：46 MB, 在所有 Java 提交中击败了89.88%的用户</p><hr><h1 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22 链表中倒数第k个节点"></a>22 链表中倒数第k个节点</h1><h2 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure><h2 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h2><h3 id="双指针-2"><a href="#双指针-2" class="headerlink" title="双指针"></a>双指针</h3><p>fast先向前移动k个位置</p><p>然后fast和slow一起移动，当fast为null时，slow指向的就是倒数第k个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：36.1 MB, 在所有 Java 提交中击败了77.89%的用户</p><hr><h1 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24 反转链表"></a>24 反转链表</h1><h2 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h2><h3 id="初步思路-4"><a href="#初步思路-4" class="headerlink" title="初步思路"></a>初步思路</h3><p>使用双指针的方法；</p><p>定义一个<strong>fast</strong>和一个<strong>slow</strong>指针，fast在前slow在后，每次把fast的next指向slow，再将fast和slow都向前移动；</p><p>循环多次后，链表就反转了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//注意初始状态，slow是null，才能保证反转后最后一个节点的next为null</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> fast.next;</span><br><span class="line">            <span class="comment">//定义一个temp来暂存fast的下一个</span></span><br><span class="line">            fast.next = slow;</span><br><span class="line">            slow = fast;</span><br><span class="line">            fast = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.2 MB, 在所有 Java 提交中击败了38.51%的用户</p><hr><h1 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25 合并两个排序的链表"></a>25 合并两个排序的链表</h1><h2 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 链表长度 &lt;= 1000</span><br></pre></td></tr></table></figure><h2 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">//定义dum节点表示新链表的头节点的前一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dum;</span><br><span class="line">        <span class="comment">//l1和l2中有一个为null，则停止</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//讲不为null的直接接在cur的</span></span><br><span class="line">        cur.next = l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.4 MB, 在所有 Java 提交中击败了79.34%的用户</p><hr><h1 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26 树的子结构"></a>26 树的子结构</h1><h2 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>给定的树 B:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4 </span><br><span class="line"> /</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,2,3], B = [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [3,4,5,1,2], B = [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><h2 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>要遍历树，很常用的思路就是用递归。</p><p>其实在写递归的时候，我们只需要知道这个函数每一步要实现的操作是什么，不需要去纠结具体的递归的过程。</p><p>这道题要我们判断B是不是A的子结构，分析一下函数的大概思路：</p><p>1、用一个函数遍历A树的节点</p><p>2、以A的每个节点为基准，和B进行比较(需要一个辅助函数isSub)</p><p>​假设A每次遍历到的节点为Na，B每次遍历到的节点为Nb，辅助函数的流程：</p><p>​1、如果<code>Nb==null</code>，说明B遍历到底了，返回true</p><p>​2、如果<code>Nb!=null &amp;&amp; Na==null || Nb.val!=Na.val</code>，则返回false</p><p>​3、递归调用<code>return isSub(Na.left,Nb.left) &amp;&amp; isSub(Na.right,Nb.right)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (B == <span class="literal">null</span> || A == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//先从根节点判断B是不是A的子结构，如果不是在分别从左右两个子树判断，</span></span><br><span class="line">    <span class="comment">//只要有一个为true，就说明B是A的子结构</span></span><br><span class="line">        <span class="keyword">return</span> isSub(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSub</span><span class="params">(TreeNode Na, TreeNode Nb)</span> &#123;</span><br><span class="line">        <span class="comment">//这里如果B为空，说明B已经访问完了，确定是A的子结构</span></span><br><span class="line">        <span class="keyword">if</span> (Nb == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果B不为空A为空，或者这两个节点值不同，说明B树不是A的子结构，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (Na == <span class="literal">null</span> || Nb.val != Na.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//当前节点比较完之后还要继续判断左右子节点</span></span><br><span class="line">        <span class="keyword">return</span> isSub(Na.left, Nb.left) &amp;&amp; isSub(Na.right, Nb.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39.6 MB, 在所有 Java 提交中击败了98.40%的用户</p><hr><h1 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27 二叉树的镜像"></a>27 二叉树的镜像</h1><h2 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>镜像输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSubStructure(TreeNode A, TreeNode B) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><h2 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h2><p>1、交换当前节点的左右子节点</p><p>2、递归调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) mirrorTree(root.left);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) mirrorTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：35.5 MB, 在所有 Java 提交中击败了95.94%的用户</p><hr><h1 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28 对称的二叉树"></a>28 对称的二叉树</h1><h2 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><h2 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h2><p>创建一个辅助函数，每次递归调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> help(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">help</span><span class="params">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">        <span class="comment">//如果左右节点同时为null，就返回true</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果有一个节点节点为null，或者左右</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> || right == <span class="literal">null</span> || left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//将left.left和right.right、left.right和right.left比较</span></span><br><span class="line">        <span class="keyword">return</span> help(left.left, right.right) &amp;&amp; help(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：35.5 MB, 在所有 Java 提交中击败了95.94%的用户</p><hr><h1 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29 顺时针打印矩阵"></a>29 顺时针打印矩阵</h1><h2 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= matrix.length &lt;= 100</code><br><code>0 &lt;= matrix[i].length &lt;= 100</code></p><h2 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>定义上下左右四个边界，从外至内循环遍历并缩小边界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[row * col];</span><br><span class="line">        <span class="comment">//定义四个边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, left = <span class="number">0</span>, right = col - <span class="number">1</span>, under = row - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历上边</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">                res[x++] = matrix[top][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++top &gt; under) <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//遍历右边</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt;= under; i++) &#123;</span><br><span class="line">                res[x++] = matrix[i][right];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--right &lt; left) <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//遍历下边</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i &gt;= left; i--) &#123;</span><br><span class="line">                res[x++] = matrix[under][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--under &lt; top) <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//遍历左边</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> under; i &gt;= top; i--) &#123;</span><br><span class="line">                res[x++] = matrix[i][left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了97.43%的用户</p><p>内存消耗：39.8 MB, 在所有 Java 提交中击败了44.19%的用户</p><blockquote><p>参考：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/">面试题29. 顺时针打印矩阵（模拟、设定边界，清晰图解） - 顺时针打印矩阵 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><hr><h1 id="30-包含min的栈"><a href="#30-包含min的栈" class="headerlink" title="30 包含min的栈"></a>30 包含min的栈</h1><h2 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h2><p>这道题的朴素做法很简单，但是题目要求我们调用min的时间复杂度是O(1)所以朴素做法肯定不行。</p><p>我们需要采用辅助栈的方法，用空间换取时间。</p><p>定义两个栈分别叫stack1和stack2；</p><p>stack1用来进行正常的栈操作，stack2则存储实时的最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">        stack2.push(Math.min(x, stack2.peek()));</span><br><span class="line">        <span class="comment">//每次stack2push的都是当前stack1中实时的最小值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1.pop();</span><br><span class="line">        stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：17 ms, 在所有 Java 提交中击败了94.11%的用户</p><p>内存消耗：40.4 MB, 在所有 Java 提交中击败了19.29%的用户</p><hr><h1 id="31-栈的压入，弹出序列"><a href="#31-栈的压入，弹出序列" class="headerlink" title="31 栈的压入，弹出序列"></a>31 栈的压入，弹出序列</h1><h2 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code><br><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code><br><code>pushed 是 popped 的排列。</code></p><h2 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h2><h3 id="模拟-1"><a href="#模拟-1" class="headerlink" title="模拟"></a>模拟</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : pushed) &#123;</span><br><span class="line">            <span class="comment">//将pushed中的num压入stack</span></span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="comment">//如果stack不为空并且stack顶的元素等于popped[index]，</span></span><br><span class="line">            <span class="comment">//则弹出栈顶并让index++；</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[index]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最后stack为空，说明true</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了88.16%的用户</p><p>内存消耗：38 MB, 在所有 Java 提交中击败了63.24%的用户</p><blockquote><p>参考：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/mian-shi-ti-31-zhan-de-ya-ru-dan-chu-xu-lie-mo-n-2/">面试题31. 栈的压入、弹出序列（模拟，清晰图解） - 栈的压入、弹出序列 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><hr><h1 id="32-I-从上到下打印二叉树"><a href="#32-I-从上到下打印二叉树" class="headerlink" title="32 I 从上到下打印二叉树"></a>32 I 从上到下打印二叉树</h1><h2 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h2><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure><h2 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h2><p>这种题都是用BFS(广度优先)</p><p>BFS的思路：</p><p>1、创建一个list和一个queue</p><p>2、只要队列不为空则一直持续BFS循环：</p><p>​①弹出队首元素并将它的值存入list</p><p>​②如果这个元素的左(右)子节点不为空，则将其添加入队列</p><p>3、最后list中就是二叉树中从上至下的元素值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//return list.stream().mapToInt(Integer::valueOf).toArray();</span></span><br><span class="line">        <span class="comment">//steam的写法，但是好像比直接遍历耗时更久</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了99.35%的用户</p><p>内存消耗：38.5 MB, 在所有 Java 提交中击败了70.89%的用户</p><hr><h1 id="32-II-从上到下打印二叉树"><a href="#32-II-从上到下打印二叉树" class="headerlink" title="32 II 从上到下打印二叉树"></a>32 II 从上到下打印二叉树</h1><h2 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h2><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h2><p>与<code>32I</code>的传统BFS有所不同，这个题要求的结果是分层的，这就需要我们在BFS中添加一层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">//关键！</span></span><br><span class="line">                <span class="comment">//让i从queue.size()递减，就不需要担心queue的长度会变化了，因为在for中初始化的操作只执行一次</span></span><br><span class="line">                <span class="comment">//每次queue.size()就表示这一层的所有元素的个数</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了94.07%的用户</p><p>内存消耗：38.5 MB, 在所有 Java 提交中击败了67.98%的用户</p><hr><h1 id="32-III-从上到下打印二叉树"><a href="#32-III-从上到下打印二叉树" class="headerlink" title="32 III 从上到下打印二叉树"></a>32 III 从上到下打印二叉树</h1><h2 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h2><p>其实和<code>32II</code>一样，偶数层翻转一下就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">//关键！</span></span><br><span class="line">                <span class="comment">//让i从queue.size()递减，就不需要担心queue的长度会变化了，因为在for中初始化的操作只执行一次</span></span><br><span class="line">                <span class="comment">//每次queue.size()就表示这一层的所有元素的个数</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == -<span class="number">1</span>)</span><br><span class="line">                Collections.reverse(temp);</span><br><span class="line">            flag *= -<span class="number">1</span>;</span><br><span class="line">            list.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了98.60%的用户</p><p>内存消耗：38.5 MB, 在所有 Java 提交中击败了73.78%的用户</p><p>或者偶数层从list末尾加数字也行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">//关键！</span></span><br><span class="line">                <span class="comment">//让i从queue.size()递减，就不需要担心queue的长度会变化了，因为在for中初始化的操作只执行一次</span></span><br><span class="line">                <span class="comment">//每次queue.size()就表示这一层的所有元素的个数</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (flag == -<span class="number">1</span>) temp.addFirst(node.val);</span><br><span class="line">                <span class="comment">//如果是偶数层就每次添加在前面</span></span><br><span class="line">                <span class="keyword">else</span> temp.addLast(node.val);</span><br><span class="line">                <span class="comment">//如果是奇数层就正常添加在后面</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            flag *= -<span class="number">1</span>;</span><br><span class="line">            list.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了98.60%的用户</p><p>内存消耗：38.5 MB, 在所有 Java 提交中击败了83.35%的用户</p><hr><h1 id="33-二叉搜索树的后续遍历序列"><a href="#33-二叉搜索树的后续遍历序列" class="headerlink" title="33 二叉搜索树的后续遍历序列"></a>33 二叉搜索树的后续遍历序列</h1><h2 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyPostorder</span><span class="params">(<span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>数组长度 &lt;= 1000</code></p><h2 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h2><p>后序遍历: <code>[ 左子树 | 右子树 | 根节点 ]</code> </p><p><img src="C:/Users/summer/Desktop/1597978711-RQSXFJ-image.png" alt="image.png"></p><p>上图二叉树后续遍历结果：[3，5，4，10，12，9]</p><p>后序遍历的最后一个数一定是root，从前向后找到第一个大于root的数(即10)；</p><p>在10前面的都是root的左子树，在10后面的(不包括root)都是root的右子树。</p><p>通过这种方式，就把后续遍历的数组的左子树和右子树分开了。</p><p>由于是从左遍历过来的，因此左边的值一定都比root小，还需要确定右边的值都比root大。</p><p>最后递归调用左右节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyPostorder</span><span class="params">(<span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recur(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(<span class="type">int</span>[] postorder, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">//根节点的值一定在最右边</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">root_val</span> <span class="operator">=</span> postorder[right];</span><br><span class="line">        <span class="comment">//找到第一个大于root的下标</span></span><br><span class="line">        <span class="keyword">while</span> (postorder[mid] &lt; root_val)</span><br><span class="line">            mid++;</span><br><span class="line">        <span class="comment">//判断一下右边的值是否都大于root的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (temp &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postorder[temp++] &lt; root_val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归调用左右节点</span></span><br><span class="line">        <span class="keyword">return</span> recur(postorder, left, mid - <span class="number">1</span>) &amp;&amp; recur(postorder, mid, right - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：35.5 MB, 在所有 Java 提交中击败了98.62%的用户</p><hr><h1 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34 二叉树中和为某一值的路径"></a>34 二叉树中和为某一值的路径</h1><h2 id="题目-31"><a href="#题目-31" class="headerlink" title="题目"></a>题目</h2><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例:</strong><br>给定如下二叉树，以及目标和 target &#x3D; 22，</p><pre><code>          5         / \        4   8       /   / \      11  13  4     /  \    / \    7    2  5   1</code></pre><p><strong>返回:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>提示：</p><p><code>节点总数 &lt;= 10000</code></p><h2 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h2><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><ul><li>递推参数当前节点root，当前目标值tar</li><li>终止条件：root为null时，直接返回</li><li>递归过程<ul><li>更新path：<code>root.val</code>加入<code>path</code></li><li>更新tar：<code>tar-=root.val</code></li><li>更新res：如果当前节点是叶节点，并且路径和为target（即tar&#x3D;0）</li><li>递归：递归遍历左右节点</li><li>恢复path：回溯前需要将当前节点从path中删除</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        dfs(root, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> tar)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">//tar</span></span><br><span class="line">        tar -= root.val;</span><br><span class="line">        <span class="keyword">if</span> (tar == <span class="number">0</span> &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//不能直接添加path，因为path只是一个引用，当退出这个函数就会被删除</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(path));</span><br><span class="line">        dfs(root.left, tar);</span><br><span class="line">        dfs(root.right, tar);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.8 MB, 在所有 Java 提交中击败了54.01%的用户</p><hr><h1 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35 复杂链表的复制"></a>35 复杂链表的复制</h1><h2 id="题目-32"><a href="#题目-32" class="headerlink" title="题目"></a>题目</h2><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h2><h3 id="思路-哈希表"><a href="#思路-哈希表" class="headerlink" title="思路(哈希表)"></a>思路(哈希表)</h3><p>如果要我们复制一个普通链表，这是相对比较简单的，可以设计如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">copyList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);<span class="comment">//定义哑节点，避免链表头没有pre节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dum;<span class="comment">//前驱节点，初始化为dum</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(head.val);<span class="comment">//复制一份节点</span></span><br><span class="line">            pre.next = cur;<span class="comment">//前驱节点的next指针指向当前节点</span></span><br><span class="line">            head = head.next;<span class="comment">//向后遍历</span></span><br><span class="line">            pre = cur;<span class="comment">//保存这个节点，作为下一个节点的前驱节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以分析一下，复制链表主要有两个步骤：1、复制节点；2、使构建出的节点的指针指向下一个节点；</p><p>这是两个不相关的过程，我们正常的流程应该是：先复制所有的节点，再从头开始构建指针指向；</p><p>而由于每个节点的next都是有顺序的，不会被打乱，因此我们可以把这两个步骤拆分开来放进循环体中。</p><p>但这题与复制普通链表的不同点在于，这个链表的每个节点除了next指针外，还有一个random指针；</p><p>random指针的指向是不确定的，如果我们把它引入循环不断找下一个random，可能会形成一个闭环。</p><p>所以这道题，我们需要把上述两个步骤拆分开：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建map的原因是为了保留一开始节点按照next遍历的顺序；</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;<span class="comment">//定义一个cur，用cur来遍历，以便找回原链表的头节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一轮遍历：构建节点并且按照原链表next遍历的顺序存入map</span></span><br><span class="line">        <span class="comment">//map本身是无序的，但是只要在get时的key是有序的，那么取出来的value就不会乱</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">            map.put(cur, node);</span><br><span class="line">            <span class="comment">//每当有新节点创建，就在map中存入一个key为原链表节点，value为新链表节点的键值对</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur = head;<span class="comment">//让cur复位到head，进行下一轮遍历</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二轮遍历：构建每个节点的next和random指针指向</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.1 MB, 在所有 Java 提交中击败了52.05%的用户</p><h3 id="优化思路-原地修改"><a href="#优化思路-原地修改" class="headerlink" title="优化思路(原地修改)"></a>优化思路(原地修改)</h3><p>在刚才的方法中，因为创建了哈希表的原因，导致空间复杂度有些高了。</p><p>那么怎么优化呢？</p><p>仔细想想刚才哈希表的作用，是为了保持住按照原链表按next遍历的顺序，那一定需要创建哈希表才能做到这样的效果吗？</p><p>其实我们还可以通过原地复制的办法做到。</p><p>具体思路：</p><p>假设原链表为 $node1\rightarrow node2\rightarrow node3\rightarrow \cdots$ (只看next指针顺序)</p><p>则我们可以在原地复制每个节点 $node1\rightarrow node1_{new} \rightarrow node2\rightarrow node2_{new} \rightarrow node3\rightarrow node3_{new} \rightarrow \cdots$</p><p>此时我们只需要给新节点构建random指针指向，再拆分就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//第一步操作：原地复制原链表的每个节点，并按next指针拼接起来</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">            temp.next = cur.next;</span><br><span class="line">            cur.next = temp;</span><br><span class="line">            cur = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二部操作：构建新节点的random指向</span></span><br><span class="line">    cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.random != <span class="literal">null</span>)</span><br><span class="line">                cur.next.random = cur.random.next;</span><br><span class="line">            <span class="comment">//cur.next.random相当于newNode.random</span></span><br><span class="line">            <span class="comment">//由于第一步操作构建时，每一个旧节点的next都是一个一模一样的新节点</span></span><br><span class="line">            <span class="comment">//所以新节点的random就等于旧节点的random的next</span></span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三步操作：把两个链表拆分开来</span></span><br><span class="line">        cur = head.next;<span class="comment">//cur表示新链表</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head, res = head.next;<span class="comment">//pre表示旧链表</span></span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre.next = pre.next.next;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//由于在构建节点时，旧链表最后一个节点的next指向的是旧链表的最后一个节点，所以需要让它重新指向null</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：37.8 MB, 在所有 Java 提交中击败了84.64%的用户</p><hr><h1 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36 二叉搜索树与双向链表"></a>36 二叉搜索树与双向链表</h1><h2 id="题目-33"><a href="#题目-33" class="headerlink" title="题目"></a>题目</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解-32"><a href="#题解-32" class="headerlink" title="题解"></a>题解</h2><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><blockquote><p><a href="https://www.cnblogs.com/vipchenwei/p/7562567.html">二叉树的三种遍历方式 - 博客园 (cnblogs.com)</a></p></blockquote><p>中序遍历二叉树，因为是中序遍历，所以遍历顺序就是双线链表的建立顺序。我们只需要在中序遍历的过程中，修改每个节点的左右指针，将零散的节点连接成双向循环链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Node head, pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="comment">//最后head就是头节点，pre是尾节点</span></span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        dfs(cur.left);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上一步dfs(cur.left)执行完之后，当前的这个cur指向的是二叉树左下角的叶节点</span></span><br><span class="line">        <span class="comment">//即最小的那个元素，此时将head定义为这个元素</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">null</span>) head = cur;</span><br><span class="line">        <span class="keyword">else</span> pre.right = cur;</span><br><span class="line">        <span class="comment">//当前节点的left赋值为pre</span></span><br><span class="line">        cur.left = pre;</span><br><span class="line">        <span class="comment">//更新pre</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        </span><br><span class="line">        dfs(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：37.8 MB, 在所有 Java 提交中击败了50.55%的用户</p><hr><h1 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37 序列化二叉树"></a>37 序列化二叉树</h1><h2 id="题目-34"><a href="#题目-34" class="headerlink" title="题目"></a>题目</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅<a href="https://support.leetcode-cn.com/hc/kb/article/1194353/">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/%E9%A2%98%E8%AE%B0%E5%BD%95/serdeser.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,null,null,4,5]</span><br><span class="line">输出：[1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure><h2 id="题解-33"><a href="#题解-33" class="headerlink" title="题解"></a>题解</h2><h3 id="深度优先-先序遍历"><a href="#深度优先-先序遍历" class="headerlink" title="深度优先(先序遍历)"></a>深度优先(先序遍历)</h3><p>序列化：</p><p>由于需要反序列化，因此为了保证数据的完整性，null节点也要保存</p><p>反序列化：</p><p>先序遍历的结果 <code>[ 根节点 | 左子树 | 右子树 ]</code>。</p><p>而在这个<code>[ 左子树 ]</code>中，也同样存在着<code>[ 根节点 | 左子树 | 右子树 ]</code>的结构。</p><p>因此只需要递归遍历序列化的结果。保存的null作为递归的回溯点就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先序遍历</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dfs</span><span class="params">(TreeNode root, String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            str += <span class="string">&quot;null,&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str += str.valueOf(root.val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            str = dfs(root.left, str);</span><br><span class="line">            str = dfs(root.right, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        String[] split = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        List&lt;String&gt; dataList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(Arrays.asList(split));</span><br><span class="line">        <span class="keyword">return</span> f(dataList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">f</span><span class="params">(List&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">        <span class="comment">//当前如果是None，说明遍历到底了，</span></span><br><span class="line">        <span class="comment">//就开始返回</span></span><br><span class="line">        <span class="keyword">if</span> (dataList.get(<span class="number">0</span>).equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">            dataList.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建当前节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.valueOf(dataList.get(<span class="number">0</span>)));</span><br><span class="line">        <span class="comment">//将当前节点移除</span></span><br><span class="line">        dataList.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//先遍历当前节点的左子树</span></span><br><span class="line">        root.left = f(dataList);</span><br><span class="line">        <span class="comment">//后遍历当前节点的右子树</span></span><br><span class="line">        root.right = f(dataList);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：105 ms, 在所有 Java 提交中击败了17.27%的用户</p><p>内存消耗：41.4 MB, 在所有 Java 提交中击败了8.98%的用户</p><h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h3><blockquote><p>参考：<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/solution/mian-shi-ti-37-xu-lie-hua-er-cha-shu-ceng-xu-bian-/">面试题37. 序列化二叉树（层序遍历 BFS ，清晰图解） - 序列化二叉树 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bfs(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">bfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                stringBuilder.append(node.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stringBuilder.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.deleteCharAt(stringBuilder.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        String[] split = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        List&lt;String&gt; dataList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(Arrays.asList(split));</span><br><span class="line">        <span class="keyword">return</span> f(dataList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">f</span><span class="params">(List&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.valueOf(dataList.get(<span class="number">0</span>)));</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!dataList.get(i).equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.valueOf(dataList.get(i)));</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (!dataList.get(i).equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(dataList.get(i)));</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：470 ms, 在所有 Java 提交中击败了5.12%的用户</p><p>内存消耗：42 MB, 在所有 Java 提交中击败了5.03%的用户</p><hr><h1 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38 字符串的排列"></a>38 字符串的排列</h1><h2 id="题目-35"><a href="#题目-35" class="headerlink" title="题目"></a>题目</h2><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>1 &lt;= s 的长度 &lt;= 8</code></p><h2 id="题解-34"><a href="#题解-34" class="headerlink" title="题解"></a>题解</h2><h3 id="回溯-剪枝"><a href="#回溯-剪枝" class="headerlink" title="回溯+剪枝"></a>回溯+剪枝</h3><blockquote><p>参考：<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/mian-shi-ti-38-zi-fu-chuan-de-pai-lie-hui-su-fa-by/">剑指 Offer 38. 字符串的排列（回溯法，清晰图解） - 字符串的排列 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        arr = s.toCharArray();</span><br><span class="line">        f(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(String.valueOf(arr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用来判断重复字符</span></span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//重复的剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(arr[i])) <span class="keyword">continue</span>;</span><br><span class="line">            set.add(arr[i]);</span><br><span class="line">            <span class="comment">//交换相当于固定一个位置</span></span><br><span class="line">            swap(i, x);</span><br><span class="line">            <span class="comment">//进入下一层递归</span></span><br><span class="line">            f(x + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//当结束一层递归时交换回来</span></span><br><span class="line">            swap(i, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：7 ms, 在所有 Java 提交中击败了95.64%的用户</p><p>内存消耗：43.4 MB, 在所有 Java 提交中击败了37.16%的用户</p><hr><h1 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39 数组中出现次数超过一半的数字"></a>39 数组中出现次数超过一半的数字</h1><h2 id="题目-36"><a href="#题目-36" class="headerlink" title="题目"></a>题目</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字(众数)。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>1 &lt;= 数组长度 &lt;= 50000</code></p><h2 id="题解-35"><a href="#题解-35" class="headerlink" title="题解"></a>题解</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(num) &gt; maxNum) &#123;</span><br><span class="line">                maxNum = map.get(num);</span><br><span class="line">                res = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：10 ms, 在所有 Java 提交中击败了28.80%的用户</p><p>内存消耗：43.7 MB, 在所有 Java 提交中击败了64.24%的用户</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>对数组进行排序，数组中间的元素一定是众数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了57.84%的用户</p><p>内存消耗：44.3 MB, 在所有 Java 提交中击败了37.45%的用户</p><h3 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h3><blockquote><p>设nums的众数为x，数组长度为n</p><p>推论一：若记众数的票数为1，非众数的票数为-1，则所有数字的票数&gt;0</p><p>推论二：若数组的前a个数字的票数和&#x3D;0，则数组剩余(n-a)个数字的票数和一定仍&gt;0，<strong>即剩下(n-a)个数字的众数仍然为x</strong></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/%E9%A2%98%E8%AE%B0%E5%BD%95/1603612327-bOQxzq-Picture1.png" alt="Picture1.png"></p></blockquote><p>算法大致思路：</p><p>1、遍历数组</p><p>​1、设当前数为众数</p><p>​2、向后遍历并计算票数和</p><p>​3、当票数和&#x3D;0时，缩小剩余数组区间，即重新假设当前数为众数</p><p>​4、最后一轮假设的数一定是众数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化x(众数)，votes(当前票数和)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, votes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">//当票数和=0，则假设当前数字是众数</span></span><br><span class="line">            <span class="keyword">if</span> (votes == <span class="number">0</span>) x = num;</span><br><span class="line">            <span class="comment">//加减票数和</span></span><br><span class="line">            votes += num == x ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了99.95%的用户</p><p>内存消耗：41.7 MB, 在所有 Java 提交中击败了87.36%的用户</p><hr><h1 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40 最小的k个数"></a>40 最小的k个数</h1><h2 id="题目-37"><a href="#题目-37" class="headerlink" title="题目"></a>题目</h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code><br><code>0 &lt;= arr[i] &lt;= 10000</code></p><h2 id="题解-36"><a href="#题解-36" class="headerlink" title="题解"></a>题解</h2><p>比较简单，排序一下就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(arr,k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> getPivotIndex(nums, left, right);</span><br><span class="line">            quickSort(nums, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPivotIndex</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[right] &gt;= pivot &amp;&amp; left &lt; right) right--;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            <span class="keyword">while</span> (nums[left] &lt;= pivot &amp;&amp; left &lt; right) left++;</span><br><span class="line">            nums[right] = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行用时：7 ms, 在所有 Java 提交中击败了69.41%的用户</p><p>内存消耗：39.7 MB, 在所有 Java 提交中击败了63.39%的用户</p><hr><h1 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41 数据流中的中位数"></a>41 数据流中的中位数</h1><h2 id="题目-38"><a href="#题目-38" class="headerlink" title="题目"></a>题目</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>最多会对 addNum、findMedian 进行 50000 次调用</code></p><h2 id="题解-37"><a href="#题解-37" class="headerlink" title="题解"></a>题解</h2><h3 id="初步思路-5"><a href="#初步思路-5" class="headerlink" title="初步思路"></a>初步思路</h3><p>维护一个排序的列表，每次添加数字时二分查找到应该插入的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(list.isEmpty())&#123;</span><br><span class="line">            list.add(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(list.get(middle)&lt;=num)&#123;</span><br><span class="line">                left=middle+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right=middle-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(left,num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(list.size() / <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="type">double</span>) list.get(list.size() / <span class="number">2</span>) + (<span class="type">double</span>) list.get(list.size() / <span class="number">2</span> - <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是直接超时了。。。毕竟是道困难题，所以还需要寻找更好的方法</p><h3 id="大-小顶堆计算中位数"><a href="#大-小顶堆计算中位数" class="headerlink" title="大&#x2F;小顶堆计算中位数"></a>大&#x2F;小顶堆计算中位数</h3><p>由于中位数只和最中间的两个数字或一个数有关，和其他的数字排序都无关，因此可以用两个堆来实现。</p><p>按数组下标从左到右，分成两个堆。</p><p>左边是大顶堆A，堆顶朝右，存放这些数中较小的一半，堆顶是这其中最大的数；</p><p>右边是小顶堆B，堆顶朝左，存放这些数中较大的一半，堆顶是这其中最小的数。</p><p>最终中位数只靠A和B的堆顶元素就可以计算得出。</p><p>Java中关于堆结构有一个实现类：PriorityQueue</p><p>这本质上是个优先队列，内部用数组的形式维护了一个小顶堆，它不像一般队列满足先进先出原则，而是每次将元素出队时，都是这其中最小的数（可以通过自定义比较器改为最大的）。</p><p><a href="https://www.cnblogs.com/Elliott-Su-Faith-change-our-life/p/7472265.html">Java中PriorityQueue详解 - geekerin - 博客园 (cnblogs.com)</a></p><p><a href="https://baijiahao.baidu.com/s?id=1665383380422326763&wfr=spider&for=pc">刷算法不知道PriorityQueue?看了这篇文章才知道他有多实用 (baidu.com)</a></p><p><strong>addNum函数：</strong></p><blockquote><p>1、当<code>A.size()==B.size()</code>，向A中添加一个元素。实现方法：将新元素插入B，再插入A</p><p>2、当<code>A.size()!=B.size()</code>，向B中添加一个元素。实现方法：将新元素插入A，再插入B</p><p>（插入的同时需要将该堆继续维护成原来的大&#x2F;小顶堆）</p><p>为什么向A，B中添加元素的时候不直接插入，而需要先插入另一个堆呢？</p><p>因为我们需要时刻保证A中的时较小的那些数，B中是较大的那些数（即A中所有数都要小于B中的），</p><p>例如要向A中添加一个元素时，我们不知道这个元素应该是属于A还是B，那么就应该先插入B，然后将B顶的数(即B中最小的数)插入<strong>A</strong></p></blockquote><p><strong>findMedian函数</strong></p><blockquote><p>1、当<code>A.size()==B.size()</code>，中位数等于(A顶+B顶)&#x2F;2</p><p>2、当<code>A.size()!=B.size()</code>，中位数等于A顶</p></blockquote><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; A, B;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        A = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; (y - x));<span class="comment">//大顶堆，保存较小的一半</span></span><br><span class="line">        B = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();<span class="comment">//小顶堆，保存较大的一半</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A.size() == B.size()) &#123;</span><br><span class="line">            B.add(num);</span><br><span class="line">            A.add(B.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A.add(num);</span><br><span class="line">            B.add(A.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.size() == B.size() ? (A.peek() + B.peek()) / <span class="number">2.0</span> : A.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：68 ms, 在所有 Java 提交中击败了74.95%的用户</p><p>内存消耗：49.3 MB, 在所有 Java 提交中击败了87.07%的用户</p><hr><h1 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42 连续子数组的最大和"></a>42 连续子数组的最大和</h1><h2 id="题目-39"><a href="#题目-39" class="headerlink" title="题目"></a>题目</h2><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>1 &lt;= arr.length &lt;= 10^5</code><br><code>-100 &lt;= arr[i] &lt;= 100</code></p><h2 id="题解-38"><a href="#题解-38" class="headerlink" title="题解"></a>题解</h2><p>定义动态规划数组dp,dp[i]表示以nums[i]为<strong>结尾</strong>的连续子数组的最大和，即无论nums[i]是正是负，dp[i]必须包含nums[i];</p><p>因为题目要求是连续子数组，如果不包含nums[i]，就不能保证递推到dp[i+1]的正确性。</p><p>状态转移方程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">若dp[i-<span class="number">1</span>]&gt;<span class="number">0</span>,则dp[i]=dp[i-<span class="number">1</span>]+nums[i]</span><br><span class="line">若dp[i-<span class="number">1</span>]&lt;=<span class="number">0</span>,则dp[i]=nums[i]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : dp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; max)&#123;</span><br><span class="line">                max = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了98.17%的用户</p><p>内存消耗：44.8 MB, 在所有 Java 提交中击败了67.68%的用户</p><hr><h1 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45 把数组排成最小的数"></a>45 把数组排成最小的数</h1><h2 id="题目-40"><a href="#题目-40" class="headerlink" title="题目"></a>题目</h2><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure><p>提示:</p><p><code>0 &lt; nums.length &lt;= 100</code></p><p>说明:</p><p><code>输出结果可能非常大，所以你需要返回一个字符串而不是整数</code><br><code>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</code></p><h2 id="题解-39"><a href="#题解-39" class="headerlink" title="题解"></a>题解</h2><p>这道题本质是排序，但是排序的规则和正常的规则不太一样；</p><p>对于数组nums中的任意两个数x，y：</p><p><code>若x+y&gt;y+x，则x&quot;大于&quot;y</code></p><p><code>若x+y&lt;y+x，则x&quot;小于&quot;y</code></p><p>套用以上规则，对nums进行排序</p><h3 id="使用内置排序"><a href="#使用内置排序" class="headerlink" title="使用内置排序"></a>使用内置排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">        <span class="comment">//把数字都转化成字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        <span class="comment">//使用内置排序，传入两个参数，第一个是string数组，第二个是lambda表达式</span></span><br><span class="line">        <span class="comment">//compareto函数是按字典顺序比较两个字符串</span></span><br><span class="line">        Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：5 ms, 在所有 Java 提交中击败了74.27%的用户</p><p>内存消耗：37.3 MB, 在所有 Java 提交中击败了99.11%的用户</p><h3 id="手动实现快排"><a href="#手动实现快排" class="headerlink" title="手动实现快排"></a>手动实现快排</h3><p>快速排序基本思路：</p><p>1、选定数组中任意一个数作为pivot</p><p>2、将大于pivot的数字放在pivot的右边</p><p>3、将小于pivot的数组放在pivot的左边</p><p>4、分别对左右子序列重复前三部操作</p><p><strong>基本的快排：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> getPivotIndex(nums, left, right);</span><br><span class="line">            <span class="comment">//在新区间递归</span></span><br><span class="line">            quickSort(nums, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对nums进行pivot分区，返回pivot的下标，以便quickSort更新递归区间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPivotIndex</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//随机选取pivot</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        <span class="comment">//交换到left的位置，方便后面填坑法进行调换</span></span><br><span class="line">        swap(nums, left, index);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//填坑法</span></span><br><span class="line">            <span class="comment">//因为nums[left]的值已经暂存在pivot中，因此可以直接覆盖，后面同理</span></span><br><span class="line">            <span class="keyword">while</span> (nums[right] &gt;= pivot &amp;&amp; left &lt; right) right--;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            <span class="keyword">while</span> (nums[left] &lt;= pivot &amp;&amp; left &lt; right) left++;</span><br><span class="line">            nums[right] = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个快排模板的交换逻辑修改一下就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">        <span class="comment">//把数字都转化成字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        quickSort(strs, <span class="number">0</span>, strs.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            stringBuilder.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(String[] strs, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> getPivotIndex(strs, left, right);</span><br><span class="line">            quickSort(strs, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            quickSort(strs, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPivotIndex</span><span class="params">(String[] strs, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        swap(strs, left, index);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> Integer.valueOf(strs[left]);</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((strs[right] + pivot).compareTo(pivot + strs[right]) &gt;= <span class="number">0</span> &amp;&amp; left &lt; right) right--;</span><br><span class="line">            strs[left] = strs[right];</span><br><span class="line">            <span class="keyword">while</span> ((pivot + strs[left]).compareTo(strs[left] + pivot) &gt;= <span class="number">0</span> &amp;&amp; left &lt; right) left++;</span><br><span class="line">            strs[right] = strs[left];</span><br><span class="line">        &#125;</span><br><span class="line">        strs[left] = String.valueOf(pivot);</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(String[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是没有进行优化。。。最后执行效果就不看了（太铸币</p><p>看一下大佬的优化代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        quickSort(strs, <span class="number">0</span>, strs.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(String[] strs, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> strs[i];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span> ((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j) i++;</span><br><span class="line">            tmp = strs[i];</span><br><span class="line">            strs[i] = strs[j];</span><br><span class="line">            strs[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        strs[i] = strs[l];</span><br><span class="line">        strs[l] = tmp;</span><br><span class="line">        quickSort(strs, l, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(strs, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：4 ms, 在所有 Java 提交中击败了98.15%的用户</p><p>内存消耗：37.2 MB, 在所有 Java 提交中击败了99.44%的用户</p><hr><h1 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46 把数字翻译成字符串"></a>46 把数字翻译成字符串</h1><h2 id="题目-41"><a href="#题目-41" class="headerlink" title="题目"></a>题目</h2><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>0 &lt;= num &lt; 231</code></p><h2 id="题解-40"><a href="#题解-40" class="headerlink" title="题解"></a>题解</h2><h3 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">100</span> &lt; <span class="number">26</span> &amp;&amp; num % <span class="number">100</span> &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> translateNum(num / <span class="number">100</span>) + translateNum(num / <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> translateNum(num / <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：35.3 MB, 在所有 Java 提交中击败了34.87%的用户</p><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><blockquote><p>这题和经典的青蛙跳台阶问题类似（青蛙跳台阶，一次可以跳1级，也可以跳2级，问n级台阶多少种跳法)</p><p><code>f(n)=f(n-1)+f(n-2)</code></p><p>所以动态规划，只需要知道dp[0]和dp[1]，然后递推就好了。</p><p>区别在于能不能跳两下需要判断一下。</p></blockquote><p>创建dp数组，dp[i]表示在下标为i处时有多少种翻译方法，用n表示下标为i和i-1构成的两位数；</p><p>状态转移方程：</p><p><code>dp[i]=dp[i-2]+dp[i-1] (n&gt;9&amp;&amp;n&lt;26)</code></p><p><code>dp[i]=dp[i-1] (n&lt;=9&amp;&amp;n&gt;=26)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = String.valueOf(num).toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> chars.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//dp[1]也需要特判一下</span></span><br><span class="line">        dp[<span class="number">1</span>] = (chars[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (chars[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) &lt; <span class="number">26</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//n表示的是i-1和i构成的两位数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (chars[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (chars[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="comment">//n&gt;9&amp;&amp;n&lt;26则说明这个两位数整体可以翻译成字符串</span></span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">9</span> &amp;&amp; n &lt; <span class="number">26</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则说明这个两位数整体不能翻译成字符串</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：35.3 MB, 在所有 Java 提交中击败了45.25%的用户</p><h3 id="动态规划优化-滚动数组"><a href="#动态规划优化-滚动数组" class="headerlink" title="动态规划优化(滚动数组)"></a>动态规划优化(滚动数组)</h3><p>在上述动态规划中，dp[i]只与dp[i-1]和dp[i-2]有关。</p><p>因此只用三个变量，不断更新它们的指，就能得到最终的dp[i]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = String.valueOf(num).toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> chars.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = (chars[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (chars[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) &lt; <span class="number">26</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = dp[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (chars[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (chars[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">9</span> &amp;&amp; n &lt; <span class="number">26</span>) &#123;</span><br><span class="line">                dp[<span class="number">2</span>] = dp[<span class="number">1</span>] + dp[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[<span class="number">2</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：35 MB, 在所有 Java 提交中击败了91.38%的用户</p><hr><h1 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47 礼物的最大价值"></a>47 礼物的最大价值</h1><h2 id="题目-42"><a href="#题目-42" class="headerlink" title="题目"></a>题目</h2><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>0 &lt; grid.length &lt;= 200</code><br><code>0 &lt; grid[0].length &lt;= 200</code></p><h2 id="题解-41"><a href="#题解-41" class="headerlink" title="题解"></a>题解</h2><h3 id="初步思路-6"><a href="#初步思路-6" class="headerlink" title="初步思路"></a>初步思路</h3><p>定义动态规划数组dp,<code>dp[i][j]</code>表示在第i行j列的礼物的最大价值</p><p>状态转移方程：</p><p><code>dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1])+grid[i][j]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> grid.length, col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//先对边界初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了98.39%的用户</p><p>内存消耗：41.2 MB, 在所有 Java 提交中击败了28.86%的用户</p><h3 id="优化-4"><a href="#优化-4" class="headerlink" title="优化"></a>优化</h3><p>由于<code>dp[i][j]</code>这个位置的值只与<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>有关；</p><p>因此我们可以将原矩阵作为dp矩阵，原地修改grid矩阵</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> grid.length, col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">                grid[i][j] += Math.max(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了98.39%的用户</p><p>内存消耗：41 MB, 在所有 Java 提交中击败了63.65%的用户</p><hr><h1 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48 最长不含重复字符的子字符串"></a>48 最长不含重复字符的子字符串</h1><h2 id="题目-43"><a href="#题目-43" class="headerlink" title="题目"></a>题目</h2><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h2 id="题解-42"><a href="#题解-42" class="headerlink" title="题解"></a>题解</h2><h3 id="滑动窗口-也算是动态规划吧"><a href="#滑动窗口-也算是动态规划吧" class="headerlink" title="滑动窗口(也算是动态规划吧)"></a>滑动窗口(也算是动态规划吧)</h3><p>滑动窗口的基本思想：</p><blockquote><p>我们维护一个窗口，<br>每当当前数字在之前遍历时出现过，就更新 <strong>窗口左边界</strong><br>每遍历一个字符，就计算一次 当前结果</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                <span class="comment">//防止左边界向左移动</span></span><br><span class="line">                left = Math.max(map.get(c), left);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, i);</span><br><span class="line">            <span class="comment">//更新result</span></span><br><span class="line">            result = Math.max(result, i - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：4 ms, 在所有 Java 提交中击败了93.80%的用户</p><p>内存消耗：38.2 MB, 在所有 Java 提交中击败了86.78%的用户</p><hr><h1 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50 第一个只出现一次的字符"></a>50 第一个只出现一次的字符</h1><h2 id="题目-44"><a href="#题目-44" class="headerlink" title="题目"></a>题目</h2><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;abaccdeff&quot;</span></span><br><span class="line">返回 <span class="string">&quot;b&quot;</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;&quot;</span> </span><br><span class="line">返回 <span class="string">&quot; &quot;</span></span><br></pre></td></tr></table></figure><h2 id="题解-43"><a href="#题解-43" class="headerlink" title="题解"></a>题解</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>这个题其实挺简单，也不需要什么花里胡哨的写法，只需要遍历并用HashMap存一下结果就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (map.get(c) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：26 ms, 在所有 Java 提交中击败了48.09%的用户</p><p>内存消耗：38.6 MB, 在所有 Java 提交中击败了65.39%的用户</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>也可以用LinkedHashMap，它是一种有顺序的HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(c) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行用时：26 ms, 在所有 Java 提交中击败了48.09%的用户</p><p>内存消耗：38.7 MB, 在所有 Java 提交中击败了61.29%的用户</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>也可以用纯数组的形式，可以节省一点时间消耗</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//用intl数组可以节省一点空间</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : chars) &#123;</span><br><span class="line">            arr[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[c - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：3 ms, 在所有 Java 提交中击败了99.37%的用户</p><p>内存消耗：38.7 MB, 在所有 Java 提交中击败了57.02%的用户</p><hr><h1 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52 两个链表的第一个公共节点"></a>52 两个链表的第一个公共节点</h1><h2 id="题目-45"><a href="#题目-45" class="headerlink" title="题目"></a>题目</h2><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/%E9%A2%98%E8%AE%B0%E5%BD%95/160_statement.png" alt="img"></a></p><p>在节点 c1 开始相交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/%E9%A2%98%E8%AE%B0%E5%BD%95/160_statement.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/%E9%A2%98%E8%AE%B0%E5%BD%95/160_example_2.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Reference of the node with value = 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/%E9%A2%98%E8%AE%B0%E5%BD%95/160_example_3.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果两个链表没有交点，返回 null.</span><br><span class="line">在返回结果后，两个链表仍须保持原有的结构。</span><br><span class="line">可假定整个链表结构中没有循环。</span><br><span class="line">程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</span><br></pre></td></tr></table></figure><h2 id="题解-44"><a href="#题解-44" class="headerlink" title="题解"></a>题解</h2><h3 id="双指针-3"><a href="#双指针-3" class="headerlink" title="双指针"></a>双指针</h3><p>定义两个指针p1和p2</p><p>p1先遍历headA，如果遍历到尾部，再从headB开始遍历；</p><p>p2先遍历headB，如果遍历到尾部，再从headA开始遍历；</p><p>当p1和p2相等时，返回p1.</p><blockquote><p>为什么要这样操作呢？</p><p>假设headA链表节点数量为a个，headB链表节点数量为b个，两个链表的公共节点数量为c个。设公共节点为node，则在headA到node之间，共有a-c个节点，在headB到node之间，共有b-c个节点。</p><p>p1先遍历headA，再从headB开始遍历，当到达node位置时，共走的步数为<code>a+b-c</code></p><p>p2先遍历headB，再从headA开始遍历，当到达node位置时，共走的步数为<code>b+a-c</code></p><p>此时p1和p2走的步数相同，必定重合，重合的位置就是第一个公共节点，因此返回p1即可；</p><p>同时，若p1和p2没有公共节点，则p1和p2重合的情况就是p1和p2都指向两个链表的尾部，即null。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            p1 = p1 == <span class="literal">null</span> ? headB : p1.next;</span><br><span class="line">            p2 = p2 == <span class="literal">null</span> ? headA : p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.1 MB, 在所有 Java 提交中击败了74.72%的用户</p><hr><h1 id="53-I-在排序数组中查找数字"><a href="#53-I-在排序数组中查找数字" class="headerlink" title="53 I 在排序数组中查找数字"></a>53 I 在排序数组中查找数字</h1><h2 id="题目-46"><a href="#题目-46" class="headerlink" title="题目"></a>题目</h2><p>统计一个数字在排序数组中出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">6</span></span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="题解-45"><a href="#题解-45" class="headerlink" title="题解"></a>题解</h2><h3 id="简单遍历"><a href="#简单遍历" class="headerlink" title="简单遍历"></a>简单遍历</h3><p>没什么好说的，遍历，每次++就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == target)</span><br><span class="line">                n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了26.78%的用户</p><p>内存消耗：41.4 MB, 在所有 Java 提交中击败了28.61%的用户</p><p>时间O(n)</p><p>空间O(1)</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>直接简单遍历的话，时间复杂度有些高；</p><p>关键在于如何找到这个数字在数组中出现的下标和结束的下标，所以这题实质上是一个二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//找出target的右边界和target-1的右边界</span></span><br><span class="line">        <span class="keyword">return</span> finder(nums, target) - finder(nums, target - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//finder函数实际上找的是右边界</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">finder</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//由于我们要找的是右边界，所以等于的情况也需要把区间变成[middle+1,right]</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &lt;= target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当while循环结束时，left=right+1，所以left才是右边的边界</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：41.4 MB, 在所有 Java 提交中击败了41.21%的用户</p><p>时间O(logn)</p><p>空间O(1)</p><p>二分查找的细节推荐博客：<a href="https://www.overme.cn/post/1608706561">二分查找的细节总结 - 鱼跃此时海 (overme.cn)</a></p><hr><h1 id="53-II-0-n-1中缺失的数字"><a href="#53-II-0-n-1中缺失的数字" class="headerlink" title="53 II 0~n-1中缺失的数字"></a>53 II 0~n-1中缺失的数字</h1><h2 id="题目-47"><a href="#题目-47" class="headerlink" title="题目"></a>题目</h2><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">输出: <span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="题解-46"><a href="#题解-46" class="headerlink" title="题解"></a>题解</h2><h3 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h3><p>有了<code>53 I</code>的经验后，这题直接采用二分查找的方法来做。</p><p>由于该数组是从0递增的，如果没有缺少，那么数组的值与对应下标都是相等的；</p><p>现在少了一个数字i，那么从下标i开始，到数组末尾的这些数都比下标大1；</p><p>所以二分法查找，只需要查找出这个边界下标就可以了；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> finder(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">finder</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//如果nums[middle]与midlle相等，就说明需要往右边找</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] == middle)</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果不相等，就往左边找</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关键：要的是右边界</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.8 MB, 在所有 Java 提交中击败了73.56%的用户</p><p>时间O(logn)</p><p>空间O(1)</p><hr><h1 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54 二叉搜索树的第k大节点"></a>54 二叉搜索树的第k大节点</h1><h2 id="题目-48"><a href="#题目-48" class="headerlink" title="题目"></a>题目</h2><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>限制：</p><p><code>1 ≤ k ≤ 二叉搜索树元素个数</code></p><h2 id="题解-47"><a href="#题解-47" class="headerlink" title="题解"></a>题解</h2><h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res.get(res.size() - k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了35.01%的用户</p><p>内存消耗：38.6 MB, 在所有 Java 提交中击败了24.77%的用户</p><h3 id="反向中序遍历"><a href="#反向中序遍历" class="headerlink" title="反向中序遍历"></a>反向中序遍历</h3><blockquote><p>二叉搜索树的中序遍历为递增序列，则与中序遍历相反的遍历方式就是递减序列</p></blockquote><p>可以剩下List的空间和时间消耗</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k, res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        <span class="comment">//用k计数</span></span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) res = root.val;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.3 MB, 在所有 Java 提交中击败了45.67%的用户</p><hr><h1 id="55-I-二叉树的深度"><a href="#55-I-二叉树的深度" class="headerlink" title="55 I 二叉树的深度"></a>55 I 二叉树的深度</h1><h2 id="题目-49"><a href="#题目-49" class="headerlink" title="题目"></a>题目</h2><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例如：</strong></p><p>给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回它的最大深度 3 。</p><p><strong>提示：</strong></p><p><code>节点总数 &lt;= 10000</code></p><h2 id="题解-48"><a href="#题解-48" class="headerlink" title="题解"></a>题解</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>每一层的最大深度为左右子节点的最大深度中较大的那个+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.1 MB, 在所有 Java 提交中击败了84.54%的用户</p><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>每遍历完一层给res++</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; temp;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (TreeNode node : queue) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) temp.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) temp.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            queue = temp;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了8.33%的用户</p><p>内存消耗：38.1 MB, 在所有 Java 提交中击败了88.87%的用户</p><h3 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h3><p>从底至顶计算深度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(node.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.3 MB, 在所有 Java 提交中击败了59.27%的用户</p><hr><h1 id="55-II-平衡二叉树"><a href="#55-II-平衡二叉树" class="headerlink" title="55 II 平衡二叉树"></a>55 II 平衡二叉树</h1><h2 id="题目-50"><a href="#题目-50" class="headerlink" title="题目"></a>题目</h2><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><p>给定二叉树 [3,9,20,null,null,15,7]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回 true 。</p><p><strong>示例 2:</strong></p><p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>返回 false 。</p><p><strong>限制：</strong></p><p><code>0 &lt;= 树的结点个数 &lt;= 10000</code></p><h2 id="题解-49"><a href="#题解-49" class="headerlink" title="题解"></a>题解</h2><h3 id="先序遍历-判断深度"><a href="#先序遍历-判断深度" class="headerlink" title="先序遍历 + 判断深度"></a>先序遍历 + 判断深度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(depth(root.left) - depth(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(depth(node.left), depth(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了83.59%的用户</p><p>内存消耗：38.5 MB, 在所有 Java 提交中击败了41.70%的用户</p><h3 id="后续遍历-剪枝"><a href="#后续遍历-剪枝" class="headerlink" title="后续遍历+剪枝"></a>后续遍历+剪枝</h3><p>对二叉树做后续遍历，从底至顶返回子树的深度，若判定字数不是平衡树则进行剪枝，即直接返回。</p><blockquote><p>后续遍历的特点是从底至顶，由于其是从底至顶，因此在遇到不符合的情况时，可以方便剪枝，提高效率</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recur(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">recur</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="comment">//当node==null，说明越过根节点，返回高度为0</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算左子树深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> recur(node.left);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算右子树深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> recur(node.right);</span><br><span class="line">        <span class="keyword">if</span> (right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &lt;= <span class="number">1</span> ? Math.max(left, right) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.4 MB, 在所有 Java 提交中击败了56.75%的用户</p><hr><h1 id="56-I-数组中数字出现的次数"><a href="#56-I-数组中数字出现的次数" class="headerlink" title="56 I 数组中数字出现的次数"></a>56 I 数组中数字出现的次数</h1><h2 id="题目-51"><a href="#题目-51" class="headerlink" title="题目"></a>题目</h2><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumbers(<span class="type">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>2 &lt;= nums.length &lt;= 10000</code></p><h2 id="题解-50"><a href="#题解-50" class="headerlink" title="题解"></a>题解</h2><p>题目要求时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>，因此排除暴力和哈希</p><blockquote><p>若题目改为，在一个整型数组<code>nums</code>中除了一个数字<code>x</code>外，其他数字出现了两次，找出<code>x</code></p></blockquote><p>异或运算：异或运算有个重要的性质，两个相同数字异或为 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)  <span class="comment">// 1. 遍历 nums 执行异或运算</span></span><br><span class="line">        x ^= num;</span><br><span class="line">    <span class="keyword">return</span> x;            <span class="comment">// 2. 返回出现一次的数字 x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题的难点在于有两个只出现一次的数字，因此无法直接通过上面的异或运算得到这两个数字。</p><p>可以将<code>nums</code>拆分成分别带有两个未知数x和y的数组。</p><p>拆分的关键在于两个数组必须分别包含x和y，而数组中其他的元素只要保证两两不分开就行。</p><p>算法思路：</p><p>1、先对所有数字进行一次异或，得到的结果就是x和y的异或值</p><p>2、根据异或运算定义，若整数x^y的某二进制位为1.则x和y的这个二进制位一定不同。可以通过这个特性将nums划分为两个数组</p><p>3、每个组内进行异或操作，得到两个数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumbers(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            result ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化辅助变量div=1，通过与运算从右向左循环判断</span></span><br><span class="line">        <span class="comment">//直到获取到x^y的第首位1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">div</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((result &amp; div) == <span class="number">0</span>)</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">//若num&amp;div!=则与x一组</span></span><br><span class="line">            <span class="keyword">if</span> ((num &amp; div) != <span class="number">0</span>) &#123;</span><br><span class="line">                x ^= num;</span><br><span class="line">            <span class="comment">//若num&amp;div==0则与y一组</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                y ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：40.1 MB, 在所有 Java 提交中击败了41.50%的用户</p><hr><h1 id="56-II-数组中数字出现的次数"><a href="#56-II-数组中数字出现的次数" class="headerlink" title="56 II 数组中数字出现的次数"></a>56 II 数组中数字出现的次数</h1><h2 id="题目-52"><a href="#题目-52" class="headerlink" title="题目"></a>题目</h2><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,26,30,31,47,60], target = 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>1 &lt;= nums.length &lt;= 10^5</code><br><code>1 &lt;= nums[i] &lt;= 10^6</code></p><h2 id="题解-51"><a href="#题解-51" class="headerlink" title="题解"></a>题解</h2><p>先看一下我自己一开始的写法，本来想创建数组用空间换时间的，结果时间空间都是铸币（</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[Math.max(nums[nums.length - <span class="number">1</span>]+<span class="number">1</span>,target)];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            map[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[target - num] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;num, target - num&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：5 ms, 在所有 Java 提交中击败了23.31%的用户</p><p>内存消耗：59.2 MB, 在所有 Java 提交中击败了5.02%的用户</p><h3 id="双指针-4"><a href="#双指针-4" class="headerlink" title="双指针"></a>双指针</h3><p>这题有个关键条件是排序数组，<del>一开始没看见</del></p><p>定义两个指针，p1指向数组头，p2指向数组尾</p><ol><li>计算<code>s=nums[p1]+nums[p2]</code></li><li>如果<code>s&gt;target</code>，则<code>p2--</code></li><li>如果<code>s&lt;target</code>，则<code>p1++</code></li><li>如果<code>s=target</code>，则返回数组<code>[nums[p1],nums[p2]]</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>, p2 = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; p2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[p1] + nums[p2] &gt; target) &#123;</span><br><span class="line">                p2--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[p1] + nums[p2] &lt; target) &#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[p1], nums[p2]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了86.49%的用户</p><p>内存消耗：55.1 MB, 在所有 Java 提交中击败了80.69%的用户</p><hr><h1 id="57-I-和为s的两个数字"><a href="#57-I-和为s的两个数字" class="headerlink" title="57 I 和为s的两个数字"></a>57 I 和为s的两个数字</h1><h2 id="题目-53"><a href="#题目-53" class="headerlink" title="题目"></a>题目</h2><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,26,30,31,47,60], target = 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>1 &lt;= nums.length &lt;= 10^5</code><br><code>1 &lt;= nums[i] &lt;= 10^6</code></p><h2 id="题解-52"><a href="#题解-52" class="headerlink" title="题解"></a>题解</h2><p>先看一下我自己一开始的写法，本来想创建数组用空间换时间的，结果时间空间都是铸币（</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[Math.max(nums[nums.length - <span class="number">1</span>]+<span class="number">1</span>,target)];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            map[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[target - num] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;num, target - num&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：5 ms, 在所有 Java 提交中击败了23.31%的用户</p><p>内存消耗：59.2 MB, 在所有 Java 提交中击败了5.02%的用户</p><h3 id="双指针-5"><a href="#双指针-5" class="headerlink" title="双指针"></a>双指针</h3><p>这题有个关键条件是排序数组，<del>一开始没看见</del></p><p>定义两个指针，p1指向数组头，p2指向数组尾</p><ol><li>计算<code>s=nums[p1]+nums[p2]</code></li><li>如果<code>s&gt;target</code>，则<code>p2--</code></li><li>如果<code>s&lt;target</code>，则<code>p1++</code></li><li>如果<code>s=target</code>，则返回数组<code>[nums[p1],nums[p2]]</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>, p2 = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; p2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[p1] + nums[p2] &gt; target) &#123;</span><br><span class="line">                p2--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[p1] + nums[p2] &lt; target) &#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[p1], nums[p2]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了86.49%的用户</p><p>内存消耗：55.1 MB, 在所有 Java 提交中击败了80.69%的用户</p><hr><h1 id="57-II-和为s的连续正数序列"><a href="#57-II-和为s的连续正数序列" class="headerlink" title="57 II 和为s的连续正数序列"></a>57 II 和为s的连续正数序列</h1><h2 id="题目-54"><a href="#题目-54" class="headerlink" title="题目"></a>题目</h2><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] findContinuousSequence(<span class="type">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>1 &lt;= target &lt;= 10^5</code></p><h2 id="题解-53"><a href="#题解-53" class="headerlink" title="题解"></a>题解</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>左闭右闭(其实感觉左闭右开应该更符合代码习惯)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] findContinuousSequence(<span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= target / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                sum += right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                sum -= left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">                    arr[i - left] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(arr);</span><br><span class="line">                sum -= left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了97.53%的用户</p><p>内存消耗：36.3 MB, 在所有 Java 提交中击败了77.89%的用户</p><blockquote><p>参考：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shi-yao-shi-hua-dong-chuang-kou-yi-ji-ru-he-yong-h/">什么是滑动窗口，以及如何用滑动窗口解这道题（C++&#x2F;Java&#x2F;Python） - 和为s的连续正数序列 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><hr><h1 id="58-I-翻转单词顺序"><a href="#58-I-翻转单词顺序" class="headerlink" title="58 I 翻转单词顺序"></a>58 I 翻转单词顺序</h1><h2 id="题目-55"><a href="#题目-55" class="headerlink" title="题目"></a>题目</h2><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><h2 id="题解-54"><a href="#题解-54" class="headerlink" title="题解"></a>题解</h2><h3 id="分隔-倒序"><a href="#分隔-倒序" class="headerlink" title="分隔+倒序"></a>分隔+倒序</h3><ol><li><p>用String.trim()删除首尾空格</p></li><li><p>分割字符串</p><p>以空格为分割符完成字符串分割后，若两单词间有 x &gt; 1 个空格，则在单词列表 strs 中，此两单词间会多出 x - 1 个 “空单词” （即 “” ）。解决方法：倒序遍历单词列表，并将单词逐个添加至 StringBuilder ，遇到空单词时跳过。</p></li><li><p>倒叙遍历，拼接至StringBuilder</p></li><li><p>转化为字符串并返回</p></li></ol><p>由于这种方法用到了几个内置api，所以面试不建议用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String[] strs = s.trim().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> strs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i].equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            stringBuilder.append(strs[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString().trim();<span class="comment">//q</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了85.37%的用户</p><p>内存消耗：37.9 MB, 在所有 Java 提交中击败了94.89%的用户</p><h3 id="双指针-6"><a href="#双指针-6" class="headerlink" title="双指针"></a>双指针</h3><p>倒序遍历字符串 s ，记录单词左右索引边界 p1 , p2 ；<br>每确定一个单词的边界，则将其添加至 StringBuilder ；<br>最终，返回 stringBuilder.toString() 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, p2 = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> &amp;&amp; s.charAt(p1) != <span class="string">&#x27; &#x27;</span>) p1--; <span class="comment">//找到空格</span></span><br><span class="line">            stringBuilder.append(s.substring(p1 + <span class="number">1</span>, p2 + <span class="number">1</span>) + <span class="string">&quot; &quot;</span>); <span class="comment">//拼接单词</span></span><br><span class="line">            <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> &amp;&amp; s.charAt(p1) == <span class="string">&#x27; &#x27;</span>) p1--; <span class="comment">//跳过空格</span></span><br><span class="line">            p2 = p1; <span class="comment">//p2指向单词末尾</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：3 ms, 在所有 Java 提交中击败了61.65%的用户</p><p>内存消耗：37.8 MB, 在所有 Java 提交中击败了98.33%的用户</p><hr><h1 id="58-II-左旋转字符串"><a href="#58-II-左旋转字符串" class="headerlink" title="58 II 左旋转字符串"></a>58 II 左旋转字符串</h1><h2 id="题目-56"><a href="#题目-56" class="headerlink" title="题目"></a>题目</h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解-55"><a href="#题解-55" class="headerlink" title="题解"></a>题解</h2><p>这题太简单，方法也很多，主要是按照要求选取不同方法就行。</p><h3 id="方法一：利用substring方法"><a href="#方法一：利用substring方法" class="headerlink" title="方法一：利用substring方法"></a>方法一：利用substring方法</h3><p>把字符串分割成两部分：前n个和剩下的</p><p>然后重新拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> s.substring(<span class="number">0</span>, n);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.substring(n, s.length());</span><br><span class="line">        <span class="keyword">return</span> s2 + s1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：37.8 MB, 在所有 Java 提交中击败了97.00%的用户</p><h3 id="方法二：用StringBuilder遍历拼接"><a href="#方法二：用StringBuilder遍历拼接" class="headerlink" title="方法二：用StringBuilder遍历拼接"></a>方法二：用StringBuilder遍历拼接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; s.length(); i++) &#123;</span><br><span class="line">            stringBuilder.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            stringBuilder.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：4 ms, 在所有 Java 提交中击败了34.32%的用户</p><p>内存消耗：38.4 MB, 在所有 Java 提交中击败了17.93%的用户</p><hr><h1 id="59-I-滑动窗口的最大值"><a href="#59-I-滑动窗口的最大值" class="headerlink" title="59 I 滑动窗口的最大值"></a>59 I 滑动窗口的最大值</h1><h2 id="题目-57"><a href="#题目-57" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line"></span><br><span class="line">---------------               -----</span><br><span class="line"></span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><h2 id="题解-56"><a href="#题解-56" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>每次滑动窗口更新就遍历一遍滑动窗口里面的数字，找到最大的那个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length - k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; k + i; j++) &#123;</span><br><span class="line">                max = nums[j] &gt; max ? nums[j] : max;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：27 ms, 在所有 Java 提交中击败了18.53%的用户</p><p>内存消耗：46.4 MB, 在所有 Java 提交中击败了76.30%的用户</p><h3 id="大根堆（优先队列）"><a href="#大根堆（优先队列）" class="headerlink" title="大根堆（优先队列）"></a>大根堆（优先队列）</h3><blockquote><p>对优先队列做任何操作后，队首的元素始终能保持时最大的。</p></blockquote><p>先把前k个数字加入优先队列。</p><p>当滑动窗口向右移动时，添加进一个数字，此时队首的元素就是最大的。</p><p>但是不能保证这个队首的最大的元素在滑动窗口的范围内，</p><p>因此需要判断一下，如果队首的元素不在滑动窗口范围内，就出队，知道满足为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//优先队列中存储二元数组(num,index)</span></span><br><span class="line">        <span class="comment">//index表示num的下标，用于判断当前优先队列中的最大值在不在这个滑动窗口内</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">int</span>[]&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] pair1, <span class="type">int</span>[] pair2)</span> &#123;</span><br><span class="line">                <span class="comment">//如果；num1!=num2，返回num2-num1</span></span><br><span class="line">                <span class="comment">//否则返回index2-index1</span></span><br><span class="line">                <span class="keyword">return</span> pair1[<span class="number">0</span>] != pair2[<span class="number">0</span>] ? pair2[<span class="number">0</span>] - pair1[<span class="number">0</span>] : pair2[<span class="number">1</span>] - pair1[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = pq.peek()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//pq添加进一个元素，表示滑动窗口右边界向右移动一格</span></span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[i], i&#125;);</span><br><span class="line">            <span class="comment">//此时逻辑上左边界也向右移动一格</span></span><br><span class="line">            <span class="comment">//则左边界为i-k+1，如果pq顶的元素在这个边界之外，则出队</span></span><br><span class="line">            <span class="keyword">while</span> (pq.peek()[<span class="number">1</span>] &lt;= i - k) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            res[i - k + <span class="number">1</span>] = pq.peek()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：11 ms, 在所有 Java 提交中击败了83.53%的用户</p><p>内存消耗：47.1 MB, 在所有 Java 提交中击败了54.73%的用户</p><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><blockquote><p>参考：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution/dong-hua-yan-shi-dan-diao-dui-lie-jian-z-unpy/">动画演示 单调队列 剑指 Offer 59 - I. 滑动窗口的最大值 - 滑动窗口的最大值 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 窗口个数</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组中元素，right表示滑动窗口右边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 如果队列不为空且当前考察元素大于等于队尾元素，则将队尾元素移除。</span></span><br><span class="line">            <span class="comment">// 直到，队列为空或当前考察元素小于新的队尾元素</span></span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; nums[right] &gt;= nums[queue.peekLast()]) &#123;</span><br><span class="line">                queue.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储元素下标</span></span><br><span class="line">            queue.addLast(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算窗口左侧边界</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> right - k + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 当队首元素的下标小于滑动窗口左侧边界left时</span></span><br><span class="line">            <span class="comment">// 表示队首元素已经不再滑动窗口内，因此将其从队首移除</span></span><br><span class="line">            <span class="keyword">if</span> (queue.peekFirst() &lt; left) &#123;</span><br><span class="line">                queue.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于数组下标从0开始，因此当窗口右边界right+1大于等于窗口大小k时</span></span><br><span class="line">            <span class="comment">// 意味着窗口形成。此时，队首元素就是该窗口内的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (right + <span class="number">1</span> &gt;= k) &#123;</span><br><span class="line">                res[left] = nums[queue.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：10 ms, 在所有 Java 提交中击败了90.09%的用户</p><p>内存消耗：46.4 MB, 在所有 Java 提交中击败了75.13%的用户</p><hr><h1 id="59-II-队列的最大值"><a href="#59-II-队列的最大值" class="headerlink" title="59 II 队列的最大值"></a>59 II 队列的最大值</h1><h2 id="题目-58"><a href="#题目-58" class="headerlink" title="题目"></a>题目</h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxQueue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max_value</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.max_value();</span></span><br><span class="line"><span class="comment"> * obj.push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</span><br><span class="line">1 &lt;= value &lt;= 10^5</span><br></pre></td></tr></table></figure><h2 id="题解-57"><a href="#题解-57" class="headerlink" title="题解"></a>题解</h2><p>一般来说，如果要快速从队列中找到最大值，那么可以维护一个max在插入新元素时更新最大值。</p><p>但是万一出队的操作把这个最大值取走了呢？我们就无法找到下一个最大的值了。</p><p>解决的思路是创建一个辅助队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line">    <span class="comment">//deque用来存队列</span></span><br><span class="line">    <span class="comment">//maxDeque用来存最大值队列</span></span><br><span class="line">    <span class="comment">//maxDeque中不一定包含所有队列中的值，</span></span><br><span class="line">    <span class="comment">//但其中的值一定是:最大的-&gt;第二大的-&gt;第三大的....</span></span><br><span class="line">    Deque&lt;Integer&gt; deque, maxDeque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        maxDeque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max_value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxDeque.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//maxDeque中第一个就是当前的最大值</span></span><br><span class="line">        <span class="keyword">return</span> maxDeque.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        deque.addLast(value);</span><br><span class="line">        <span class="comment">//如果maxDeque队列尾的元素比当前要插入的小，那么就将队尾的出队</span></span><br><span class="line">        <span class="keyword">while</span> (!maxDeque.isEmpty() &amp;&amp; maxDeque.peekLast() &lt; value) maxDeque.removeLast();</span><br><span class="line">        <span class="comment">//在maxDeque队尾插入</span></span><br><span class="line">        maxDeque.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deque.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> deque.peekFirst();</span><br><span class="line">        <span class="comment">//如果要出队的这个数恰巧是最大的那个，则将其从maxDeque中也出队</span></span><br><span class="line">        <span class="keyword">if</span> (temp == maxDeque.peekFirst()) maxDeque.removeFirst();</span><br><span class="line">        deque.removeFirst();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：32 ms, 在所有 Java 提交中击败了61.72%的用户</p><p>内存消耗：45.8 MB, 在所有 Java 提交中击败了92.88%的用户</p><blockquote><p>参考:<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/ru-he-jie-jue-o1-fu-za-du-de-api-she-ji-ti-by-z1m/">如何解决 O(1) 复杂度的 API 设计题 - 队列的最大值 - 力扣（LeetCode） (leetcode-cn.com)</a></p></blockquote><hr><h1 id="61-扑克牌中的顺子"><a href="#61-扑克牌中的顺子" class="headerlink" title="61 扑克牌中的顺子"></a>61 扑克牌中的顺子</h1><h2 id="题目-59"><a href="#题目-59" class="headerlink" title="题目"></a>题目</h2><p>从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>数组长度为 5 </code></p><p><code>数组的数取值为 [0, 13]</code></p><h2 id="题解-58"><a href="#题解-58" class="headerlink" title="题解"></a>题解</h2><p>分析：</p><ul><li>先对数组执行排序。</li><li>判别重复： 排序数组中的相同元素位置相邻，因此可通过遍历数组，判断 <code>nums[i] = nums[i + 1]</code> 是否成立来判重。</li><li>获取最大 &#x2F; 最小的牌： 排序后，数组末位元素 <code>nums[4]</code> 为最大牌；元素 <code>nums[joker]</code> 为最小牌，其中 <code>joker</code> 为大小王的数量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">joker</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 数组排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) joker++; <span class="comment">// 统计大小王数量</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若有重复，提前返回 false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">4</span>] - nums[joker] &lt; <span class="number">5</span>; <span class="comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62 圆圈中最后剩下的数字"></a>62 圆圈中最后剩下的数字</h1><h2 id="题目-60"><a href="#题目-60" class="headerlink" title="题目"></a>题目</h2><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 5, m = 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10, m = 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>1 &lt;= n &lt;= 10^5</code><br><code>1 &lt;= m &lt;= 10^6</code></p><h2 id="题解-59"><a href="#题解-59" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            index = (index + m - <span class="number">1</span>) % n;</span><br><span class="line">            list.remove(index);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1347 ms, 在所有 Java 提交中击败了7.02%的用户</p><p>内存消耗：40.6 MB, 在所有 Java 提交中击败了12.06%的用户</p><h3 id="数学解法"><a href="#数学解法" class="headerlink" title="数学解法"></a>数学解法</h3><blockquote><p>最后只剩下一个元素，假设这个最后存活的元素为 num, 这个元素最终的的下标一定是0 （因为最后只剩这一个元素），<br>所以如果我们可以推出上一轮次中这个num的下标，然后根据上一轮num的下标推断出上上一轮num的下标，<br>直到推断出元素个数为n的那一轮num的下标，那我们就可以根据这个下标获取到最终的元素了。推断过程如下：</p><p>首先最后一轮中num的下标一定是0， 这个是已知的。<br>那上一轮应该是有两个元素，此轮次中 num 的下标为 (0 + m)%n &#x3D; (0+3)%2 &#x3D; 1; 说明这一轮删除之前num的下标为1；<br>再上一轮应该有3个元素，此轮次中 num 的下标为 (1+3)%3 &#x3D; 1；说明这一轮某元素被删除之前num的下标为1；<br>再上一轮应该有4个元素，此轮次中 num 的下标为 (1+3)%4 &#x3D; 0；说明这一轮某元素被删除之前num的下标为0；<br>再上一轮应该有5个元素，此轮次中 num 的下标为 (0+3)%5 &#x3D; 3；说明这一轮某元素被删除之前num的下标为3；</p><p>….</p><p>因为我们要删除的序列为0到n-1, 所以求得下标其实就是求得了最终的结果。比如当n 为5的时候，num的初始下标为3，<br>所以num就是3，也就是说从0-n-1的序列中， 经过n-1轮的淘汰，3这个元素最终存活下来了，也是最终的结果。</p><p>总结一下推导公式：(此轮过后的num下标 + m) % 上轮元素个数 &#x3D; 上轮num的下标</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从2开始反推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans = (ans + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：4 ms, 在所有 Java 提交中击败了99.98%的用户</p><p>内存消耗：35.1 MB, 在所有 Java 提交中击败了83.29%的用户</p><hr><h1 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63 股票的最大利润"></a>63 股票的最大利润</h1><h2 id="题目-61"><a href="#题目-61" class="headerlink" title="题目"></a>题目</h2><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= 数组长度 &lt;= 10^5</code></p><h2 id="题解-60"><a href="#题解-60" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>如果不考虑别的因素，那么想要收益最大化，肯定是用最高价格减去最低价格。</p><p>但是实际问题需要考虑先后问题。总要先买才能卖。</p><p>大致思路：</p><p>维护一个minPrice，表示在第i天时的历史最低价格；</p><p>维护一个maxProfit，表示在第i天时的最大收益；</p><p>进行一次遍历，在遍历的过程中对minPrice和maxProfit进行实时的更新，这样就不存在一个先后问题了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minPrice</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxProfit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (price &lt; minPrice) &#123;</span><br><span class="line">                minPrice = price;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (price - minPrice &gt; maxProfit) &#123;</span><br><span class="line">                maxProfit = price - minPrice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了98.58%的用户</p><p>内存消耗：38.1 MB, 在所有 Java 提交中击败了69.63%的用户</p><h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><p>创建一个数组dp，dp[i]表示第i天卖出的最大收益；再定义一个变量cost，用于存放当前最小的成本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; /</span><br><span class="line">        <span class="comment">// 定义状态，第i天卖出的最大收益</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 初始边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> prices[<span class="number">0</span>]; <span class="comment">// 成本</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], prices[i] - cost);</span><br><span class="line">            <span class="comment">// 选择较小的成本买入</span></span><br><span class="line">            cost = Math.min(cost, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了56.72%的用户</p><p>内存消耗：38.2 MB, 在所有 Java 提交中击败了51.68%的用户</p><p>(我觉得这种dp有点蠢，其实上面的暴力就是dp优化掉数组的结果)</p><hr><h1 id="64-求1-2-…-n"><a href="#64-求1-2-…-n" class="headerlink" title="64 求1+2+…+n"></a>64 求1+2+…+n</h1><h2 id="题目-62"><a href="#题目-62" class="headerlink" title="题目"></a>题目</h2><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 3</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>1 &lt;= n &lt;= 10000</code></p><h2 id="题解-61"><a href="#题解-61" class="headerlink" title="题解"></a>题解</h2><h3 id="回溯-2"><a href="#回溯-2" class="headerlink" title="回溯"></a>回溯</h3><p>这到底由于给出了一些限制条件，因此不能用传统的数学公式或for迭代来实现。</p><p>而普通的回溯一般都有一个if来进行终止条件的判断，</p><p>这题的难点就在于用其他方式来实现回溯终止。</p><blockquote><p>常见的逻辑运算符有三种，即 “与 &amp;&amp; ”，“或 || ”，“非 ! ” ；而其有重要的短路效应，如下所示：</p><p>if(A &amp;&amp; B)  &#x2F;&#x2F; 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A &amp;&amp; B 为 false</p><p>if(A || B) &#x2F;&#x2F; 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true</p></blockquote><p>本题需要实现 “当 n &#x3D; 1 时终止递归” 的需求，可通过短路效应实现。</p><p>n &gt; 1 &amp;&amp; sumNums(n - 1) &#x2F;&#x2F; 当 n &#x3D; 1 时 n &gt; 1 不成立 ，此时 “短路” ，终止后续递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n + sumNums(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：1 ms, 在所有 Java 提交中击败了32.48%的用户</p><p>内存消耗：36 MB, 在所有 Java 提交中击败了8.57%的用户</p><hr><h1 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65 不用加减乘除做加法"></a>65 不用加减乘除做加法</h1><h2 id="题目-63"><a href="#题目-63" class="headerlink" title="题目"></a>题目</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“&#x2F;” 四则运算符号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a = 1, b = 1</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>a, b 均可能是负数或 0</code></p><p><code>结果不会溢出 32 位整数</code></p><h2 id="题解-62"><a href="#题解-62" class="headerlink" title="题解"></a>题解</h2><p>设两个二进制数a，b</p><table><thead><tr><th>a</th><th>b</th><th>进位(c)</th><th>无进位和(d)</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><p><code>进位</code>规则和<code>与运算</code>一致</p><p><code>无进位和</code>与<code>异或运算</code>规律相同</p><blockquote><p><code>c=a&amp;b&lt;&lt;1</code>与运算+左移一位</p><p><code>d=a^b</code>异或运算</p><p>则s&#x3D;a+b-&gt;s&#x3D;c+d</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, c, d;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//进位</span></span><br><span class="line">            c = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//无进位和</span></span><br><span class="line">            d = a ^ b;</span><br><span class="line">            <span class="comment">//把c重新赋值给a</span></span><br><span class="line">            a = c;</span><br><span class="line">            <span class="comment">//把d重新赋值给b</span></span><br><span class="line">            b = d;</span><br><span class="line">            <span class="comment">//当进位=0时跳出循环</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (c != <span class="number">0</span>);</span><br><span class="line">        res = c + d;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：35.3 MB, 在所有 Java 提交中击败了18.16%的用户</p><hr><h1 id="66-构建乘积函数"><a href="#66-构建乘积函数" class="headerlink" title="66 构建乘积函数"></a>66 构建乘积函数</h1><h2 id="题目-64"><a href="#题目-64" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]&#x3D;A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>所有元素乘积之和不会溢出 32 位整数</code><br><code>a.length &lt;= 100000</code></p><h2 id="题解-63"><a href="#题解-63" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力-2"><a href="#暴力-2" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] constructArr(<span class="type">int</span>[] a) &#123;</span><br><span class="line">        <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                b[i] *= a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; b.length; j++) &#123;</span><br><span class="line">                b[i] *= a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路应该是没什么问题，但是复杂度太高，超时了</p><h3 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h3><table><thead><tr><th>输出</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>B[0]</td><td>-</td><td>A[1]</td><td>A[2]</td><td>A[3]</td></tr><tr><td>B[1]</td><td>A[0]</td><td>-</td><td>A[2]</td><td>A[3]</td></tr><tr><td>B[2]</td><td>A[0]</td><td>A[1]</td><td>-</td><td>A[3]</td></tr><tr><td>B[3]</td><td>A[0]</td><td>A[1]</td><td>A[2]</td><td>-</td></tr></tbody></table><p>这题实质上就是维护左下角和右上角两个dp数组</p><p>状态转移方程:</p><p>设左下角为C，右上角为D</p><p><code>C[i]=C[i-1]*A[i-1]</code></p><p><code>D[i]=D[i+1]*A[i+1]</code></p><p><code>B[i]=C[i]*D[i]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] constructArr(<span class="type">int</span>[] a) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">        <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        c[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        d[n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            c[i] = c[i - <span class="number">1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            d[i] = d[i + <span class="number">1</span>] * a[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            b[i] = c[i] * d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：2 ms, 在所有 Java 提交中击败了52.20%的用户</p><p>内存消耗：51 MB, 在所有 Java 提交中击败了67.79%的用户</p><hr><h1 id="68-I-二叉搜索树的最近公共祖先"><a href="#68-I-二叉搜索树的最近公共祖先" class="headerlink" title="68 I 二叉搜索树的最近公共祖先"></a>68 I 二叉搜索树的最近公共祖先</h1><h2 id="题目-65"><a href="#题目-65" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/%E9%A2%98%E8%AE%B0%E5%BD%95/binarysearchtree_improved.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p><code>所有节点的值都是唯一的。</code><br><code>p、q 为不同节点且均存在于给定的二叉搜索树中。</code></p><h2 id="题解-64"><a href="#题解-64" class="headerlink" title="题解"></a>题解</h2><p>把最近公共祖先的定义理解提取一下：设节点 rootroot 为节点 p,q 的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p,q 的公共祖先，则称 root 是 “最近的公共祖先” 。</p><p>根据这个定义，若root是p，q的<strong>最近公共祖先</strong>，可以有以下推论：</p><ol><li>p，q在root的子树中，并且在root的<strong>异侧</strong></li><li>p&#x3D;root，q在root的子树中</li><li>q&#x3D;root，p在root的子树中</li></ol><p>而这题又有两个很重要的条件：树为<strong>二叉搜索树</strong>；树的节点的值<strong>唯一</strong>。</p><p>根据这两个条件，有以下推论</p><ol><li>若root.val&lt;p.val，则p在root的右子树中</li><li>若root.val&gt;p.val，则p在root的左子树中</li><li>若root.val&#x3D;p.val，则p就是root</li></ol><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当root的值比p和q都小，说明p，q都在root的右子树上</span></span><br><span class="line">            <span class="comment">//此时root的右子树中必然有更近的公共祖先，因此root向右迭代</span></span><br><span class="line">            <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">                root = root.right;</span><br><span class="line">            <span class="comment">//向左迭代同理</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">                root = root.left;</span><br><span class="line">            <span class="comment">//当p，q在root的异侧时，root一定是他们的最近公共祖先，跳出循环</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：5 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：38.8 MB, 在所有 Java 提交中击败了85.78%的用户</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>思路和迭代类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//向左递归</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：5 ms, 在所有 Java 提交中击败了100.00%的用户</p><p>内存消耗：39 MB, 在所有 Java 提交中击败了59.57%的用户</p><hr><h1 id="68-II-二叉树的最近公共祖先"><a href="#68-II-二叉树的最近公共祖先" class="headerlink" title="68 II 二叉树的最近公共祖先"></a>68 II 二叉树的最近公共祖先</h1><h2 id="题目-66"><a href="#题目-66" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/%E9%A2%98%E8%AE%B0%E5%BD%95/binarytree.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p><code>所有节点的值都是唯一的。</code><br><code>p、q 为不同节点且均存在于给定的二叉搜索树中。</code></p><h2 id="题解-65"><a href="#题解-65" class="headerlink" title="题解"></a>题解</h2><p>把最近公共祖先的定义理解提取一下：设节点 rootroot 为节点 p,q 的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p,q 的公共祖先，则称 root 是 “最近的公共祖先” 。</p><p>根据这个定义，若root是p，q的<strong>最近公共祖先</strong>，可以有以下推论：</p><ol><li>p，q在root的子树中，并且在root的<strong>异侧</strong></li><li>p&#x3D;root，q在root的子树中</li><li>q&#x3D;root，p在root的子树中</li></ol><p>上面这些都和<code>68 I</code>一样。但这题和<code>68 I</code>的区别在于，所给的树不是二叉搜索树。</p><p>由于没有了这个关键条件，这题只能用递归的方法写了。</p><h3 id="递归（先序遍历）"><a href="#递归（先序遍历）" class="headerlink" title="递归（先序遍历）"></a>递归（先序遍历）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//不仅是特判，也是后续递归的回溯条件</span></span><br><span class="line">        <span class="comment">//当后续递归遇到p，q时，就会回溯</span></span><br><span class="line">        <span class="keyword">if</span> (p == root || q == root) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一直向左子树遍历</span></span><br><span class="line">        <span class="comment">//如果左边有p或q，则将其赋值给left</span></span><br><span class="line">        <span class="comment">//注意left的值是向左遍历的过程中遇到的第一个p或q</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一直向右子树遍历</span></span><br><span class="line">        <span class="comment">//如果右边有p或q，则将其赋值给right</span></span><br><span class="line">        <span class="comment">//注意right的值是向右遍历的过程中遇到的第一个p或q</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//若left==null，说明p，q都在root的右子树中</span></span><br><span class="line">        <span class="comment">//则右边遇到的第一个p或q就是最近公共祖先</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="comment">//若right==null，说明p，q都在root的左子树中</span></span><br><span class="line">        <span class="comment">//则左边遇到的第一个p或q就是最近公共祖先</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="comment">//否则说明p和q在root的异侧，那root必定是最近公共祖先</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时：7 ms, 在所有 Java 提交中击败了75.96%的用户</p><p>内存消耗：39.6 MB, 在所有 Java 提交中击败了72.29%的用户</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自定义Controller参数解析器</title>
      <link href="/2022/04/02/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89Controller%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
      <url>/2022/04/02/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89Controller%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot自定义Controller参数解析器-HandlerMethodArgumentResolver"><a href="#SpringBoot自定义Controller参数解析器-HandlerMethodArgumentResolver" class="headerlink" title="SpringBoot自定义Controller参数解析器(HandlerMethodArgumentResolver)"></a>SpringBoot自定义Controller参数解析器(HandlerMethodArgumentResolver)</h1><p>正文省略一万字（</p><blockquote><p>参考：</p><p><a href="https://cloud.tencent.com/developer/article/1497760">HandlerMethodArgumentResolver(一)：Controller方法入参自动封装器（将参数parameter解析为值）【享学Spring MVC】 - 云+社区 - 腾讯云 (tencent.com)</a></p><p><a href="https://cloud.tencent.com/developer/article/1497783">HandlerMethodArgumentResolver(二)：Map参数类型和固定参数类型【享学Spring MVC】 - 云+社区 - 腾讯云 (tencent.com)</a></p><p><a href="https://cloud.tencent.com/developer/article/1497399">HandlerMethodArgumentResolver(三)：基于HttpMessageConverter消息转换器的参数处理器【享学Spring MVC】 - 云+社区 - 腾讯云 (tencent.com)</a></p><p><a href="https://cloud.tencent.com/developer/article/1497397">HandlerMethodArgumentResolver(四)：自定参数解析器处理特定应用场景，介绍PropertyNamingStrategy的使用【享学Spring MVC】 - 云+社区 - 腾讯云 (tencent.com)</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java动态代理</title>
      <link href="/2022/03/12/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2022/03/12/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>动态代理实现：</p><p>1、JDK 动态代理</p><p>​用 Java 反射包中的类和接口实现动态代理</p><p>2、CGLIB 动态代理</p><p>​通过第三方库 CGLIB ，以继承类的方式实现动态代理</p><h2 id="JDK-代理"><a href="#JDK-代理" class="headerlink" title="JDK 代理"></a>JDK 代理</h2><p><em><strong>由于底层机制的缘故，被代理的目标类必须实现至少一个接口</strong></em></p><ul><li>创建被代理的目标类以及其实现的接口</li><li>创建 <code>InvocationHandler</code> 接口的实现类，在 <code>invoke()</code> 中完成要代理的功能</li><li>用 <code>Proxy.newInstance() </code>动态地构造出代理对象</li></ul><p>Hello （被代理的目标类实现的接口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">plus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloImpl （被代理的目标类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloImpl</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sayHello方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">plus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        System.out.println(<span class="string">&quot;plus方法被调用&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回值为&quot;</span> + c);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyProxyHandler （InvocationHandler的实现类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法中传入被代理的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyProxyHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要代理的功能</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  JDK自动创建的代理的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被代理的对象的方法（哪个方法被调用，这里的 method 就是那个方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   被代理的方法的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在执行目标方法前，做一系列增强操作</span></span><br><span class="line">        before();</span><br><span class="line"></span><br><span class="line">        System.out.println(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行目标方法，获取返回值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        res = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在执行目标方法后，做一系列增强操作</span></span><br><span class="line">        after();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Main （主方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过 被代理的目标类 和 InvocationHandler的实现类</span></span><br><span class="line">        <span class="comment">//构造出代理对象</span></span><br><span class="line">        <span class="type">HelloImpl</span> <span class="variable">helloImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloImpl</span>();</span><br><span class="line">        <span class="type">MyProxyHandler</span> <span class="variable">myProxyHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyProxyHandler</span>(helloImpl);</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">helloProxy</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(helloImpl.getClass().getClassLoader(),</span><br><span class="line">                helloImpl.getClass().getInterfaces(),</span><br><span class="line">                myProxyHandler);</span><br><span class="line">        </span><br><span class="line">        helloProxy.sayHello();</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        helloProxy.plus(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//before</span></span><br><span class="line"><span class="comment">//public abstract void Hello.sayHello()</span></span><br><span class="line"><span class="comment">//sayHello方法被调用</span></span><br><span class="line"><span class="comment">//after</span></span><br><span class="line"><span class="comment">//==========</span></span><br><span class="line"><span class="comment">//before</span></span><br><span class="line"><span class="comment">//public abstract int Hello.plus(int,int)</span></span><br><span class="line"><span class="comment">//plus方法被调用</span></span><br><span class="line"><span class="comment">//返回值为2</span></span><br><span class="line"><span class="comment">//after</span></span><br></pre></td></tr></table></figure><p>JDK 代理生成的代理对象实际上是在原对象的基础上，给每个方法都用 <code>invoke()</code> 进行了加强</p><p>相较于静态代理，使用少量的代码就可以完成增强效果</p><h2 id="CGLIB-代理"><a href="#CGLIB-代理" class="headerlink" title="CGLIB 代理"></a>CGLIB 代理</h2><p>需要导入jar包：核心包和依赖包（spring_core.jar已经集成了这两个包，因此，导入此包即可）</p><p>子类是在调用的时候才生成的</p><p>使用目标对象的子类的方式实现的代理，它是在内存中构建一个子类对象从而实现对目标对象功能的扩展，能够在运行时动态生成字节码，可以解决目标对象没有实现接口的问题</p><p>缺点：被final或static修饰的类不能用cglib代理，因为它们不会被拦截，不会执行目标对象的额外业务方法</p><blockquote><p>[Java 动态代理详解 - whirlys - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/whirly/p/10154887.html#:~:text=Java">https://www.cnblogs.com/whirly/p/10154887.html#:~:text=Java</a> 动态代理详解. 动态代理在Java中有着广泛的应用，比如Spring,AOP、Hibernate数据查询、测试框架的后端mock、RPC远程调用、Java注解对象获取、日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等。. 本文主要介绍Java中两种常见的动态代理方式：JDK原生动态代理和CGLIB动态代理。. 由于Java动态代理与java反射机制关系紧密，请读者确保已经了解了Java反射机制 )</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高级</title>
      <link href="/2022/03/10/MySQL%E9%AB%98%E7%BA%A7/"/>
      <url>/2022/03/10/MySQL%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><blockquote><p>参考:<a href="https://zhuanlan.zhihu.com/p/416970649">MySQL逻辑架构 - 知乎 (zhihu.com)</a></p></blockquote><h3 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h3><p>将MySQL服务层通过线程池和TCP连接池，与多个客户端连接。主要工作是:<strong>连接处理</strong>、<strong>授权认证</strong>、<strong>安全防护</strong>。</p><h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><p>服务层用于处理核心服务，如标准的SQL接口、查询解析、SQL优化和统计、全局的和引擎依赖的缓存与缓冲器等等。所有的与存储引擎无关的工作，如过程、函数等，都会在这一层来处理。在该层上，服务器会解析查询并创建相应的内部解析树，并对其完成优化，如确定查询表的顺序，是否利用索引等，最后生成相关的执行操作。</p><p>服务层可以细分为几个部分:</p><ul><li><p><strong>SQL Interface: SQL接口</strong></p><ul><li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface </li><li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</li></ul></li><li><p><strong>Parser:</strong> <strong>解析器</strong></p><ul><li>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li><li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。</li></ul></li><li><p><strong>Optimizer:</strong> <strong>查询优化器</strong></p><ul><li>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划。</li><li>这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</li><li>它使用“<strong>选取-投影-连接</strong>”策略进行查询。例如:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,name FROM student WHERE gender = &#x27;女&#x27;;</span><br></pre></td></tr></table></figure><p>这个SELECT查询先根据WHERE语句进行选取，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。</p></li><li><p><strong>Caches &amp; Buffers: 查询缓存组件</strong></p><ul><li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li><li>这个查询缓存可以在不同客户端之间共享。 </li><li>从MySQL5.7.20开始，不推荐使用查询缓存，<strong>并在MySQL 8.0中删除</strong>。</li></ul></li></ul><h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><p>存储引擎层，存储引擎负责实际的MySQL数据的<strong>存储与提取，服务器通过API 与 存储引擎进行通信</strong>。不同的存储引擎功能和特性有所不同，这样可以根据实际需要有针对性的使用不同的存储引擎。</p><h3 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h3><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207300457811.png" alt="image-20220730045710707"></p><p><strong>MySQL的查询流程:</strong></p><p><strong>1.</strong> <strong>查询缓存</strong>:Server如果在查询缓存中发现了这条SQL语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在MySQL8.0之后就抛弃了这个功能。</p><p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL中的查询缓存，不是缓存查询计划，而是查询对应的结果。只有<strong>相同的查询操作才会命中查询缓存</strong>。<strong>两个查询请求在任何字符上的不同（例如:空格、注释、大小写），都会导致缓存不会命中</strong>。</p><p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。</p><p>此外，既然是缓存，那就有它缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或<code>DROP DATABASE</code>语句，那使用该表的所有缓存都将变为无效并被删除。对于更新压力大的数据库来说，查询缓存的命中率会非常低。</p><p><strong>2.</strong> <strong>解析器</strong>:在解析器中对SQL语句进行语法分析、语义分析。</p><p>分析器先做<strong>词法分析</strong>。用户输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。 </p><p>接着做<strong>语法分析</strong>。根据词法分析的结果，语法分析器（比如:Bison）会根据语法规则，判断用户输入的这个SQL语句是否满足MySQL语法。如果SQL语句正确，则会生成一个语法树，否则，报语法错误的信息</p><p><strong>3.</strong> <strong>优化器</strong>:在优化器中会确定SQL语句的执行路径，比如是根据全表检索，还是根据索引检索等。在查询优化器中，可以分为逻辑查询优化阶段和物理查询优化阶段。</p><p>物理优化:通过索引、表连接方式等技术进行优化；逻辑优化:通过SQL等价变换提升查询效率。</p><p><strong>4.</strong> <strong>执行器</strong>:在执行之前需要判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p><p>而存储引擎说白了就是<strong>如何存储数据</strong>、<strong>如何为存储的数据建立索引</strong>、<strong>如何更新&#x2F;查询数据</strong>等技术的实现方法。</p><p>MySQL 提供了多个存储引擎，在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。</p><h3 id="常见存储引擎"><a href="#常见存储引擎" class="headerlink" title="常见存储引擎"></a>常见存储引擎</h3><ul><li><h5 id="InnoDB-主要的事务存储引擎"><a href="#InnoDB-主要的事务存储引擎" class="headerlink" title="InnoDB:主要的事务存储引擎"></a><strong>InnoDB:主要的事务存储引擎</strong></h5><ul><li><p>InnoDB，支持事务、行级锁、自增主键、外键、自动灾难恢复。</p></li><li><p>MySQL5.5之后，成为默认存储引擎。 </p></li><li><p><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</strong></p></li><li><p>数据文件结构:</p><ul><li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li><li>表名.ibd 存储数据和索引</li></ul></li><li><p>对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保存数据和索引。</p></li></ul></li><li><h5 id="MyISAM-主要的非事务存储引擎"><a href="#MyISAM-主要的非事务存储引擎" class="headerlink" title="MyISAM:主要的非事务存储引擎"></a><strong>MyISAM:主要的非事务存储引擎</strong></h5><ul><li><p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务、行级锁、外键。</p></li><li><p>5.5之前默认的存储引擎</p></li><li><p>优势是<strong>访问的速度快</strong>，适合对事务完整性没有要求或者以SELECT、INSERT为主的应用</p></li><li><p>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高</p></li><li><p>数据文件结构:</p><ul><li>表名.frm 存储表结构</li><li>表名.MYD 存储数据 (MYData)</li><li>表名.MYI 存储索引 (MYIndex)</li></ul></li><li><p>应用场景:只读应用或者以读为主的业务</p></li></ul></li></ul><p><strong>InnoDB和MyISAM对比</strong></p><table><thead><tr><th>对比项</th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td>自带系统表使用</td><td>是</td><td>是</td></tr><tr><td>关注点</td><td>性能:节省资源、消耗少、简单业务</td><td>事务:并发写、事务、更大资源</td></tr><tr><td>默认安装</td><td>是</td><td>是</td></tr><tr><td>默认使用</td><td>否</td><td>是</td></tr></tbody></table><h3 id="InnoDB详解"><a href="#InnoDB详解" class="headerlink" title="InnoDB详解"></a>InnoDB详解</h3><blockquote><p>参考:<a href="https://zhuanlan.zhihu.com/p/180531140">mysql存储引擎InnoDB详解，从底层看清InnoDB数据结构 - 知乎 (zhihu.com)</a></p></blockquote><h4 id="数据库存储结构"><a href="#数据库存储结构" class="headerlink" title="数据库存储结构"></a>数据库存储结构</h4><p>数据是存放在磁盘上的，会先读取到内存中再由CPU进行操作。由于磁盘读取速度很慢，如果每次操作都只读取一行数据的话，磁盘IO量会非常高，导致性能很差。因此InnoDB将磁盘中的所有数据划分为若干个<strong>页（page）</strong>，以页作为磁盘与内存交互的基本单位，一般页的大小为<strong>16KB</strong>。<strong>页与页之间通过双向链表进行连接</strong>。</p><p>这主要是基于两种维度进行考量:</p><ol><li>时间维度:如果一条数据正在在被使用，那么在接下来一段时间内大概率还会再被使用。可以认为热点数据缓存都属于这种思路的实现。</li><li>空间维度:如果一条数据正在在被使用，那么存储在它附近的数据大概率也会很快被使用。InnoDB的数据页和操作系统的页缓存则是这种思路的体现。</li></ol><p><strong>页的上层结构</strong></p><p>除了页之外，在数据库中还存在着区（Extent）、段（Segment）和表空间（Tablespace）的概念。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207310327377.png" alt="image-20220731032703256"></p><ul><li>区（Extent）:是比页大一级的存储结构，一个区有<strong>64个连续的页</strong>，所以一个区的大小为<strong>1MB</strong>。</li><li>段（Segment）:由一个或多个区（不要求相邻）组成。<strong>段是数据库中的分配单位</strong>。</li><li>表空间（Tablespace）:由一个或多个段组成</li></ul><p>InnoDB 中的页并非只有一种，比如有存放 Insert Buffer 的页、存放 undo log 的页、存放数据的页等等。其中我们最关注的还是存放我们表数据的页，又称<strong>索引页</strong>，或者<strong>数据页</strong>，以下介绍的就是<strong>数据页</strong>。</p><p><strong>页的内部结构</strong></p><p>一个页由七部分构成:</p><table><thead><tr><th>名称</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>File Header（文件头）</td><td>38字节</td><td>页的通用信息（比如页的编号、其上一页、下一页是谁等）</td></tr><tr><td>Page Header（页头部）</td><td>56字节</td><td>页的专有信息（比如存储了多少条数据、第一条数据的地址等）</td></tr><tr><td>Infimum + Supremum（最小和最大记录）</td><td>26字节</td><td>指向页中的最小记录和最大记录的指针（比较的是主键大小）</td></tr><tr><td>User Records（用户记录）</td><td>不确定</td><td>存储的数据（单向链表方式存储）</td></tr><tr><td>Free Space（空闲空间）</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory（页目录）</td><td>不确定</td><td>为页中存储的数据记录目录，方便通过二分法查找某条具体数据的位置</td></tr><tr><td>File Trailer（文件尾）</td><td>8字节</td><td>校验页的完整性</td></tr></tbody></table><h4 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h4><p>行格式就是页中真正保存的数据的格式。行格式分为四种:<code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code>、<code>Compressed</code>。行格式之间都大同小异，主要介绍<code>Compact</code>。</p><blockquote><p>几种行格式的具体区别可以参考:<a href="https://blog.csdn.net/shuifa2008/article/details/103759062">Innodb 四种行格式对比_shuifa2008的博客-CSDN博客</a></p></blockquote><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207310353241.png" alt="image-20220731035340160"></p><h5 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h5><p>MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，拥有这些数据类型的列称为<strong>变长字段</strong>，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要<strong>把这些数据实际上占用的字节数也存起来</strong>。在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。</p><blockquote><p> 注意:这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10。</p></blockquote><h5 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h5><p>Compact行格式会<strong>把可以为NULL的列存在一个NULL值列表中</strong>。如果表中没有允许存储NULL的列，则NULL值列表也不存在。</p><p>例如一个表中有四个列C1、C2、C3、C4，其中C2、C3允许为NULL，则NULL值列表中会有两个bit位来<strong>逆序</strong>表示每条C2、C3是否为NULL。</p><p>规则为:bit位的值为1时，代表该列的值为NULL；bit位的值为0时，代表该列的值不为NULL。</p><p>例如一条行记录为<code>1,NULL,NULL,a</code>，则它的NULL值列表就为<code>1 1</code>；</p><p>例如一条行记录为<code>2,b,NULL,a</code>，则它的NULL值列表就为<code>1 0</code>；</p><p>之所以要存储NULL值列表是因为数据都是需要对齐的，如果没有标注出来NULL值的位置，就有可能在查询数据的时候出现混乱。如果使用一个特定的符号放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据。</p><h5 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h5><p>记录头信息分为几个部分:</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207310413765.png" alt="d35c888d876641768d782acb0e6668d3"></p><table><thead><tr><th>名称</th><th>大小（单位:bit）</th><th>描述</th></tr></thead><tbody><tr><td><code>预留位1</code></td><td>1</td><td>没有使用</td></tr><tr><td><code>预留位2</code></td><td>1</td><td>没有使用</td></tr><tr><td><code>delete_mask</code></td><td>1</td><td>标记该记录是否被删除（1表示被删除，0表示未删除）</td></tr><tr><td><code>mini_rec_mask</code></td><td>1</td><td>B+树的每层非叶子节点中的（主键）最小记录都会添加该标记（值为1）</td></tr><tr><td><code>n_owned</code></td><td>4</td><td>页目录中每个组中最后一条记录的头信息中会存储该组有多少条记录，就是n_owned</td></tr><tr><td><code>heap_no</code></td><td>13</td><td>表示当前记录在这个页的中的位置</td></tr><tr><td><code>record_type</code></td><td>3</td><td>表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶子节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录</td></tr><tr><td><code>next_record</code></td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><h5 id="隐藏列"><a href="#隐藏列" class="headerlink" title="隐藏列"></a>隐藏列</h5><p>记录的真实数据中，除了自定义的列的数据以外，还有三个隐藏列:</p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>DB_ROW_ID（row_id）</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>（DB_TRX_ID）transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>（DB_ROLL_PTR）roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。</p><h5 id="行溢出"><a href="#行溢出" class="headerlink" title="行溢出"></a>行溢出</h5><p>一个页的大小一般为16KB，但是MySQL中有些不定长的字段可以存储的值很大，例如VARCHAR最多可以存储65533个字节，这样的话就会导致一个页面连一条记录都存不下，这种现象就是行溢出。</p><p>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会<strong>存储该列的一部分数据</strong>，把剩余的数据分散存储在几个其他的页中进行<strong>分页存储</strong>，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为<strong>页的扩展</strong>。</p><p>在MySQL8.0中，默认行格式就是Dynamic。Dynamic、Compressed行格式和Compact行格式基本一致，只不过在处理行溢出数据时不同:</p><ul><li>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。</li><li>Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。</li></ul><h4 id="区、段和碎片区（了解）"><a href="#区、段和碎片区（了解）" class="headerlink" title="区、段和碎片区（了解）"></a>区、段和碎片区（了解）</h4><h5 id="为什么要有区"><a href="#为什么要有区" class="headerlink" title="为什么要有区"></a>为什么要有区</h5><p>B+树的每一层中的页都会形成一个双向链表，如果是以页为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。B+树索引的使用场景中，范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了。而如果链表中相邻的两个页物理位置离得非常远，就会发生随机I&#x2F;O。随机I&#x2F;O是非常慢的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用顺序I&#x2F;O。</p><p>所以引入区的概念，一个区就是物理位置上连续的64个页。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页的单位分配了，而是按照区为单位分配，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I&#x2F;O。</p><h5 id="为什么要有段"><a href="#为什么要有段" class="headerlink" title="为什么要有段"></a>为什么要有段</h5><p>对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段（segment），存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。</p><p>除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有数据段、索引段、回滚段。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。</p><p>在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。</p><p>段其实不对应表空间中的某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p><h5 id="为什么要有碎片区"><a href="#为什么要有碎片区" class="headerlink" title="为什么要有碎片区"></a>为什么要有碎片区</h5><p>默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16KB&#x3D;1024KB）存储空间，所以默认情况下一个只存在几条记录的小表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。</p><p>为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，InnoDB提出了一个碎片（fragment）区的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页面用于段A，有些页面用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。</p><p>所以此后为某个段分配存储空间的策略是这样的:</p><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li><li>当某个段已经占用了32个碎片区页面之后，就会申请以完整的区为单位来分配存储空间。</li></ul><p>所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。</p><h5 id="区的分类"><a href="#区的分类" class="headerlink" title="区的分类"></a>区的分类</h5><p>区大体上可以分为4种类型:</p><ul><li>空闲的区(FREE):现在还没有用到这个区中的任何页面。</li><li>有剩余空间的碎片区(FREE_FRAG):表示碎片区中还有可用的页面。</li><li>没有剩余空间的碎片区(FULL_FRAG):表示碎片区中的所有页面都被使用，没有空闲页面。</li><li>附属于某个段的区(FSEG):每一索引都可以分为叶子节点段和非叶子节点段</li></ul><p>处于<code>FREE</code>、<code>FREE_FRAG</code>以及<code>FULL_FRAG</code>这三种状态的区都是独立的，直属于表空间。而处于<code>FSEG</code>状态的区是附属于某个段的。</p><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><p>MySQL官方对索引的定义为:<strong>索引</strong>（Index）是帮助MySQL高效获取数据的<strong>数据结构</strong>。在InnoDB中，索引的形式为B+树。</p><p>这里所谓的高效，是指当我们从磁盘中读取数据时，应该尽可能地<strong>减少磁盘IO次数</strong>。</p><p>之前我们讲过InnoDB中，磁盘与内存交互的基本单位是页。可以想象一下，如果我们需要从MySQL中查找一条数据，应该如何查找？</p><p>朴素的思想:将数据页（或者区）读取到内存，然后再在内存中通过页目录，查询所需要的数据；如果未查询到，又需要进行一次磁盘IO，读取新的数据页到内存中。试想一下，如果一个表中有百万、千万条数据，即使我们每次进行磁盘IO的时候都尽量读取很多的数据页到内存中进行查询，但是产生的磁盘IO次数也还是会非常多。</p><p>这时就需要一种<strong>数据结构</strong>来<strong>快速找到数据存在的那个数据页</strong>，从而<strong>减少磁盘IO次数</strong>。这个数据结构就是<strong>B+树</strong>。</p><blockquote><p>如果还未了解B+树，可以参考:<a href="https://blog.csdn.net/jiang_wang01/article/details/113739230">什么是B+树？（详细图解）_初念初恋的博客-CSDN博客_b+树</a></p></blockquote><h3 id="索引的设计方案"><a href="#索引的设计方案" class="headerlink" title="索引的设计方案"></a>索引的设计方案</h3><p>现在，假设现在一张表中有这么几条数据（为了演示方便，假设一个页中最多只有三条数据、每次磁盘IO只能读取一个页）。</p><p>此时，假设我们需要查询<strong>主键（黄色字段）&#x3D;20</strong>的行数据，就会遇到刚才说的问题:需要先读取页10，再读取页28，再读取页9，最终找到数据，可以想象一下如果数据量很大，必然会产生很多次磁盘IO。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207310600967.png" alt="image-20220731060004831"></p><p>解决方案就是我们设计一个目录项:</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207310606621.png" alt="image-20220731060624503"></p><p>目录项中有两个字段:</p><ul><li>page_no:这个目录项所表示的数据页的编号</li><li>key:这个目录项所表示的数据页的中最小的数据的<strong>主键值</strong></li></ul><p>有了目录项，就可以先把目录项都读取到内存中，通过二分法查找，根据目录项中key的范围找到目标数据在哪个数据页中，然后直接读取那个数据页即可。</p><p>但是，随着数据量的增大，数据页会越来越多，相应的，<strong>目录项也会越来越多</strong>，直到需要多次磁盘IO才能把目录项全部读入内存中，这样又退化到我们设计目录项之前的状态了。同时，目录项还缺乏一个具体的存储结构来管理。</p><p>于是，我们可以<strong>将目录项用数据页来存储</strong>。并且，给存放目录项的数据页再设计一个数据页用来存放其目录项，简称套娃。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207310628841.png" alt="image-20220731061647409"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207310628328.png" alt="image-20220731062347803"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207310625889.png" alt="image-20220731062504812"></p><p><strong>目录项记录</strong> 和普通的 <strong>用户记录</strong> 的 <strong>不同点</strong>:</p><ul><li><strong>目录项记录</strong> 的 record_type 值是1，而 <strong>普通用户记录</strong> 的 record_type 值是0，InnoDB就是通过这个来区分 <strong>用户记录</strong> 和 <strong>目录项记录</strong> 的。</li><li>目录项记录只有 <strong>主键值和页的编号</strong> 两个列，而普通的用户记录的列是用户自己定义的，可能包含 <strong>很多列</strong> ，另外还有InnoDB自己添加的隐藏列。 </li><li>了解:记录头信息里还有一个叫 <strong>min_rec_mask</strong> 的属性，只有在存储 <strong>目录项记录</strong> 的页中的主键值最小的 <strong>目录项记录</strong> 的 <strong>min_rec_mask</strong> 值为 <strong>1</strong> ，其他别的记录的 <strong>min_rec_mask</strong> 值都是 <strong>0</strong> 。</li></ul><p><strong>相同点</strong>:两者用的是一样的数据页，都会为主键值生成 <strong>Page Directory （页目录）</strong>，从而在按照主键值进行查找时可以使用 <strong>二分法</strong> 来加快查询速度。</p><p>像这样的数据结构，就是B+树:</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207310629090.png" alt="image-20220731062944017"></p><p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第0层，之后依次往上加。之前我们做了一个非常极端的假设:存放用户记录的页最多存放3条记录，存放目录项记录的页最多存放4条记录。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录，那么:</p><ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</li><li>如果B+树有2层，最多能存放 1000×100&#x3D;10,0000 条记录。 </li><li>如果B+树有3层，最多能存放 1000×1000×100&#x3D;1,0000,0000 条记录。 </li><li>如果B+树有4层，最多能存放 1000×1000×1000×100&#x3D;1000,0000,0000 条记录。</li></ul><p>而每多一层B+树只会增加一次磁盘IO。一般来说，三层B+树索引足以存放百万级别的数据，而它的磁盘IO次数只有三次。</p><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>上面的例子中，我们是根据数据的<strong>主键</strong>来对数据进行排序的，这种索引就称为<strong>主键索引&#x2F;聚簇索引&#x2F;一级索引</strong>。这种索引只能针对查询条件是主键的查询进行索引优化。</p><p><strong>特点:</strong></p><ul><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义: </p><ul><li>页内的记录是按照主键的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。 </li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li></ul></li><li><p><strong>B+树的叶子节点存储的是完整的用户记录。</strong></p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p></li></ul><p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建，InnDB存储引擎会自动的为我们创建聚簇索引。</p><p><strong>优点:</strong></p><ul><li><strong>数据访问更快</strong>，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快。</li><li>聚簇索引对于主键的<strong>排序查找</strong>和<strong>范围查找</strong>速度<strong>非常快</strong>。</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io操作。</li></ul><p><strong>缺点:</strong></p><ul><li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。</li><li>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong>。</li></ul><h4 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h4><p>在实际的使用场景中，很显然不可能总是用主键作为查询条件。这时就需要对不同的<strong>查询字段</strong>按需建立索引了。这种索引就称为<strong>非聚簇索引&#x2F;二级索引&#x2F;辅助索引</strong>。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207310640078.png" alt="image-20220731064002985"></p><p>非聚簇索引和聚簇索引最大的区别就在于，它的叶子节点并不存放完整的数据，而是只存放<strong>建立索引的字段</strong>和<strong>主键值</strong>。因此当我们通过非聚簇索引查找数据时，找到的其实只是主键值，此时需要拿主键值，再去聚簇索引中找到完整的数据。这就称为<strong>回表</strong>。</p><h2 id="索引的使用和设计原则"><a href="#索引的使用和设计原则" class="headerlink" title="索引的使用和设计原则"></a>索引的使用和设计原则</h2><h3 id="索引的声明和使用"><a href="#索引的声明和使用" class="headerlink" title="索引的声明和使用"></a>索引的声明和使用</h3><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ul><li><p>从功能逻辑上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。</p></li><li><p>按照物理实现方式，索引可以分为 2 种:一级索引（聚簇索引）和二级索引（非聚簇索引）。</p><ul><li>一级索引:索引和数据存储在一起，都存储在同一个B+tree中的叶子节点。一般主键索引都是一级索引。</li><li>二级索引树的叶子节点存储的是主键而不是数据。也就是说，在找到索引后，得到对应的主键，再回到一级索引中找主键对应的数据记录。</li></ul></li><li><p>按照作用字段个数进行划分，分成单列索引和联合索引。</p></li></ul><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 建表时建立索引</span><br><span class="line">CREATE TABLE table_name [col_name data_type] </span><br><span class="line">[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]</span><br><span class="line"></span><br><span class="line"># 在已存在的表上创建索引</span><br><span class="line">ALTER TABLE table_name </span><br><span class="line">ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) [ASC | DESC]</span><br><span class="line"></span><br><span class="line">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name </span><br><span class="line">ON table_name (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure><ul><li><code>UNIQUE</code>、<code>FULLTEXT</code>和<code>SPATIAL</code>为可选参数，分别表示唯一索引、全文索引和空间索引；</li><li><code>INDEX</code>与<code>KEY</code>为同义词，两者的作用相同，用来指定创建索引；</li><li><code>index_name</code>指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</li><li><code>col_name</code>为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li><li><code>length</code>为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li><li><code>ASC</code>或<code>DESC</code>指定升序或者降序的索引值存储。</li></ul><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM table_name</span><br></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name DROP INDEX index_name;</span><br><span class="line">或</span><br><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure><h3 id="隐藏索引（8-0新特性）"><a href="#隐藏索引（8-0新特性）" class="headerlink" title="隐藏索引（8.0新特性）"></a>隐藏索引（8.0新特性）</h3><p>从 MySQL8.x 开始支持隐藏索引（invisible indexes），只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 切换成隐藏索引 </span><br><span class="line">ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; </span><br><span class="line"></span><br><span class="line"># 切换成非隐藏索引</span><br><span class="line">ALTER TABLE tablename ALTER INDEX index_name VISIBLE; </span><br><span class="line"></span><br><span class="line"># 也可以在创建索引时指定 INVISIBLE </span><br><span class="line"># 索引创建时默认是 VISIBLE</span><br></pre></td></tr></table></figure><p>（当索引被隐藏时，其内容仍是实时更新的，因此不推荐长期隐藏索引）</p><h3 id="创建索引原则（推荐创建索引的场景）"><a href="#创建索引原则（推荐创建索引的场景）" class="headerlink" title="创建索引原则（推荐创建索引的场景）"></a>创建索引原则（推荐创建索引的场景）</h3><h4 id="字段的数值有唯一性的限制"><a href="#字段的数值有唯一性的限制" class="headerlink" title="字段的数值有唯一性的限制"></a>字段的数值有唯一性的限制</h4><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都可以起到唯一性约束的，因此在我们的数据表中，如果<strong>某个字段是唯一的</strong>，就可以<strong>直接创建唯一性索引</strong>，或者<strong>主键索引</strong>。这样可以更快速地通过该索引来确定某条记录。</p><blockquote><p>参考:<a href="https://juejin.cn/post/7040110129512972325">普通索引的性能会不会比唯一索引好？ - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/it_lihongmin/article/details/115315120">Mysql - 普通索引与唯一索引之间性能差别change buffer_it_lihongmin的博客-CSDN博客</a></p></blockquote><h4 id="频繁作为-WHERE-查询条件且具有明显区分特性的字段"><a href="#频繁作为-WHERE-查询条件且具有明显区分特性的字段" class="headerlink" title="频繁作为 WHERE 查询条件且具有明显区分特性的字段"></a>频繁作为 WHERE 查询条件且具有明显区分特性的字段</h4><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到并且具有明显区分特性（例如username，而不是sex这种），那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p><h4 id="经常-GROUP-BY-和-ORDER-BY-的列"><a href="#经常-GROUP-BY-和-ORDER-BY-的列" class="headerlink" title="经常 GROUP BY 和 ORDER BY 的列"></a>经常 GROUP BY 和 ORDER BY 的列</h4><p>某个字段在 SELECT 语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对<strong>分组或者排序的字段进行索引</strong>。如果待排序的列有多个，那么可以在这些列上建立<strong>组合索引</strong>。</p><h4 id="UPDATE、DELETE-的-WHERE-条件列"><a href="#UPDATE、DELETE-的-WHERE-条件列" class="headerlink" title="UPDATE、DELETE 的 WHERE 条件列"></a>UPDATE、DELETE 的 WHERE 条件列</h4><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p><h4 id="查询-DISTINCT-字段"><a href="#查询-DISTINCT-字段" class="headerlink" title="查询 DISTINCT 字段"></a>查询 DISTINCT 字段</h4><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p><h4 id="多表-JOIN"><a href="#多表-JOIN" class="headerlink" title="多表 JOIN"></a>多表 JOIN</h4><ul><li><strong>连接表的数量尽量不要超过 3 张</strong>，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</li><li><strong>对 WHERE 条件创建索引</strong>，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</li><li><strong>对用于连接的字段创建索引</strong>，并且该字段在多张表中的<strong>类型必须一致</strong>。</li></ul><h4 id="使用列的类型小的创建索引"><a href="#使用列的类型小的创建索引" class="headerlink" title="使用列的类型小的创建索引"></a>使用列的类型小的创建索引</h4><p>我们这里所说的类型大小指的就是<strong>该类型表示的数据范围的大小</strong>。</p><ul><li>数据类型越小，在查询时进行的比较操作越快</li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I&#x2F;O 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul><p>这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I&#x2F;O。</p><h4 id="使用字符串前缀创建索引"><a href="#使用字符串前缀创建索引" class="headerlink" title="使用字符串前缀创建索引"></a>使用字符串前缀创建索引</h4><p>如果某个字段是 varchar 类型的（或者 text 等等），那么其中可能存储了很长的字符串，当建立索引时，可以不用整个字符串建立索引，而是指截取前面部分建立索引</p><p>拓展:Alibaba《Java开发手册》</p><p><strong>【强制】</strong>在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p><p>说明:索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上。</p><p>区分度计算公式:<code>count(distinct left(列名, 索引长度))/count(*)</code></p><h4 id="区分度高的列适合作为索引"><a href="#区分度高的列适合作为索引" class="headerlink" title="区分度高的列适合作为索引"></a>区分度高的列适合作为索引</h4><p>列的基数指的是某一列中不重复数据的个数，比方说某个列包含值 2,5,8,2,5,8,2,5,8，虽然有 9 条记录，但该列的基数却是 3 。也就是说，<strong>在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。</strong>这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小的列建立索引效果可能不好。</p><p>可以使用公式 <code>select count(distinct a)/count(*) from t1</code> 计算区分度，越接近 1 越好，一般超过 33% 就算是比较高效的索引了。</p><p>拓展:联合索引把区分度高（散列性高）的列放在前面。</p><h4 id="使用频率高的列放到联合索引的左侧"><a href="#使用频率高的列放到联合索引的左侧" class="headerlink" title="使用频率高的列放到联合索引的左侧"></a>使用频率高的列放到联合索引的左侧</h4><h4 id="多个字段都要创建索引的情况下，联合索引优于单值索引"><a href="#多个字段都要创建索引的情况下，联合索引优于单值索引" class="headerlink" title="多个字段都要创建索引的情况下，联合索引优于单值索引"></a>多个字段都要创建索引的情况下，联合索引优于单值索引</h4><h4 id="单张表的索引不超过6个"><a href="#单张表的索引不超过6个" class="headerlink" title="单张表的索引不超过6个"></a>单张表的索引不超过6个</h4><h3 id="不适合创建索引的场景"><a href="#不适合创建索引的场景" class="headerlink" title="不适合创建索引的场景"></a>不适合创建索引的场景</h3><ul><li>where 中使用不到的字段不要使用索引</li><li>数据量小的表不要使用索引</li><li>有大量重复数据的列上不要创建索引</li><li>避免对经常更新的表创建过多索引</li><li>不建议用无序的值作为索引</li><li>删除不再使用或者很少使用的索引</li><li>不要定义冗余或重复的索引</li></ul><h2 id="插入-1KW-条测试数据"><a href="#插入-1KW-条测试数据" class="headerlink" title="插入 1KW 条测试数据"></a>插入 1KW 条测试数据</h2><p>创建测试表t_user</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t_user` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `c_user_id` varchar(36) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;用户Id&#x27;,</span><br><span class="line">  `c_name` varchar(22) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;用户名&#x27;,</span><br><span class="line">  `c_province_id` int(11) NOT NULL COMMENT &#x27;省份Id&#x27;,</span><br><span class="line">  `c_city_id` int(11) NOT NULL COMMENT &#x27;城市Id&#x27;,</span><br><span class="line">  `create_time` datetime NOT NULL COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_user_id` (`c_user_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure><p>创建临时表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tmp_table` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>用 python 生成 1kw 个数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@fengye tmp]# python -c <span class="string">&quot;for i in range(1, 1+10000000): print(i)&quot;</span> &gt; base.txt</span><br></pre></td></tr></table></figure><p>在 mysql 中执行导入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data infile &#x27;\home\tmp\base.txt&#x27; replace into table  tmp_table</span><br></pre></td></tr></table></figure><blockquote><p>可能出现的报错</p><p><code>1290 - The MySQL server is running with the --secure-file-priv option so it cannot execute this statement</code></p><p>原因:mysql默认没有开启 <code>secure_file_priv</code> </p><p>解决:在 <code>my.ini(/etc/my.cnf)</code> 中的 <code>[mysqld]</code> 节点中添加</p><p>secure_file_priv &#x3D; ‘’，然后重启</p><p>说明:</p><p>secure_file_prive &#x3D; null 限制mysqld 不允许导入导出</p><p>secure_file_priv &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F; 限制mysqld的导入导出只能发生在&#x2F;var&#x2F;lib&#x2F;mysql-files&#x2F;目录下</p><p>secure_file_priv &#x3D; ‘’ 不对mysqld的导入导出做限制</p></blockquote><p>从临时表中的数据插入到 <code>t_user</code> 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into t_user</span><br><span class="line">select id,uuid(),concat(&#x27;userNickName&#x27;,id),floor(rand()*1000),floor(rand()*100),now()</span><br><span class="line">from tmp_table</span><br></pre></td></tr></table></figure><p>打乱创建时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t_user SET create_time=date_add(create_time, interval FLOOR(1 + (RAND() * 7)) year);</span><br></pre></td></tr></table></figure><h2 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="性能分析工具"></a>性能分析工具</h2><h3 id="查看系统性能参数"><a href="#查看系统性能参数" class="headerlink" title="查看系统性能参数"></a>查看系统性能参数</h3><p><code>SHOW [SESSION/GLOBAL] STATUS LIKE &#39;参数&#39;</code> </p><p>常用的性能参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Connections:连接 MySQL 服务器的次数</span><br><span class="line">Uptime:MySQL服务器上线事件</span><br><span class="line">Slow_queries:慢查询次数</span><br><span class="line">Innodb_rows_read:已select的行数</span><br><span class="line">Innodb_rows_inserted:已inserted的行数Innodb_rows_updated:已updated的行数Innodb_rows_deleted:已deleted的行数</span><br><span class="line">Com_select:查询操作的次数</span><br><span class="line">Com_insert:插入操作的次数</span><br><span class="line">Com_update:更新操作的次数</span><br><span class="line">Com_delete:删除操作的次数</span><br></pre></td></tr></table></figure><h3 id="查看上一条SQL语句的查询成本"><a href="#查看上一条SQL语句的查询成本" class="headerlink" title="查看上一条SQL语句的查询成本"></a>查看上一条SQL语句的查询成本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;last_query_cost&#x27; </span><br></pre></td></tr></table></figure><p>SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论:</p><ol><li><strong>位置决定效率</strong>。如果页就在数据库<strong>缓冲池</strong>中，那么效率是最高的，否则还需要从内存或者<strong>磁盘</strong>中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li><li><strong>批量决定效率</strong>。如果我们从磁盘中对单一页进行<strong>随机读取</strong>，那么效率是很低的（差不多10ms），而采用<strong>顺序读取</strong>的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li></ol><p>所以说，遇到I&#x2F;O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到<strong>缓冲池</strong>中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>MySQL的慢查询日志，用来记录在MySQL中<strong>响应时间超过阈值</strong>（即 <code>long_query_time</code> ，默认为<code>10s</code>）的语句。</p><p>慢查询日志默认为关闭状态，需要手动开启，支持持久化到文件。</p><p><strong>建议在测试环境中开启，正式环境中关闭，因为该功能会影响性能</strong>。</p><blockquote><p>补充说明:</p><p>除了 <code>long_query_time</code> 外，还有一个系统变量 <code>min_examined_row_limit</code>，表示查询扫描过的最小记录数。</p><p>当一条查询扫描的记录数大于 <code>min_examined_row_limit</code> 同时查询的执行事件超过 <code>long_query_time</code> ，那么这个查询就会被记录到慢查询日志中。</p><p>这个值默认是 <code>0</code> ，可以在 <code>my.ini/my.cnf</code> 中修改，也可用 <code>SET</code> 命令修改。</p></blockquote><h4 id="修改慢查询配置"><a href="#修改慢查询配置" class="headerlink" title="修改慢查询配置"></a>修改慢查询配置</h4><p>查看慢查询是否开启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;slow_query_log&#x27;;</span><br></pre></td></tr></table></figure><p>查看慢查询日志位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;slow_query_log_file&#x27;;</span><br></pre></td></tr></table></figure><p>开启慢查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL slow_query_log=&#x27;ON&#x27;;</span><br></pre></td></tr></table></figure><p>查看慢查询阈值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure><p>修改慢查询阈值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#测试发现:设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并 执行下述语句 </span><br><span class="line">mysql&gt; set global long_query_time = 1; </span><br><span class="line">mysql&gt; show global variables like &#x27;%long_query_time%&#x27;; </span><br><span class="line"></span><br><span class="line">mysql&gt; set long_query_time=1; </span><br><span class="line">mysql&gt; show variables like &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure><p>修改慢查询输出方式。默认为FILE，可以设置为 TABLE、FILE 或两个同时设置 TABLE,FILE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set log_output=TABLE; </span><br></pre></td></tr></table></figure><h4 id="查看慢查询数量"><a href="#查看慢查询数量" class="headerlink" title="查看慢查询数量"></a>查看慢查询数量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;%Slow_queries%&#x27;;</span><br></pre></td></tr></table></figure><h4 id="慢查询日志分析"><a href="#慢查询日志分析" class="headerlink" title="慢查询日志分析"></a>慢查询日志分析</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#得到按照时间排序的前10条里面含有左连接的查询语句 </span></span><br><span class="line">mysqldumpslow -s t -t 10 -g <span class="string">&quot;left join&quot;</span> /var/lib/mysql/atguigu-slow.log </span><br><span class="line"></span><br><span class="line">参数:</span><br><span class="line">-s 表示按照何种方式排序</span><br><span class="line">    c 访问次数</span><br><span class="line">    l 锁定时间</span><br><span class="line">    r 返回记录</span><br><span class="line">    t 查询时间</span><br><span class="line">    al 平均锁定时间</span><br><span class="line">    ar 平均返回记录数</span><br><span class="line">    at  平均查询时间</span><br><span class="line">-t 返回前面多少条数据</span><br><span class="line">-g 后边搭配一个正则匹配模式，大小写不敏感</span><br></pre></td></tr></table></figure><blockquote><p>可能会出现的报错:</p><p><code>mysqldumpslow: command not found...</code></p><p>原因:系统默认去 <code>/usr/bin</code> 下查找命令</p><p>解决方法:找到 mysql 的安装目录下的 <code>/bin/mysqldumpslow</code> </p><p>执行 <code>ln -s /www/server/mysql/bin/mysqldumpslow /usr/bin</code></p></blockquote><h4 id="重置慢查询日志"><a href="#重置慢查询日志" class="headerlink" title="重置慢查询日志"></a>重置慢查询日志</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs slow</span><br></pre></td></tr></table></figure><h3 id="EXPLAIN-分析查询语句"><a href="#EXPLAIN-分析查询语句" class="headerlink" title="EXPLAIN 分析查询语句"></a>EXPLAIN 分析查询语句</h3><blockquote><p>参考:<a href="https://www.cnblogs.com/LoveBB/p/15181075.html">mysql explain详解 - 天下没有收费的bug - 博客园 (cnblogs.com)</a></p></blockquote><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN 查询语句</span><br></pre></td></tr></table></figure><h4 id="EXPLAIN-语句输出的各个列的作用如下"><a href="#EXPLAIN-语句输出的各个列的作用如下" class="headerlink" title="EXPLAIN 语句输出的各个列的作用如下"></a>EXPLAIN 语句输出的各个列的作用如下</h4><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</td></tr><tr><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的索引</td></tr><tr><td>key_len</td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table><ul><li><h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>SELECT识别符（执行顺序的标识）。</p><ol><li>id值越大优先级越高，越先被执行</li><li>id相同时，执行顺序由上至下</li></ol></li><li><p>select_type</p><ul><li>SIMPLE(简单SELECT，不使用UNION或子查询等)</li><li>PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</li><li>UNION(UNION中的第二个或后面的SELECT语句)</li><li>DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</li><li>UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)</li><li>SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)</li><li>DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)</li><li>DERIVED(派生表的SELECT, FROM子句的子查询)</li><li>UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</li></ul></li><li><p>table</p><p>显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称，例如上面的e，d，也可能是第几步执行的结果的简称</p></li><li><p><strong>type</strong></p><p>对表的访问方式，表示 mysql 在表中找到所需行的方式，又称访问类型。</p><ul><li><p>ALL </p><p>不用索引，遍历全表（效率最低）</p></li><li><p>index </p><p>使用索引，遍历全表（效率还是很低）</p><p><code>select count(*) from user;</code></p></li><li><p>range </p><p>范围查询，用在 <code>between/like/&lt;=</code> 等等</p><p><code>select * from user where user_name like &#39;test&#39;;</code></p></li><li><p>ref </p><p>通过普通的二级索引进行等值查询（普通指的是不唯一索引，因此查询结果可能有多条）</p><p><code>select * from user where user_name = &#39;test&#39;;</code></p></li><li><p>ref_or_null </p><p>与 <code>ref</code> 类似，条件中多了一个 <code>is null</code> 判断 </p><p><code>select * from user where address = &#39;test&#39; or address is null;</code></p></li><li><p>eq_ref </p><p>连表查询时，连接的条件是<strong>主键</strong>或<strong>唯一二级索引</strong>，这是连表查询中连接效率最高的</p><p><code>select * from user join department on department.user_id = user.id;</code></p></li><li><p>const</p><p>根据<strong>主键</strong>或<strong>唯一二级索引</strong>与常数进行等值匹配</p><p><code>select * from user where id = 100;</code></p></li><li><p>system</p><p>const的特例，当查询的表只有一条数据时，用system（innodb不支持）</p></li></ul><p>结果从好到坏:<strong>system &gt; const &gt; eq_ref &gt; ref</strong> <strong>&gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt;</strong> <strong>range &gt; index &gt; ALL</strong> </p><p>SQL性能优化的目标:至少达到range级别，要求是ref级别，最好是consts级别</p></li><li><p>possible_keys &amp; key</p><p><code>possible_key</code> 表示可能用到的索引</p><p><code>key</code> 表示实际用到的索引</p></li><li><p>key_len</p><p>实际使用的索引的长度</p></li><li><p>ref</p><p>查询条件的类型</p></li><li><p><strong>rows</strong></p><p>预计需要读取的行数（越小越好）</p></li><li><p>filtered</p><p>某个表经过搜索条件过滤后剩余记录条数的百分比</p></li><li><p><strong>extra</strong></p><p>记录了一些额外的信息来帮助理解MySQL实际查询的过程</p></li></ul><h4 id="EXPLAIN-输出格式"><a href="#EXPLAIN-输出格式" class="headerlink" title="EXPLAIN 输出格式"></a>EXPLAIN 输出格式</h4><p><code>EXPLAIN FORMAT=&lt;xxx&gt; ...</code></p><ul><li>传统格式</li><li>JSON 格式（最详细）</li><li>TREE 格式（8.0.16+）</li><li>可视化输出（Mysql workbench）</li></ul><h3 id="分析优化执行计划-trace"><a href="#分析优化执行计划-trace" class="headerlink" title="分析优化执行计划:trace"></a>分析优化执行计划:trace</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 开启</span><br><span class="line">SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on; </span><br><span class="line"># 设置大小</span><br><span class="line">set optimizer_trace_max_mem_size=1000000;</span><br><span class="line"># 使用</span><br><span class="line">select * from student where id &lt; 10;</span><br><span class="line">select * from information_schema.optimizer_trace\G</span><br></pre></td></tr></table></figure><h3 id="MySQL监控分析视图-sys-schema"><a href="#MySQL监控分析视图-sys-schema" class="headerlink" title="MySQL监控分析视图 sys schema"></a>MySQL监控分析视图 sys schema</h3><h4 id="索引情况"><a href="#索引情况" class="headerlink" title="索引情况"></a>索引情况</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#1. 查询冗余索引 </span><br><span class="line">select * from sys.schema_redundant_indexes; </span><br><span class="line">#2. 查询未使用过的索引 </span><br><span class="line">select * from sys.schema_unused_indexes; </span><br><span class="line">#3. 查询索引的使用情况 </span><br><span class="line">select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema=&#x27;dbname&#x27; ;</span><br></pre></td></tr></table></figure><h4 id="表相关"><a href="#表相关" class="headerlink" title="表相关"></a>表相关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 1. 查询表的访问量 </span><br><span class="line">select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc; </span><br><span class="line"># 2. 查询占用bufferpool较多的表 </span><br><span class="line">select object_schema,object_name,allocated,data</span><br><span class="line">from sys.innodb_buffer_stats_by_table order by allocated limit 10; </span><br><span class="line"># 3. 查看表的全表扫描情况 </span><br><span class="line">select * from sys.statements_with_full_table_scans where db=&#x27;dbname&#x27;;</span><br></pre></td></tr></table></figure><h4 id="语句相关"><a href="#语句相关" class="headerlink" title="语句相关"></a>语句相关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#1. 监控SQL执行的频率 </span><br><span class="line">select db,exec_count,query from sys.statement_analysis order by exec_count desc; </span><br><span class="line">#2. 监控使用了排序的SQL </span><br><span class="line">select db,exec_count,first_seen,last_seen,query</span><br><span class="line">from sys.statements_with_sorting limit 1; </span><br><span class="line">#3. 监控使用了临时表或者磁盘临时表的SQL </span><br><span class="line">select db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line">from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0 order by (tmp_tables+tmp_disk_tables) desc;</span><br></pre></td></tr></table></figure><h4 id="IO相关"><a href="#IO相关" class="headerlink" title="IO相关"></a>IO相关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#1. 查看消耗磁盘IO的文件 </span><br><span class="line">select file,avg_read,avg_write,avg_read+avg_write as avg_io</span><br><span class="line">from sys.io_global_by_file_by_bytes order by avg_read limit 10;</span><br></pre></td></tr></table></figure><h4 id="Innodb-相关"><a href="#Innodb-相关" class="headerlink" title="Innodb 相关"></a>Innodb 相关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#1. 行锁阻塞情况 </span><br><span class="line">select * from sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure><h2 id="索引优化和查询优化"><a href="#索引优化和查询优化" class="headerlink" title="索引优化和查询优化"></a>索引优化和查询优化</h2><h3 id="索引失效的几种情况"><a href="#索引失效的几种情况" class="headerlink" title="索引失效的几种情况"></a>索引失效的几种情况</h3><blockquote><p>参考:<a href="https://www.cnblogs.com/technologykai/articles/14172224.html">mysql索引失效的常见原因和如何用好索引 - 问题大白 - 博客园 (cnblogs.com)</a></p></blockquote><ul><li>不满足最佳左前缀原则</li><li><code>where</code> 条件后使用计算、函数、类型转换</li><li>范围条件右边索引失效（指的是<strong>联合索引</strong>中的范围<strong>列</strong>）</li><li>使用了 <code>select *</code> （会引起回表）</li><li>字段不允许为空，则 <code>is null</code> 和 <code>is not null</code> 都失效；若字段允许为空，则 <code>is null</code> 走 <code>ref</code> 类型的索引，而 <code>is not null</code> 走 <code>range</code> 类型的索引。 </li><li><code>like</code> 查询左边有 <code>%</code></li><li><code>OR</code> 前后存在非索引的列</li><li>使用 <code>not in</code></li><li>使用 <code>!=</code> 、 <code>&lt;</code> 、 <code>&gt;</code></li></ul><h3 id="回表问题和索引覆盖"><a href="#回表问题和索引覆盖" class="headerlink" title="回表问题和索引覆盖"></a>回表问题和索引覆盖</h3><blockquote><p>参考:<a href="https://juejin.cn/post/6938357172791148575">避免写出致命 SQL，搞懂 MySQL 回表 - 掘金 (juejin.cn)</a></p></blockquote><p>在 <code>InnoDB</code> 中，索引分为聚簇索引和普通索引。</p><ul><li>聚簇索引的叶子节点存储的是完整的行记录</li><li>普通索引的叶子节点存储的是主键</li></ul><p>可见，<code>InnoDB</code> 的聚簇索引负责存储完整的行数据，而普通索引只能帮助找到主键。因此，<code>InnoDB</code> 必须也只能有一个聚簇索引。</p><ol><li>如果表定义的主键，那么主键就是聚簇索引</li><li>如果表没有定义主键，那么第一个 <code>not null</code> 的 <code>unique</code> 列就是聚簇索引</li><li>否则，<code>InnoDB</code> 会创建一个隐藏的 <code>DB_ROW_ID</code> 作为聚簇索引</li></ol><h4 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h4><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/6012bf39878a49d1abd22783581f9eb8tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.webp" alt="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80NDU5MDI0LWE3NWU3NjdkMDE5OGE2YTQ.png"></p><p>利用普通索引查询到某条数据的主键后，又返回到聚簇索引，重新定位该数据。</p><p>回表查询的性能比扫一遍索引树低。</p><h4 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h4><blockquote><p>如果一个索引包含（覆盖）了所需要查询的字段的值，那么就称为<strong>索引覆盖</strong></p></blockquote><p>在 InnoDB 中，普通索引树的叶子节点存储的都是主键+索引列值。</p><p>为了避免回表，可以对需要查询的数据建立联合索引。</p><h3 id="连接查询优化"><a href="#连接查询优化" class="headerlink" title="连接查询优化"></a>连接查询优化</h3><blockquote><p>参考:<a href="https://www.jianshu.com/p/048d93d3ee54">MySQL查询优化——连接以及连接原理 - 简书 (jianshu.com)</a></p><p>文章中有一处有误，MySQL 从 8.0.18 版本开始添加 hash join，并从 8.0.20 开始移除 BNLJ</p></blockquote><h4 id="连接查询原理"><a href="#连接查询原理" class="headerlink" title="连接查询原理"></a>连接查询原理</h4><p>在 MySQL 中，<code>A left join B on condition</code> 的执行过程如下:</p><ol><li>以 table_A 为驱动表，检索 table_B</li><li><strong>根据 on 条件过滤 table_B 的数据</strong>，构建 table_A 结果集，并且添加外部行。</li><li>对结果集执行 where 条件过滤。如果A中有一行匹配 where 子句但是B中没有一行匹配on条件，则生成另一个B行，其中所有列设置为 NULL。</li></ol><p>驱动表:用来最先获得数据，并以此表为依据，逐步获得其他表的数据，直至最终查询到所有符合条件的数据的第一个表。外连接:根据连接方向，主表是驱动表；内连接:小表驱动大表（where条件后的小的结果集将作为驱动表）。</p><p>在上述过程中，根据 on 条件过滤 table_B 的数据的算法，就被称为 join 算法。</p><ul><li>SNLJ（Simple Nested Loop Join）:<ol><li>从驱动表中选取数据，遍历被驱动表，匹配到的数据放入结果集</li><li>重复选取驱动表中的其他数据，直到遍历完驱动表</li><li>匹配效率非常低，并且还伴随着大量的 IO</li></ol></li><li>INLJ（Index Nested Loop Join）<ol><li>相比于 SNLJ ，从驱动表中选取出的数据和被驱动表中的匹配时，使用索引进行遍历</li><li>因此要求 on 的匹配条件是被驱动表的索引</li><li>提高了匹配效率</li></ol></li><li>BNLJ（Block Nested Loop Join）<ol><li>相比于 SNLJ ，在遍历被驱动表时，会读取整块的数据并将其缓存在内存的 join buffer 中</li><li>是被驱动表没有索引情况下的默认算法（8.0.18以前）</li><li>减少 IO 次数</li></ol></li></ul><p>总体性能:INLJ &gt; BNLJ &gt; SNLJ</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ol><li>为被驱动表的 on 匹配条件添加索引</li><li>增加 join buffer 的大小（通过增加缓存数据的大小，减少 IO 次数）</li><li>减少驱动表不必要的字段查询（字段越少，join buffer 缓存的数据就越多）</li></ol><p><strong>MySQL 从 8.0.18 版本开始添加 Hash Join，并从 8.0.20 开始移除 BNLJ</strong></p><ul><li>Nested Loop:对于被连接的<strong>数据子集较小</strong>的情况下，Nested Loop是个较好的选择。</li><li>Hash Join是做<strong>大数据集连接</strong>时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立散列值，然后扫描较大的表并探测散列值，找出与Hash表匹配的行。<ul><li>这种方式适用于较小的表完全可以放入内存中的情况，这样总成本就是访问两个表的成本之和。</li><li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高 I&#x2F;O 的性能。</li><li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。Hash Join 只能应用于等值连接，这是由 Hash 的特点决定的。</li></ul></li></ul><h3 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h3><blockquote><p>参考:<a href="https://www.jianshu.com/p/3989222f7084">MySQL 子查询优化 - 简书 (jianshu.com)</a></p></blockquote><p>子查询执行慢的原因:</p><ul><li>执行子查询时，MySQL 需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</li><li>子查询的临时表中不会存在索引。</li></ul><p>优化方法:用连接查询（join）替代子查询</p><h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p>MySQL两种排序方法:</p><ul><li>index:直接使用索引，因为索引是有序的，所以不需要额外的排序。效率高。</li><li>filesort:通过相应的排序算法，将取得的数据在系统变量设置的内存排序区（sort_buffer_size）中进行排序，如果内存装载不下，会将磁盘上的数据进行分块，再对各个数据块进行排序，再将各个块合并成有序的结果集。效率低。</li></ul><p>优化排序的思路就是尽量使用 index，迫不得已的情况下也要使用优化的 filesort。</p><p>然而，并非是 <code>只要 order by 的列上有索引，排序就一定会用 index</code> ，需要分情况来看。</p><h4 id="几种常见的排序情况"><a href="#几种常见的排序情况" class="headerlink" title="几种常见的排序情况"></a>几种常见的排序情况</h4><blockquote><p>参考:<a href="https://blog.csdn.net/u012068483/article/details/105593352">MySQL优化篇:排序分组优化</a></p></blockquote><ul><li><p>order by 的列上建立了索引并且使用了 limit 关键字，则会使用索引:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student order by age limit 100;</span><br></pre></td></tr></table></figure><p>如果没有使用 limit ，排序就不会走索引。因为如果使用了索引， <code>select *</code> 会引起大量回表，执行器会判断这种行为得不偿失，就将其优化成了 filesort。</p><p>但是如果实现了索引覆盖，那么不加 limit 关键字，也会走索引:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select age from student order by age limit 100;</span><br></pre></td></tr></table></figure></li><li><p>排序的列不满足联合索引的最左前缀原则，不使用索引；排序的顺序和索引相反，不使用索引。</p></li><li><p>没有 where 条件过滤，不使用索引</p></li></ul><h4 id="filesort-的两种排序法"><a href="#filesort-的两种排序法" class="headerlink" title="filesort 的两种排序法"></a>filesort 的两种排序法</h4><ul><li><p>双路排序（慢）</p><p>扫描两次磁盘最终得到数据。第一次扫描获取到排序列和主键，将其放入 sort_buffer 中按照 order by 排序后，再进行第二次扫描，获取到完整的行数据返回。</p></li><li><p>单路排序（快）</p><p>扫描一次最终得到数据。直接从磁盘读取查询需要的所有列，按照 order by 在 sort_buffer 中排序，然后返回。</p></li></ul><p>整体来看，单路排序各方面优于双路排序，但是会占用更多的内存空间，并且需要适当提高 sort_buffer_size 。</p><p>优化思路:</p><ol><li>提高 sort_buffer_size</li><li>提高 max_length_for_sort_data （数据总量超过这个值则会用双路，低于这个值用单路）</li><li>select 尽量只选择必要的字段</li></ol><h3 id="分组优化"><a href="#分组优化" class="headerlink" title="分组优化"></a>分组优化</h3><ul><li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li><li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li><li>当无法使用索引列，可以增大 <code>max_length_for_sort_data</code> 和 <code>sort_buffer_size</code> 参数的设置</li><li>where效率高于having，能写在where限定的条件就不要写在having中了</li><li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li></ul><h3 id="分页优化"><a href="#分页优化" class="headerlink" title="分页优化"></a>分页优化</h3><blockquote><p>参考:<a href="https://www.jianshu.com/p/864d0bd80115">数据量很大，分页查询很慢，怎么优化？ - 简书 (jianshu.com)</a></p></blockquote><p>分页查询例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from student limit 10000,100;</span><br><span class="line"># 查询 10000-10100 条数据，默认是按照主键排序</span><br></pre></td></tr></table></figure><p>上述例子虽然只查询出了100条数据，但实际上是先读取10100条数据，再抛弃前10000条数据。如果偏移量或者查询数量较多，那么查询的效率是很低的。</p><p>优化:</p><ul><li><p>先用子查询，检索出指定范围内的主键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student t,(select id from student limit 10000,100) a where t.id = a.id;</span><br></pre></td></tr></table></figure><p>由于子查询满足了索引覆盖，所以查询的效率很高</p></li><li><p>如果主键是连续递增的，可以用 id 的范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where id between 10000 and 10100;</span><br></pre></td></tr></table></figure></li></ul><h3 id="索引条件下推"><a href="#索引条件下推" class="headerlink" title="索引条件下推"></a>索引条件下推</h3><blockquote><p>参考:<a href="https://www.cnblogs.com/zengkefu/p/5684101.html">MySQL–索引条件下推优化 - zengkefu - 博客园 (cnblogs.com)</a></p></blockquote><p>简称 ICP (Index Condition Pushdown)</p><p>假设有联合索引 <code>idx(class_id,student_name,address)</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from student</span><br><span class="line">  where class_id = &quot;1&quot;</span><br><span class="line">  and student_name like &quot;%王%&quot;</span><br><span class="line">  and address like &quot;%江苏%&quot;;</span><br><span class="line"># like 条件不走索引</span><br></pre></td></tr></table></figure><ul><li>不开启 ICP 执行过程:先根据 class_id 回表找到数据，然后将数据与 like 条件匹配。数据量大时有大量回表。</li><li>开启 ICP 执行过程:先在索引树中判断是否符合 like 条件，再将筛选完的数据回表（由于创建的是联合索引，所以索引树的叶子结点上有完整的 class_id、student_name、address）。减少回表次数。</li></ul><p>ICP 默认开启，也可以用 <code>set optimizer_switch=&#39;index_condition_pushdown=off/on&#39;</code> 手动开启或关闭</p><h3 id="其他优化建议"><a href="#其他优化建议" class="headerlink" title="其他优化建议"></a>其他优化建议</h3><ul><li><p>exist 和 in 的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from A where A_id exists (select A_id from B)</span><br><span class="line"># 以 A 为主表</span><br><span class="line"></span><br><span class="line">select * from A where A_id in (select A_id from B)</span><br><span class="line"># 以 B 为主表</span><br></pre></td></tr></table></figure><p>根据小表驱动大表的原则，A表大则用exists，B表大则用in</p></li><li><p>如果确定查询的结果只有一条，可以加上 <code>limit 1</code> 来提高效率（避免找到结果后继续扫描）</p></li></ul><h2 id="数据库设计规范"><a href="#数据库设计规范" class="headerlink" title="数据库设计规范"></a>数据库设计规范</h2><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><blockquote><p><a href="https://www.cnblogs.com/lca1826/p/6601395.html">理解数据库范式-通俗易懂 - Strawberry丶 - 博客园 (cnblogs.com)</a></p></blockquote><p><strong>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。</strong>可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是:第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。高级别的范式满足低级别的范式。</p><p>范式只是设计的标准，实际上设计数据表时，不一定要完全满足这些标准。</p><blockquote><p>一些概念:</p><p><strong>属性</strong>:表中的字段</p><p><strong>元组</strong>:表中的一行数据。</p><p><strong>码</strong>:表中可以唯一确定一个元组的某个属性（或者属性组），如果这样的码有不止一个，那么大家都叫候选码，我们从候选码中挑一个出来做老大，它就叫<strong>主码</strong>。</p><p><strong>全码</strong>:如果一个码包含了所有的属性，这个码就是全码。</p><p><strong>主属性</strong>:一个属性只要在任何一个候选码中出现过，这个属性就是主属性。</p><p><strong>非主属性</strong>:与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。</p><p><strong>外码</strong>:一个属性（或属性组），它不是码，但是它别的表的码，它就是外码。</p></blockquote><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>定义:确保数据表中的每个字段的值具有原子性，即不可拆分</p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>定义:满足第一范式，所有非主属性完全依赖码（每条数据都可以唯一标识，并且普通字段完全依赖于主键）</p><blockquote><p>完全依赖:设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。</p><p>部分依赖:设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。</p></blockquote><p>例如有一张表中有key1，key2，列1，列2，列3。完全依赖就是只有知道了key1和key2的值，才能唯一确定列1，列2，列3。而如果只知道key1或key2，则无法唯一确定列1，列2，列3。</p><p>通俗来说，第二范式的就是要求一张表只做一件事。</p><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>定义:满足第二范式，消除传递依赖</p><p>即每一个非主属性都直接依赖码，而非主属性之间不能互相依赖</p><h4 id="巴斯范式"><a href="#巴斯范式" class="headerlink" title="巴斯范式"></a>巴斯范式</h4><p>定义:满足第三范式，主属性之间没有互相依赖</p><hr><p>**范式的优点:**有助于消除数据冗余。</p><p>**范式的缺点:**可能会降低查询效率，因为范式等级越高，设计的表就越多，越精细，查询时就需要关联更多的表。</p><p>在实际开发中，一般只满足到第三范式或巴斯范式；为了提高查询的效率，可能会适当增加冗余数据。</p><h3 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化"></a>反范式化</h3><p>当冗余信息有价值或者能够大幅提高查询效率，就会采取反范式化来优化。</p><p>添加冗余字段的建议:</p><ol><li>冗余字段不需要经常修改</li><li>冗余字段查询时不可或缺</li></ol><h3 id="数据表的设计原则"><a href="#数据表的设计原则" class="headerlink" title="数据表的设计原则"></a>数据表的设计原则</h3><ol><li>表的个数越少越好</li><li>表中的字段个数越少越好</li><li>表中联合主键的字段个数越少越好</li><li>使用主键和外键越多越好</li></ol><h3 id="设计建议"><a href="#设计建议" class="headerlink" title="设计建议"></a>设计建议</h3><h4 id="库相关"><a href="#库相关" class="headerlink" title="库相关"></a>库相关</h4><ol><li><p>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。</p></li><li><p>【强制】库名中英文<code>一律小写</code>，不同单词采用<code>下划线</code>分割。须见名知意。</p></li><li><p>【强制】库的名称格式:业务系统名称_子系统名。</p></li><li><p>【强制】库名禁止使用关键字（如type,order等）。</p></li><li><p>【强制】创建数据库时必须<code>显式指定字符集</code>，并且字符集只能是utf8mb4。创建数据库SQL举例:CREATE DATABASE crm_fund <code>DEFAULT CHARACTER SET &#39;utf8&#39;</code>; </p></li><li><p>【建议】对于程序连接数据库账号，遵循<code>权限最小原则</code>。使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号<code>原则上不准有drop权限</code>。 </p></li><li><p>【建议】临时库以<code>tmp_</code>为前缀，并以日期为后缀；备份库以<code>bak_</code>为前缀，并以日期为后缀。</p></li></ol><h4 id="表、列相关"><a href="#表、列相关" class="headerlink" title="表、列相关"></a>表、列相关</h4><ol><li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以<code>英文字母开头</code>。 </p></li><li><p>【强制】 <code>表名、列名一律小写</code>，不同单词采用下划线分割。须见名知意。</p></li><li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用<code>统一前缀</code>。比如:crm_fund_item </p></li><li><p>【强制】创建表时必须<code>显式指定字符集</code>为utf8mb4。 </p></li><li><p>【强制】表名、列名禁止使用关键字（如type,order等）。</p></li><li><p>【强制】创建表时必须<code>显式指定表存储引擎</code>类型。如无特殊需求，一律为InnoDB。 </p></li><li><p>【强制】建表必须有comment。 </p></li><li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或<code>缩写</code>。如:公司 ID，不要使用 corporation_id, 而用corp_id 即可。</p></li><li><p>【强制】布尔值类型的字段命名为<code>is_描述</code>。如member表上表示是否为enabled的会员的字段命名为 is_enabled。 </p></li><li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据。通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p></li><li><p>【建议】建表时关于主键:<code>表必须有主键 </code>(1)强制要求主键为id，类型为int或bigint，且为auto_increment 建议使用unsigned无符号型。 (2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部页分裂和大量随机I&#x2F;O，性能下降。</p></li><li><p>【建议】核心表（如用户表）必须有行数据的<code>创建时间字段</code>（create_time）和<code>最后更新时间字段</code>（update_time），便于查问题。</p></li><li><p>【建议】表中所有字段尽量都是<code>NOT NULL</code>属性，业务可以根据需要定义<code>DEFAULT值</code>。 因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</p></li><li><p>【建议】所有存储相同数据的<code>列名和列类型必须一致</code>（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</p></li><li><p>【建议】中间表（或临时表）用于保留中间结果集，名称以<code>tmp_</code>开头。备份表用于备份或抓取源表快照，名称以<code>bak_</code>开头。中间表和备份表定期清理。</p></li><li><p>【示范】一个较为规范的建表语句:</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user_info ( </span><br><span class="line">    `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增主键&#x27;, </span><br><span class="line">    `user_id` bigint(11) NOT NULL COMMENT &#x27;用户id&#x27;, </span><br><span class="line">    `username` varchar(45) NOT NULL COMMENT &#x27;真实姓名&#x27;, </span><br><span class="line">    `email` varchar(30) NOT NULL COMMENT &#x27;用户邮箱&#x27;, </span><br><span class="line">    `nickname` varchar(45) NOT NULL COMMENT &#x27;昵称&#x27;, </span><br><span class="line">    `birthday` date NOT NULL COMMENT &#x27;生日&#x27;, </span><br><span class="line">    `sex` tinyint(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;性别&#x27;, </span><br><span class="line">    `short_introduce` varchar(150) DEFAULT NULL COMMENT &#x27;一句话介绍自己，最多50个汉字&#x27;, </span><br><span class="line">    `user_resume` varchar(300) NOT NULL COMMENT &#x27;用户提交的简历存放地址&#x27;, </span><br><span class="line">    `user_register_ip` int NOT NULL COMMENT &#x27;用户注册时的源ip&#x27;, </span><br><span class="line">    `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, </span><br><span class="line">    `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, </span><br><span class="line">    `user_review_status` tinyint NOT NULL COMMENT &#x27;用户资料审核状态，1为通过，2为审核中，3为未 通过，4为还未提交审核&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`), </span><br><span class="line">    UNIQUE KEY `uniq_user_id` (`user_id`), </span><br><span class="line">    KEY `idx_username`(`username`), </span><br><span class="line">    KEY `idx_create_time_status`(`create_time`,`user_review_status`) </span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;网站用户基本信息&#x27;</span><br></pre></td></tr></table></figure><ol start="17"><li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</li></ol><h4 id="索引相关"><a href="#索引相关" class="headerlink" title="索引相关"></a>索引相关</h4><ol><li><p>【强制】InnoDB表必须主键为id int&#x2F;bigint auto_increment，且主键值<code>禁止被更新</code>。 </p></li><li><p>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为<code>BTREE</code>。 </p></li><li><p>【建议】主键的名称以<code>pk_</code>开头，唯一键以<code>uni_</code>或<code>uk_</code>开头，普通索引以<code>idx_</code>开头，一律使用小写格式，以字段的名称或缩写作为后缀。</p></li><li><p>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引:idx_sample_mid。 </p></li><li><p>【建议】单个表上的索引个数<code>不能超过6个</code>。 </p></li><li><p>【建议】在建立索引时，多考虑建立<code>联合索引</code>，并把区分度最高的字段放在最前面。</p></li><li><p>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</p></li><li><p>【建议】建表或加索引时，保证表里互相不存在<code>冗余索引</code>。 比如:如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</p></li></ol><h4 id="SQL编写相关"><a href="#SQL编写相关" class="headerlink" title="SQL编写相关"></a>SQL编写相关</h4><ol><li>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。 </li><li>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。 </li><li>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</li><li>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从同步延迟。</li><li>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。</li><li>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li><li>【建议】对单表的多次alter操作必须合并为一次，且必须留下alter语句的记录到git中。对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。因为alter table会产生<code>表锁</code>，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</li><li>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。 </li><li>【建议】事务里不要包含过多慢SQL。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</li><li>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id&#x3D;XX;否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>**事务:**一组逻辑操作单元，使数据从一种状态变换到另一种状态</p><p>**事务处理的原则:**保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(<strong>commit</strong>)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(<strong>rollback</strong>)到最初状态。</p><p><strong>事务的ACID特性:</strong></p><p>一般来说，事务都需要满足以下特性:</p><ul><li><p>原子性（atomicity）:</p><p>事务是不可分割的工作单元，要么全部提交，要么全部回滚</p></li><li><p>一致性（consistency）:</p><p>事务执行前后，从一个合法状态变换为另一个合法状态，即执行前后都满足业务的约束（符合业务的要求）</p></li><li><p>隔离性（isolation）:</p><p>多个用户并发访问数据库，执行事务时，事务之间不会互相干扰</p></li><li><p>持久性（durability）:</p><p>事务一旦被提交，数据的改变就是永久性的</p></li></ul><p><strong>事务的状态:</strong></p><ul><li><p><strong>活动的（active）</strong></p><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在<strong>活动的</strong>状态。</p></li><li><p><strong>部分提交的（partially committed）</strong></p><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并<strong>没有刷新到磁盘</strong>时，我们就说该事务处在<strong>部分提交的</strong>状态。</p></li><li><p><strong>失败的（failed）</strong></p><p>当事务处在<strong>活动的</strong>或者<strong>部分提交</strong>的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在<strong>失败</strong>的状态。</p></li><li><p><strong>中止的（aborted）</strong></p><p>如果事务执行了一部分而变为<strong>失败</strong>的状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为<strong>回滚</strong>。当<strong>回滚</strong>操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了<strong>中止</strong>的状态。</p></li><li><p><strong>提交的（committed）</strong></p><p>当一个处在<strong>部分提交</strong>的状态的事务将修改过的数据都<strong>同步到磁盘</strong>上之后，我们就可以说该事务处在了<strong>提交</strong>的状态。</p></li></ul><h3 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h3><h5 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a><strong>显式事务</strong></h5><p><strong>步骤1:</strong> <code>START TRANSACTION</code> 或者 <code>BEGIN</code> ，作用是显式开启一个事务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN; </span><br><span class="line">#或者 </span><br><span class="line">mysql&gt; START TRANSACTION;</span><br></pre></td></tr></table></figure><p><code>START TRANSACTION</code> 语句相较于 <code>BEGIN</code> 特别之处在于，后边能跟随几个<strong>修饰符</strong>: </p><p>①<code>READ ONLY</code>:标识当前事务是一个<strong>只读事务</strong>，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p><p>②<code>READ WRITE</code>:标识当前事务是一个<strong>读写事务</strong>，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p><p>③<code>WITH CONSISTENT SNAPSHOT</code>:启动一致性读。</p><p>**步骤2:**一系列事务中的操作（主要是DML，不含DDL）</p><p>**步骤3:**提交事务 或 中止事务（即回滚事务）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span><br><span class="line">mysql&gt; COMMIT;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 回滚事务。即撤销正在进行的所有没有提交的修改 </span><br><span class="line">mysql&gt; ROLLBACK; </span><br><span class="line"></span><br><span class="line"># 将事务回滚到某个保存点。 </span><br><span class="line">mysql&gt; ROLLBACK TO [SAVEPOINT]</span><br></pre></td></tr></table></figure><p>其中关于SAVEPOINT相关操作有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。</span><br><span class="line">SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除某个保存点</span><br><span class="line">RELEASE SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure><h5 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a><strong>隐式事务</strong></h5><p>在MySQL中，如果没有显示地用 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 开启事务，那么每一条DML语句都会被包装成一个<strong>独立的事务</strong>并自动提交。</p><p>有一个系统变量 <code>autocommit</code> ，默认为 true ，可以将其修改为 false 来关闭自动提交效果。这样的话写入的多条DML语句都会属于<strong>同一个事务</strong>，直到手动提交或回滚。</p><h5 id="隐式提交数据的情况"><a href="#隐式提交数据的情况" class="headerlink" title="隐式提交数据的情况"></a><strong>隐式提交数据的情况</strong></h5><ul><li>当使用DDL语句、修改MySQL的表结构时，就会隐式地提交之前未提交的事务</li><li><strong>事务控制或关于锁定的语句</strong><ul><li>当我们在一个事务还没提交或者回滚时就又使用 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句开启了另一个事务时，会隐式的提交上一个事务。</li><li><code>autocommit</code> 为 true</li><li>使用<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句也会<strong>隐式的提交</strong>前边语句所属的事务。</li></ul></li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><h4 id="数据并发问题"><a href="#数据并发问题" class="headerlink" title="数据并发问题"></a>数据并发问题</h4><p>对于 SQL 来说，服务端可能和多个客户端建立连接，每个客户端与服务端建立的连接被称为<strong>会话</strong>（<strong>Session</strong>）。每个会话都可以在自己的会话中向服务器发送请求语句，请求语句可能是事务的一部分，当多个会话同时发送请求时，就会遇到数据并发问题。</p><ol><li><strong>脏写（Dirty Write）</strong></li></ol><p>对于了两个事务 <code>Session A</code>、<code>Session B</code>，如果 <code>Session A</code> <strong>修改</strong>了 <code>Session B</code> 还未提交的数据，就发生了<strong>脏写</strong>。若 <code>Session B</code> 回滚，那么 <code>Session A</code> 修改的数据就不存在了。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207172032295.png" alt="image-20220717203218011"></p><ol start="2"><li><strong>脏读（Dirty Read）</strong></li></ol><p>对于两个事务 <code>Session A</code>、<code>Session B</code>，如果 <code>Session A</code> <strong>读取</strong>了 <code>Session B</code> 还未提交的数据，就发生了<strong>脏读</strong>。若 <code>Session B</code> 回滚，那么 <code>Session A</code> 读取的数据就是临时且失效的。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207172040428.png" alt="image-20220717204009186"></p><ol start="3"><li><strong>不可重复读（Non-Repeatable Read）</strong></li></ol><p>对于两个事务 <code>Session A</code>、<code>Session B</code>，如果 <code>Session A</code> <strong>读取</strong>了一个字段，然后 <code>Session B</code> 更新了这个字段，之后 <code>Session A</code> 再次读取同一个字段，值就不同了，就发生了<strong>不可重复读</strong>（<code>Session A</code> 的两次读取是在同一个事务中，因此逻辑上来说应当相同）</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207172045564.png" alt="image-20220717204553285"></p><ol start="4"><li><strong>幻读（Phantom）</strong></li></ol><p>对于两个事务 <code>Session A</code>、<code>Session B</code>，如果 <code>Session A</code> <strong>读取</strong>了一个字段，然后 <code>Session B</code> 在表中插入了一些新的数据，之后 <code>Session A</code> 再次读取同一个字段，就会多出一些数据，就发生了<strong>幻读</strong>（如果 <code>Session B</code> 删除了一些数据，导致第二次读取到的数据少了，不属于幻读。幻读强调的是读取到了之前没有的记录）</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207172102651.png" alt="image-20220717210231391"></p><p>严重程度排序:<code>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</code></p><h4 id="SQL的四种隔离级别"><a href="#SQL的四种隔离级别" class="headerlink" title="SQL的四种隔离级别"></a>SQL的四种隔离级别</h4><p>SQL标准中设立了4个隔离级别:</p><ul><li><code>READ UNCOMMITTED</code>:读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li><li><code>READ COMMITTED</code>:读已提交，它满足了隔离的简单定义:一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</li><li><code>REPEATABLE READ</code>:可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。<strong>这是MySQL的默认隔离级别，MySQL中这个级别可以通过临键锁、MVCC解决幻读</strong>。</li><li><code>SERIALIZABLE</code>:串行化。在事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li></ul><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207172129899.png" alt="image-20220717212926651"></p><h4 id="MySQL中设置事务的隔离级别"><a href="#MySQL中设置事务的隔离级别" class="headerlink" title="MySQL中设置事务的隔离级别"></a>MySQL中设置事务的隔离级别</h4><p>查看隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@transaction_isolation</span><br></pre></td></tr></table></figure><p>设置隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别; </span><br><span class="line">#其中，隔离级别格式: </span><br><span class="line">&gt; READ UNCOMMITTED </span><br><span class="line">&gt; READ COMMITTED </span><br><span class="line">&gt; REPEATABLE READ </span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure><h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>事务有四大特性:<strong>原子性</strong>、<strong>一致性</strong>、<strong>隔离性</strong>、<strong>永久性</strong>；<strong>隔离性</strong>由<strong>锁机制</strong>实现，<strong>原子性</strong>、<strong>一致性</strong>和<strong>持久性</strong>都由事务的<strong>redo日志</strong>和<strong>undo日志</strong>来保证。</p><ul><li><strong>redo log</strong>:重做日志，提供再写入操作，恢复提交事务修改的页操作，保证事务的<strong>持久性</strong></li><li><strong>undo log</strong>:回滚日志，回滚行记录到某个特定的版本，用来保证事务的<strong>原子性</strong>和<strong>一致性</strong></li></ul><h4 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h4><p>innoDB引擎是以页为单位来管理存储空间的，在真正访问磁盘中的页时，需要先把磁盘中的页缓存到内存中的 <strong>buffer pool</strong> 。所有的增删改查都必须先更新缓冲池中的数据，然后缓冲池中的数据（<strong>脏页，指内存中改动了但还未刷新到磁盘的页</strong>）再以一定的频率刷入磁盘（<strong>checkpoint机制</strong>）。</p><p>由于<strong>checkpoint</strong>不是每次更改都会触发的，因此如果在触发前数据库宕机，那么缓冲池中的数据就丢失了。为了保证数据库的<strong>持久性</strong>，所以引入了redo日志。</p><blockquote><p>如果取消缓冲池，每次数据有更新就刷入磁盘，也可以解决持久性的问题。但是同样是磁盘文件操作，为什么redo日志要优于这种方法？</p><ul><li>当我们要修改页中的一条数据时，需要先把整个页都加载到内存中进行修改，修改完成后再刷入磁盘。频繁的读取会严重浪费性能，而redo日志只是记录了物理日志，并不会读取页；</li><li>当同时需要修改多个页时，磁盘的随机IO性能太差，而redo日志只需要做顺序IO。</li></ul></blockquote><h5 id="redo日志的组成"><a href="#redo日志的组成" class="headerlink" title="redo日志的组成"></a>redo日志的组成</h5><ul><li><strong>重做日志缓冲（redo log buffer）</strong>:保存在内存中的临时缓冲数据</li></ul><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207181941507.png" alt="image-20220718194037472"></p><p><code>redo log buffer</code> <strong>默认大小16MB</strong>，最大4096MB，最小1MB</p><p>查看当前 redo log buffer 大小:<code>show variables like &#39;%innodb_log_buffer_size%&#39;</code></p><ul><li><strong>重做日志文件（redo log file）</strong>:保存在磁盘中的持久化文件</li></ul><p>位置:<code>/var/lib/mysql/ib_logfile0</code> 和 <code>/var/lib/mysql/ib_logfile1</code> </p><h5 id="redo日志的流程"><a href="#redo日志的流程" class="headerlink" title="redo日志的流程"></a>redo日志的流程</h5><p><strong>一个更新事务的流程</strong></p><ol><li>将原始数据从磁盘中读入内存中的缓冲池，在其中中修改数据</li><li>生成一条redo日志并将日志写入<code>redo log buffer</code>，记录的是数据被修改后的值</li><li>当事务commit时，将redo log buffer中的内容追加写入到<code>redo log file</code>中</li><li>定期将缓冲池中的数据刷新到磁盘中</li></ol><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207182048342.png" alt="image-20220718204815192"></p><p><strong>redo log的刷盘策略</strong></p><p>redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到<strong>文件系统缓存（page cache）</strong>中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p><p>针对这种情况，InnoDB给出 <code>innodb_flush_log_at_trx_commit</code> 参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略:</p><ul><li>设置为0:表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</li><li>设置为1:表示每次事务提交时都将进行同步，刷盘操作（<strong>默认值</strong>） </li><li>设置为2:表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</li></ul><p>查看刷盘策略: <code>show variables like &#39;innodb_flush_log_at_trx_commit&#39;</code></p><p>不同的刷盘策略对事务的执行性能有不同的影响，性能由高到低:<strong>0 &gt; 2 &gt; 1</strong></p><p><strong>redo log file相关参数设置</strong></p><ul><li><code>innodb_log_group_home_dir</code>:指定 redo log 文件组所在的路径，默认值为<code>./</code>，表示在数据库的数据目录下。MySQL的默认数据目录（<code>var/lib/mysql</code>）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。</li><li><code>innodb_log_files_in_group</code>:指明redo log file的个数，命名方式如:ib_logfile0，ib_logfile1… ib_logfilen。默认2个，最大100个。</li><li><code>innodb_log_file_size</code>:单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size）不能大于最大值512G。</li></ul><p><strong>日志文件组</strong></p><p>从上面可以看出，磁盘上的redo日志文件不止一个，而是以一个日志文件组的形式出现的。这些文件以 <code>ib_logfile[数字]</code> 的形式命名，每个redo日志文件大小是一样的。</p><p>redo日志在写入日志文件组时，从 <code>ib_logfile0</code> 开始写，如果写满了，就写 <code>ib_logfile1</code> ；同理，当前一个文件写满时，就往下一个文件中写；当最后一个文件写满后，就重新回到 <code>ib_logfile0</code> 继续写。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207182156474.png" alt="image-20220718215634374"></p><p><strong>checkpoint</strong></p><blockquote><p><a href="https://www.cnblogs.com/chenpingzhao/p/5107480.html">【mysql】关于checkpoint机制 - 踏雪无痕SS - 博客园 (cnblogs.com)</a></p></blockquote><p>在整个日志文件组中还有两个重要的属性: write pos、checkpoint</p><ul><li>write pos 记录当前的位置，一边写一边后移</li><li>checkpoint 是要擦除的位置</li></ul><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207182213743.png" alt="image-20220718221331569"></p><p>上图中，checkpoint左边是已经刷盘的数据，可以放心覆盖；右边是还未刷盘的数据，需要等待刷盘，checkpoint向前走之后才能覆盖</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207182226854.png" alt="image-20220718222602729"></p><h4 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h4><blockquote><p>参考:<a href="https://blog.csdn.net/Weixiaohuai/article/details/117867353">MySQL回滚日志（undo log）总结_每天都要进步一点点的博客-CSDN博客_undolog</a></p></blockquote><p>undo日志用于存储每一个事务在执行更新数据之前的<strong>原始数据</strong>，以便于在事务回滚后恢复原数据，从而保证原子性。</p><p><strong>undo日志的作用</strong></p><ul><li>回滚数据</li></ul><p>undo日志并不会将数据库<strong>物理</strong>地恢复到执行事务之前的样子，undo是逻辑日志，只能将数据库逻辑地恢复到原来的样子，数据结构和页本身并不能完全恢复。</p><ul><li>MVCC（多版本并发控制）</li></ul><p>当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据版本是怎样的，从而让用户能够读取到当前事务操作之前的数据（快照读）</p><h5 id="undo日志的存储结构"><a href="#undo日志的存储结构" class="headerlink" title="undo日志的存储结构"></a>undo日志的存储结构</h5><p>InnoDB 对 undo log 的存储采用了分段方式进行存储（<strong>回滚段 rollback segment</strong>）。</p><p>一个回滚段中有1024个undo日志段，也就是说一个回滚段支持1024个undo日志操作。在InnoDB1.1之前，只支持1个回滚段。从InnoDB1.1开始，可以支持128个回滚段。从InnoDB1.2开始，可以通过参数对回滚段进行一些设置:</p><ul><li><strong>innodb_undo_directory</strong>:设置回滚段的存放路径，默认值为InnodDB存储引擎的目录</li><li><strong>innodb_undo_logs</strong>:设置回滚段的数量，默认为128</li><li><strong>innodb_undo_tablespaces</strong>:设置构成回滚段的表空间文件的数量</li></ul><p><strong>回滚段和事务的关系</strong></p><ul><li>每个事务使用一个回滚段，每个回滚段在同一时刻可以服务于多个事务</li><li>事务产生的undo日志会不断填充回滚段中的区，当前的区不够使用时，会扩展至下一个区。如果回滚段中的所有区都被占满，事务会覆盖最初的区（在可被覆盖的情况下）。</li></ul><p><strong>回滚段中的数据分类</strong></p><ul><li>未提交的回滚数据:该数据所关联的事务并未提交，不能被其他事务的数据覆盖</li><li>已经提交但未过期的回滚数据:该数据所关联的事务已经提交，但是不能被其他事务数据覆盖</li><li>已经提交并且已经过期的数据:该数据所关联的事务已经提交，并且已经过期，会被优先覆盖</li></ul><p>事务提交后并不能马上删除undo日志，因为可能还有其他事务要通过undo日志来得到之前版本的数据。</p><p><strong>undo日志的类型</strong></p><ul><li>insert undo log</li></ul><p>事务在 insert 过程中产生的 undo log ，只对事务本身可见，因此在事务提交后可以直接删除。</p><ul><li>update undo log</li></ul><p>事务在 update 和 delete 过程中产生的 undo log ，对其他事务可见，需要提供MVCC机制，因此不能再事务提交时删除。提交时放入 undo log 链表，等待 purge 线程进行最后的删除。</p><h5 id="undo日志的生命周期"><a href="#undo日志的生命周期" class="headerlink" title="undo日志的生命周期"></a>undo日志的生命周期</h5><p><strong>undo日志的生成</strong></p><p>对于InnoDB引擎来说，每个行记录除了记录本身的数据外，还有几个隐藏列:</p><ul><li><strong>DB_ROW_ID</strong>:如果没有显式地为表指定主键，并且表中也没有唯一索引，那么 InnoDB 会自动为每一行生成，作为隐藏主键</li><li><strong>DB_TRX_ID</strong>:每个事务都会分配一个事务ID，当事务对某条记录执行改动操作时，就会把这个ID写入到这里</li><li><strong>DB_ROLL_PTR</strong>:指向 undo log 的指针</li></ul><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207200047115.png" alt="image-20220720004708044"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207200051042.png" alt="image-20220720005112963"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207200053742.png" alt="image-20220720005345629"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207200054646.png" alt="image-20220720005457522"></p><p><strong>undo日志的回滚</strong></p><p>针对上面的例子，执行 rollback 的流程:</p><ol><li>通过 undo no&#x3D;3 的日志把 id&#x3D;2 的数据删除</li><li>通过 undo no&#x3D;2 的日志把 id&#x3D;1 的数据的 deletemark 还原成0</li><li>通过 undo no&#x3D;1 的日志把 id&#x3D;1 的数据的 name 还原成 Tom</li><li>通过 undo no&#x3D;0 的日志把 id&#x3D;1 的数据删除</li></ol><p><strong>undo日志的删除</strong></p><ul><li>对于 insert undo log</li></ul><p>由于只对事务本身可见，因此可以在事务提交后直接删除，不需要进行 purge 操作</p><ul><li>对于 update undo log</li></ul><p>由于对其他事务可见，可能会需要提供MVCC机制。因此事务提交时，会被放入undo日志链表，等待purge线程进行删除。</p><blockquote><p>purge的作用主要是<strong>清理undo页</strong>和<strong>删除普通页中被标记的数据</strong>。在InnoDB中，事务中的DELETE操作只会把数据行标记为删除，需要等待purge线程执行真正的删除操作。</p><p>参考:<a href="https://cloud.tencent.com/developer/article/1506737">MySQL purge 线程 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p></blockquote><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207200112782.png" alt="image-20220720011210688"></p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><blockquote><p>参考:<a href="https://learnku.com/articles/39212">一张图彻底搞懂 MySQL 的锁机制 | MySQL 技术论坛 (learnku.com)</a></p></blockquote><p>锁是一种用于管理共享资源的并发访问的机制，一般都由数据库或存储引擎根据当前的事务隔离级别自动添加，我们只需要了解它的机制即可。</p><h3 id="MySQL几种并发情况"><a href="#MySQL几种并发情况" class="headerlink" title="MySQL几种并发情况"></a>MySQL几种并发情况</h3><p><strong>读-读并发</strong></p><p>不会对数据有影响，不需要处理。</p><p><strong>写-写并发</strong></p><p>会发生<strong>脏写</strong>问题，SQL规范的任何一个隔离级别都用锁解决了这个问题。</p><p><strong>读-写并发</strong></p><p>可能发生<strong>脏读</strong>、<strong>不可重复读</strong>、<strong>幻读</strong>的问题</p><p><strong>读-写并发问题的解决方案</strong></p><ul><li>读写都加锁（读写操作彼此需要排队执行，性能低，但是读出来的数据始终是最新版本）</li><li>读操作采用MVCC，写操作加锁（读写操作不冲突，性能高，无法保证读出来的数据最新）</li></ul><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207210340714.png" alt="image-20220721034006583"></p><h4 id="从数据的操作类型划分"><a href="#从数据的操作类型划分" class="headerlink" title="从数据的操作类型划分"></a>从数据的操作类型划分</h4><ul><li><strong>共享锁&#x2F;读锁&#x2F;S锁</strong>:多个事务的读操作可以同时进行，不会相互影响也不会相互阻塞。</li><li><strong>排他锁&#x2F;写锁&#x2F;X锁</strong>:当前的写操作没有完成前，会阻塞其他写锁和读锁，确保在一段时间内，只有一个事务能执行写入，并且防止其他事务读取正在写入的资源。同理，在当前读操作执行时，也会阻塞其他的写操作。</li></ul><p>在InnoDB中，共享锁和排他锁既可以作用在表上，也可以作用在行上。</p><p>读操作可以加共享锁和排他锁，写操作一般只加排他锁。</p><table><thead><tr><th align="center"></th><th align="center">共享锁</th><th align="center">排他锁</th></tr></thead><tbody><tr><td align="center">共享锁</td><td align="center">兼容</td><td align="center">不兼容</td></tr><tr><td align="center">排他锁</td><td align="center">不兼容</td><td align="center">不兼容</td></tr></tbody></table><p><strong>给读操作加锁</strong></p><ul><li><p>给读操作加共享锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br><span class="line"># 或</span><br><span class="line">SELECT ... FOR SHARE; #(8.0新增语法)</span><br><span class="line"># 加的是表锁</span><br></pre></td></tr></table></figure></li><li><p>给读操作加排他锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK IN UPDATE MODE;</span><br><span class="line"># 或</span><br><span class="line">SELECT ... FOR UPDATE; #(8.0新增语法)</span><br><span class="line"># 加的是表锁</span><br></pre></td></tr></table></figure></li></ul><p><strong>MySQL8.0新特性:</strong></p><p>在5.7及之前的版本，执行 <code>SELECT ... FOR UPDATE</code> ，如果获取不到锁，会一直等待，直到超时（<code>innodb_lock_wait_timeout</code>变量）。在8.0版本后，添加<code>NOWAIT</code>、<code>SKIP LOCKED</code>语法，跳过锁等待，或者跳过锁定。（<code>SELECT ... FOR UPDATE NOWAIT</code>）</p><ul><li>NOWAIT:如果查询的行已经加锁，会立即报错返回</li><li>SKIP LOCKED:如果查询的行已经加锁，只返回结果中不包含被锁定的行</li></ul><p><strong>给写操作加锁</strong></p><ul><li><p>给写操作加排他锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DELETE/INSERT/UPDATE ... LOCK IN UPDATE MODE;</span><br><span class="line"># 或</span><br><span class="line">SELECT ... FOR UPDATE; #(8.0新增语法)</span><br><span class="line"># 加的是表锁</span><br></pre></td></tr></table></figure></li></ul><p><strong>写操作和锁的具体执行过程</strong></p><ul><li>DELETE:对一条记录做DELETE操作的过程其实是先在B+树中定位到这条记录的位置，然后获取这条记录的X锁，再执行delete mark操作。</li><li>UPDATE:在对一条记录做UPDATE操作时分为三种情况:<ul><li>情况1:未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在B+树中定位到这条记录的位置，然后再获取一下记录的X锁，最后在原记录的位置进行修改操作。</li><li>情况2:未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。新插入的记录由INSERT操作提供的隐式锁进行保护。</li><li>情况3:修改该记录的键值，则相当于在原记录上做DELECT操作之后再来一次INSERT操作。</li></ul></li><li>INSERT:一般情况下，新插入一条记录的操作并不加锁，通过一种称之为隐式锁的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</li></ul><h4 id="从锁的粒度划分"><a href="#从锁的粒度划分" class="headerlink" title="从锁的粒度划分"></a>从锁的粒度划分</h4><ul><li><strong>表锁</strong>:锁定整张表，是MySQL的基本锁策略，不依赖于存储引擎。<strong>锁的粒度最大，冲突概率高，并发度低，开销低，不容易死锁</strong>。</li><li><strong>行锁</strong>:锁定某一行，依赖于存储引擎实现。<strong>锁的粒度最小，冲突概率低，并发度高，开销大，容易出现死锁</strong>。</li><li><strong>页锁</strong>:锁定某一页，<strong>各项属性介于表锁和行锁之间</strong>。</li></ul><p>每个层级的锁的数量是有限制的。由于锁会占用内存，锁空间的大小也有限制。当某个层级的锁的数量超过这个层级的上限时，就会进行<strong>锁升级</strong>，即用大粒度的锁取代小粒度的锁，从而降低锁空间的内存占用，但是会<strong>降低并发度</strong>。</p><p>不同粒度的锁之间不能共存。</p><h5 id="表锁分类"><a href="#表锁分类" class="headerlink" title="表锁分类"></a>表锁分类</h5><ul><li><p>共享锁、排他锁</p><p><strong>InnoDB</strong>对某个表执行DML语句时（CRUD），不会自动添加表级的S锁和X锁；执行 <code>ALTER TABLE</code> 之类的DDL语句时，阻塞其他的DML语句；同理，执行DML语句也会阻塞DDL语句。而<strong>MyISAM</strong>在执行查询语句前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。</p><p>手动给表加锁:<code>lock tables t read/write</code> （一般不用）</p><p>查看加锁的表:<code>show open tables where in_use &gt; 0</code></p><p>手动解锁所有表:<code>unlock tables</code></p></li><li><p>意向锁（intention lock）</p><p>意向锁是一种特殊的表锁，它<strong>可以和行锁共存</strong>。<strong>意向锁的作用是让粒度更高的锁知道其中是否上过粒度小的锁（因此意向锁相互之间都是兼容的）</strong>。如果没有意向锁，当一个事务想要给一张表加表锁时，需要遍历该表的所有行，查看其中是否有行锁。</p><p>当我们给某一行数据加上行锁时，会自动给更高粒度的空间（页、表）上一个意向锁。这样当其他事务需要给这个空间上更高粒度的锁时，就不用再遍历了。</p><p>意向锁也分为意向共享锁，意向排他锁，自动根据行锁的类型进行选择。</p></li><li><p>自增锁（auto inc）</p><p>当表中有自增字段（auto increment）时，为了确保自增字段是连续自增的，就需要自增锁来实现。当执行插入时，就会自动添加一个表级的自增锁，执行完毕后再释放。由于每条插入语句都需要参与自增锁的竞争，并发度很低，所以可以通过 <code>innodb_autoinc_lock_mode</code> 变量来改变锁定机制。</p><blockquote><p>MySQL的插入分成三种:简单插入、批量插入、混合插入。</p><p><strong>简单插入</strong>是指可以预先知道插入的行数的语句，例如没有嵌套子查询的 insert；</p><p><strong>批量插入</strong>是指不能预先知道插入的行数的语句，例如嵌套子查询的 insert；</p><p><strong>混合插入</strong>与简单插入类似，但是部分数据手动指定了自动递增字段的值。</p></blockquote><p><strong>innodb_autoinc_lock_mode &#x3D; 0</strong></p><p>传统的模式，每个插入语句都添加一个表级自增锁。</p><p><strong>innodb_autoinc_lock_mode &#x3D; 1</strong></p><p>MySQL8.0之前的默认值。在这种情况下，批量插入仍然使用自增锁，但是简单插入则使用 mutex （轻量级锁，只在分配过程中保持）来获取所需数量的自动低增值。</p><p><strong>innodb_autoinc_lock_mode &#x3D; 2</strong></p><p>MySQL8.0后的默认值。在这种情况下，所有的插入语句都不会使用自增锁，但是执行批量插入时，生成的自增字段的值可能不连续。</p><blockquote><p>更多关于自增字段的细节参考:<a href="https://cloud.tencent.com/developer/article/1974491">MySQL自增主键为什么不连续 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p></blockquote></li><li><p>元数据锁（DML）</p><p>元数据锁的作用是保证读写的正确性不被表结构影响。</p><p>当对表做CRUD操作时，自动加元数据读锁；当对表结构做变更操作时，自动加元数据写锁。</p><p>读锁与读锁兼容，读锁与写锁、写锁与写锁不兼容。</p></li></ul><h5 id="行锁分类"><a href="#行锁分类" class="headerlink" title="行锁分类"></a>行锁分类</h5><ul><li><p>记录锁（record locks）</p><p>字面意思，给一条行记录加锁，也是最常用的锁。记录锁也分为读锁和写锁，规则与表级的相同。</p></li><li><p>间隙锁（gap locks）</p><p>间隙锁用于解决幻读问题（也可以用MVCC解决）。</p><p>插入间隙锁后，不允许其他事务在两条记录之间插入新数据。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207240123521.png" alt="image-20220724012351313"></p></li><li><p>临键锁（Next-key locks）</p><p>相当于是记录锁和间隙锁的结合体，是InnoDB的默认锁。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207242351543.png" alt="image-20220724235132356"></p></li><li><p>插入意向锁（insert intention locks）</p><blockquote><p><a href="https://blog.csdn.net/fofcn/article/details/123219466">MySQL InnoDB中的锁-插入意向锁（Insert Intention Lock）_小厂程序员的博客-CSDN博客_插入意向锁</a></p></blockquote></li></ul><h4 id="从对待锁的态度划分"><a href="#从对待锁的态度划分" class="headerlink" title="从对待锁的态度划分"></a>从对待锁的态度划分</h4><ul><li><strong>悲观锁</strong>:总是假设最坏的情况，每次拿数据时都会加锁。例如行锁、表锁、读锁、写锁等。</li><li><strong>乐观锁</strong>:认为并发操作是小概率事件，不对操作加锁，而是在更新时判断在此期间数据有没有被改动。可以通过版本号或CAS机制实现。（JUC的atomic就是通过CAS实现的）</li></ul><p>悲观锁和乐观锁是锁的设计思想，而不是具体的某个锁。</p><p><strong>乐观锁版本号机制</strong></p><p>在表中设计一个<code>version</code>字段，对行数据的更新操作执行都执行以下步骤:</p><ol><li>读取行数据和<code>version</code>的值。</li><li>在内存中对行数据进行操作。</li><li>再次读取<code>version</code>的值。</li><li>将<code>version</code>在3中的值与1中的值进行比较，如果相同则将行数据更新到磁盘，并且把磁盘中的<code>version</code>值+1；如果不同则从1重新开始。</li></ol><p><strong>两种锁的适用场景</strong></p><ul><li>乐观锁:适合读多写少。</li><li>悲观锁:适合写多读少。</li></ul><h4 id="从加锁的方式划分"><a href="#从加锁的方式划分" class="headerlink" title="从加锁的方式划分"></a>从加锁的方式划分</h4><ul><li><strong>显式锁</strong>:（存储引擎或数据库自动生成、手动添加）创建锁结构来起到锁的作用。</li><li><strong>隐式锁</strong>:不创建锁结构，也可以起到锁的作用。</li></ul><p>隐式锁的主要应用 场景是插入语句。每条行记录（聚簇索引的叶子节点）中都有一个<code>trx_id</code>属性，表示最近对这条记录进行操作的事务的id。如果有事务2要对这条数据添加锁，会先看这条记录的<code>trx_id</code>表示的事务1是否处于活跃状态。如果是，则表明该条数据还在被事务1操作中，那么事务2会帮其创建一个锁，并且自身进入等待事务1的状态中。这种情况就是隐式锁转化为显式锁。</p><blockquote><p>参考:<a href="https://zhuanlan.zhihu.com/p/408491837">MySQL InnoDB隐式锁功能解析 - 知乎 (zhihu.com)</a></p></blockquote><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>对整个数据库进行加锁，让整个库处于只读状态。</p><p>使用场景:全库逻辑备份。</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>两个事务互相持有对方需要的锁，并且等待对方释放，双方都不会释放自己的锁。</p><p><strong>产生死锁的必要条件</strong></p><ol><li>两个或以上的事务</li><li>每个事务都已经持有锁并且申请新的锁</li><li>锁资源同时只能被同一个事务持有或者不兼容</li><li>事务之间因为持有锁和申请锁导致彼此循环等待</li></ol><p>死锁的关键在于每个事务加锁的顺序不一致。如果一致，不会形成死锁。</p><p><strong>解决死锁的方法</strong></p><ol><li><p>等待，直到超时</p><p>两个事务相互等待时，当一个事务等待事件超过阈值时，就将其回滚，从而释放锁，让另一个事务继续执行。通过<code>innodb_lock_wait_timeout</code>设置等待时间，默认50s。</p><p>缺点:等待时间不好设置，太长影响业务正常执行，太短容易误伤正常事务的的等待。</p></li><li><p>使用死锁检测进行处理 </p><p>使用<strong>wait-for graph</strong>算法检测死锁。<code>innodb_deadlock_detect</code>开启或关闭。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207261852514.png" alt="image-20220726185209386"></p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207261852388.png" alt="image-20220726185235302"></p><p>构建出以事务为点，锁为边的有向图，如果图中存在环，则存在死锁。innobb引擎就会选择回滚undo量最小的事务，让其他事务继续执行。</p><p>缺点:算法本身需要耗费时间，如果同时并发的事务太多，会影响性能。</p><p>解决方法:用其他中间件对更新相同行的操作进行排队。</p></li></ol><p><strong>如何避免死锁</strong></p><ul><li>合理设计索引，使业务SQL尽可能通过索引定位更少的行，减少锁竞争。</li><li>调整业务SQL执行顺序，避免update&#x2F;delete等长时间持有锁的SQL在事务前面。</li><li>避免大事务，尽量拆分成多个小事务处理。</li><li>降低隔离级别。</li><li>在并发高的场景下不要在事务中手动加锁。</li></ul><blockquote><p>参考:<a href="https://blog.csdn.net/AlbenXie/article/details/118613349">彻底搞懂MySQL死锁_AlbenXie的博客-CSDN博客_mysql死锁</a></p></blockquote><h3 id="锁的内存结构"><a href="#锁的内存结构" class="headerlink" title="锁的内存结构"></a>锁的内存结构</h3><p>给一条记录加锁的本质就是在内存中创建一个与之关联的锁结构。</p><p>加锁时，并不会对每条记录都创建一个锁结构，而是为了节约空间，将满足一些条件的记录都用同一个锁结构表示:</p><ul><li>同一个事务中的加锁操作</li><li>被加锁的记录在同一个页中</li><li>加锁的类型一样</li><li>等待状态一样</li></ul><img src="./202207270401943.png" alt="image-20220727040106822" style="zoom: 67%;" /><p><strong>结构解析</strong></p><ol><li><p>锁所在的事务信息:记录锁的基础信息的指针。</p></li><li><p>索引信息:（行锁特有）记录加锁的记录的索引信息的指针。</p></li><li><p>表锁&#x2F;行锁信息:</p><ul><li>表锁:记录当前表和一些其他信息。</li><li>行锁:记录当前行所在的表空间(Space ID)、页号(Page Number)、行标记(n_bits)。</li></ul></li><li><p>type_mode:</p><p>一个32位的数，被分为 <code>lock_mode</code> 、<code>lock_type</code> 、<code>rec_lock_type</code> 三个部分。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207270450178.png" alt="image-20220727045009059"></p><ul><li><p>lock_mode:表示当前锁的模式</p><ul><li>LOCK_IS（十进制的0）:表示共享意向锁，也就是IS锁。 </li><li>LOCK_IX（十进制的1）:表示独占意向锁，也就是IX锁。 </li><li>LOCK_S（十进制的2）:表示共享锁，也就是S锁。 </li><li>LOCK_X（十进制的3）:表示独占锁，也就是X锁。 </li><li>LOCK_AUTO_INC（十进制的4）:表示AUTO-INC锁。</li></ul></li><li><p>lock_type:表示当前锁的类型</p><ul><li>LOCK_TABLE（十进制的1，即第1个bit为1）:表示表级锁</li><li>LOCK_REC（十进制的2，即第2个bit为1）:表示行级锁</li></ul></li><li><p>rec_lock_type:行锁的具体类型</p><ul><li>LOCK_ORDINARY（十进制的0）:表示next-key锁。 </li><li>LOCK_GAP（十进制的512，即第10个bit为1）:表示gap锁。 </li><li>LOCK_REC_NOT_GAP（十进制的1024，即第11个bit为1）:表示记录锁。</li><li>LOCK_INSERT_INTENTION（十进制的2048，即第11个bit为1）:表示插入意向锁。</li><li>补充:十进制的1，即第1个bit为1时，表示is_waiting&#x3D;true，即当前事务处在等待状态，尚未获取到锁；为0时，表示is_waiting&#x3D;false，即当前事务获取锁成功。</li></ul></li></ul></li><li><p>其他信息:为了更好的管理各种锁结构而设计的哈希表和链表。</p></li><li><p>比特位:如果是行锁结构的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的n_bits属性表示的。InnoDB数据页中的每条记录在记录头信息中都包含一个 heap_no 属性，伪记录Infimum的heap_no值为0，Supremum的heap_no值为1，之后每插入一条记录，heap_no值就增1。锁结构最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个heap_no，即一个比特位映射到页内的一条记录。</p></li></ol><h3 id="锁的监控"><a href="#锁的监控" class="headerlink" title="锁的监控"></a>锁的监控</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &#x27;innodb_row_lock%&#x27;;</span><br></pre></td></tr></table></figure><ul><li><code>Innodb_row_lock_current_waits</code>:当前正在等待锁定的数量；</li><li><code>Innodb_row_lock_time</code>:从系统启动到现在锁定总时间长度；（等待总时长）</li><li><code>Innodb_row_lock_time_avg</code>:每次等待所花平均时间；（等待平均时长）</li><li><code>Innodb_row_lock_time_max</code>:从系统启动到现在等待最常的一次所花的时间；</li><li><code>Innodb_row_lock_waits</code>:系统启动后到现在总共等待的次数；（等待总次数）</li></ul><p><strong>其他监控方法:</strong></p><p>MySQL把事务和锁的信息记录在了<code>information_schema</code>库中，涉及到的三张表分别是<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>。 </p><p>MySQL5.7及之前，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p><p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了<code>performance_schema.data_locks</code>，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p><p>同时，information_schema.INNODB_LOCK_WAITS也被<code>performance_schema.data_lock_waits</code>所代替。</p><h2 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h2><blockquote><p>参考:<a href="https://juejin.cn/post/7056583607929798692">MySQL 如何解决幻读（MVCC 原理分析） - 掘金 (juejin.cn)</a></p></blockquote><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>MVCC（Multiversion Concurrency Control），多版本并发控制。通过数据行的多个版本管理来实现数据库的并发控制。相比于用锁来实现并发控制，MVCC的并发能力更高（只有写-写之间相互阻塞），但是无法保证读出的数据是最新版本。</p><p><strong>快照读和当前读</strong></p><ul><li><p>快照读</p><p>又叫一致性读，读取的是快照数据而不是实时的最新数据。不会与写操作冲突。<strong>不加锁的简单的SELECT都是快照读</strong>。快照读的幻读由MVCC解决。</p></li><li><p>当前读</p><p>读取的是最新版本，与写操作冲突，要保证读取过程中其他并发事务不能修改当前记录。<strong>加锁的SELECT或增删改操作都会执行当前读</strong>。当前读的幻读由临键锁解决。</p></li></ul><h3 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h3><p>MVCC实现依赖于:版本链（trx_id和roll_pointer）、Undo日志、ReadView</p><h4 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h4><p>之前讲过在InnoDB行格式中，每个聚簇索引都包含三个隐藏列</p><table><thead><tr><th>列名</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>创建的表中有主键或者非 NULL的 UNIQUE 键时都不会包含 row_id 列</td></tr><tr><td><strong>trx_id</strong></td><td>是</td><td>事务ID，每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务 id 赋值给 trx_id 隐藏列</td></tr><tr><td><strong>roll_pointer</strong></td><td>是</td><td>回滚指针，每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo 日志中，然后用 roll_pointer 指向这个旧的版本。同时，旧的版本也会有一个自己的 roll_pointer 指向更旧的一个版本。</td></tr></tbody></table><p>每次对记录进行改动，都会生成一条 undo 日志，每条 undo 日志也都有一个 roll_pointer 属性（INSERT 操作对应的 undo 日志没有该属性，因为该记录并没有更早的版本），可以将这些 undo 日志都连起来，串成一个链表，就是版本链。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207272341026.webp" alt="image-20211209091759865"></p><h4 id="Undo日志"><a href="#Undo日志" class="headerlink" title="Undo日志"></a>Undo日志</h4><p>Undo日志除了可以保证事务在<code>rollback</code>时的原子性和一致性，还可以用于存放MVCC的快照读的数据。</p><h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p>上面说到，改动的记录都在undo日志中，那如何选择到底读取哪个版本的记录呢？</p><ul><li>对于使用 <code>READ UNCOMMITTED</code> 隔离级别的事务来说，由于<strong>可以读到未提交事务修改过的记录</strong>，所以直接读取记录的最新版本就好了。</li><li>对于使用 <code>SERIALIZABLE</code> 隔离级别的事务来说，InnoDB 使用<strong>加锁的方式来访问记录</strong>，不存在并发问题。</li><li>对于使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务来说，都<strong>必须保证读到</strong>已经<strong>提交</strong>了的事务修改过的记录，也就是说<strong>假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的</strong>。</li></ul><p>核心问题就是:<code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别在不可重复读和幻读上的区别在哪里？这两种隔离级别对应的<strong>不可重复读</strong>与<strong>幻读</strong>都是指<strong>同一个事务</strong>在两次读取记录时出现<strong>不一致</strong>的情况，<strong>这两种隔离级别关键是需要判断版本链中的哪个版本是当前事务可见的</strong>。</p><p>ReadView 就可以用来帮助我们解决可见性问题。事务进行<strong>快照读</strong>操作的时候就会产生 ReadView，它保存了<strong>当前事务开启时所有活跃的事务列表</strong>（活跃指的是未提交的事务）。</p><p>ReadView中主要保存了以下几个比较重要的内容:</p><ol><li><code>creator_trx_id</code>，创建这个 ReadView 的事务 ID。</li></ol><blockquote><p>说明:只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。 </p></blockquote><ol start="2"><li><p><code>m_ids</code>，生成 ReadView 时当前系统中活跃的读写事务的事务 id 列表。 </p></li><li><p><code>min_trx_id</code>，生成 ReadView 时当前系统中活跃的读写事务中最小的事务 id 也就是 m_ids 中的最小值。 </p></li><li><p><code>max_trx_id</code>，表示生成ReadView时系统中应该分配给下一个事务的id值。</p></li></ol><blockquote><p>注意:<code>max_trx_id</code> 并不是 <code>m_ids</code> 中的最大值，事务id是递增分配的。比如，现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。</p></blockquote><p>在有了 ReadView 之后，在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见:</p><ol><li><p><code>trx_id = creator_trx_id</code> ，<strong>可访问</strong></p><p>如果被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</p></li><li><p><code>trx_id &lt; min_trx_id</code> ，<strong>可访问</strong></p><p>如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。</p></li><li><p><code>trx_id &gt;= max_trx_id</code> ，<strong>不可访问</strong></p><p>如果被访问版本的 trx_id 属性值大于或等于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问。</p></li><li><p><code>min_trx_id &lt;= trx_id &lt; max_trx_id</code>，并且存在 <code>m_ids</code> 列表中，<strong>不可访问</strong></p><p>如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下 trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</p></li><li><p>某个版本的数据对当前事务不可见</p><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p></li></ol><p>在 MySQL 中，READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们<strong>生成 ReadView 的时机不同</strong>。</p><p>当事务处在READ COMMITTED中，<strong>事务中的每条读语句都会重新生成一个ReadView</strong>，这意味着历史版本对于这个事务的读操作是会不断变化的，因此有可能导致连续的两次读取内容不同，也就是不可重复读。</p><p>当事务处在REPEATABLE READ中，<strong>事务中只有第一条读语句会生成一个ReadView</strong>，后面的所有读操作都会沿用第一次的ReadView，从而保证每次读取的内容都一致。这样也就一次性解决了不可重复读和幻读的问题。</p><blockquote><p>需要注意的一点:因为ReadView是只对快照读生效的，所以MVCC并不能完全解决幻读问题。当前读的幻读问题需要<code>Next-key Locks</code>解决。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MVCC在可重复读的隔离级别下解决了以下问题:</p><ol><li>通过历史版本，让读-写操作可以并发执行，提高了并发效率。</li><li>解决了脏读、不可重复读、（快照读情况下）幻读。</li></ol><h2 id="其他数据库日志"><a href="#其他数据库日志" class="headerlink" title="其他数据库日志"></a>其他数据库日志</h2><blockquote><p>参考:[<a href="https://zhuanlan.zhihu.com/p/58011817">玩转MySQL之八]MySQL日志分类及简介 - 知乎 (zhihu.com)</a></p></blockquote><p>在MySQL中，除了之前提到的Redo日志和Undo日志外，还有一些其他不同功能的日志。</p><ul><li><strong>慢查询日志</strong>:记录所有执行时间超过<code>long_query_time</code>的查询。</li><li><strong>通用查询日志</strong>:记录所有链接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令。</li><li><strong>错误日志</strong>:记录MySQL服务的启动、运行、停止时遇到的各种错误。</li><li><strong>二进制日志</strong>:记录所有更改数据的语句，用于主从服务器之间的数据同步，以及服务器遇到故障后的恢复。</li><li><strong>中继日志</strong>:用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件（MySQL8.0以后新增）。</li><li><strong>数据定义语言日志</strong>:记录数据定义语句执行的元数据操作（MySQL8.0以后新增）。</li></ul><p>除了二进制日志，其他日志都是文本文件。默认情况下，所有日志都创建在MySQL数据目录中。</p><h3 id="慢查询日志-1"><a href="#慢查询日志-1" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>前面性能分析工具写过了，不再赘述。</p><h3 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h3><p>通用查询日志用来记录用户的所有操作，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。</p><p>由于通用查询日志记录的数据非常多，因此只建议在测试环境下开启。</p><p><strong>查看当前通用查询日志的状态</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%general_log%&#x27;;</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">| Variable_name    | Value                        |</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">| general_log      | OFF                          |</span><br><span class="line">| general_log_file | /var/lib/mysql/DB-Server.log |</span><br><span class="line">+------------------+------------------------------+</span><br></pre></td></tr></table></figure><ul><li>参数<code>general_log</code>用来控制开启、关闭MySQL查询日志</li><li>参数<code>general_log_file</code>用来控制查询日志的位置</li></ul><p><strong>设置通用查询日志的存储方式</strong></p><p>可以通过<code>log_output</code>设置通用查询日志的存储方式:</p><ul><li><code>FILE</code>:表示日志存储在文件中。</li><li><code>TABLE</code>:表示日志存储在mysql库中的<code>general_log表</code>中。</li><li><code>FILE, TABLE</code>:表示将日志同时存储在文件和<code>general_log表</code>中，会徒增很多IO压力，一般不会这样设置。</li><li><code>NONE</code>:表示不记录日志，即使<code>general_log</code>设置为ON，如果<code>log_output</code>设置为NONE，也不会记录查询日志。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;log_output&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| log_output    | FILE  |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure><blockquote><p>注意:<code>log_output</code>参数不止用于设置通用查询日志的存储方式，也同样会影响慢查询日志。</p></blockquote><p><strong>开启&#x2F;关闭通用查询日志</strong></p><ul><li><p>方法一:修改<code>my.cnf</code>配置文件，需要重启MySQL服务，修改后永久生效。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">general_log</span> = <span class="number">1</span>/<span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>方法二:命令行设置，重启后会失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global general_log = 1/0</span><br></pre></td></tr></table></figure></li></ul><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志默认开启，并且无法被关闭。默认情况下，错误日志存储在数据库的数据文件目录中，名称为<code>hostname.err</code>，其中，hostname为服务器主机名。</p><p><strong>查看错误日志配置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;log_err%&#x27;;</span><br><span class="line">+----------------------------+----------------------------------------+</span><br><span class="line">| Variable_name              | Value                                  |</span><br><span class="line">+----------------------------+----------------------------------------+</span><br><span class="line">| log_error                  | ./fengye.err                           |</span><br><span class="line">| log_error_services         | log_filter_internal; log_sink_internal |</span><br><span class="line">| log_error_suppression_list |                                        |</span><br><span class="line">| log_error_verbosity        | 2                                      |</span><br><span class="line">+----------------------------+----------------------------------------+</span><br></pre></td></tr></table></figure><p><strong>删除错误日志</strong></p><p>MySQL5.5.7之前，可以用<code>mysqladmin –u root –pflush-logs</code>命令，直接将旧文件重命名为<code>filename.err._old</code>，并创建新文件；从MySQL5.5.7开始，只能手动重命名后，开启一个新的错误日志文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@fengye data]# mv fengye404.err  fengye404.err._old</span><br><span class="line">[root@fengye data]# mysqladmin flush-logs</span><br></pre></td></tr></table></figure><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><blockquote><p>参考:<a href="https://www.cnblogs.com/Presley-lpc/p/9619571.html">mysql binlog详解 - Presley - 博客园 (cnblogs.com)</a></p></blockquote><p>MySQL的二进制日志（binary log）是一个二进制文件，主要记录所有数据库表结构变更（例如CREATE、ALTER TABLE…）以及表数据修改（INSERT、UPDATE、DELETE…）的所有操作，并且记录了语句发生时间、执行时长、操作数据等其它额外信息。</p><p><strong>binlog的应用场景</strong></p><ul><li>数据恢复:如果MySQL服务意外停止，可以通过binlog来恢复。</li><li>数据复制:主数据库向从数据库复制数据。</li></ul><p><strong>binlog和redolog的区别</strong></p><ol><li>redolog由InnoDB产生；binlog由MySQL数据库产生。</li><li>redolog是物理日志，记录了”某个页上做了什么修改“；biglog是逻辑日志，存储对应的SQL语句。</li><li>redolog的空间是固定的，循环写入；binlog空间没有限制，追加写入。</li><li>redolog一般对于用户不可见，由存储引擎维护并保证数据库崩溃时事务的持久性；binlog用于人工恢复数据。</li></ol><p><strong>查看binlog配置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%log_bin%&#x27;;</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| Variable_name                   | Value                            |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br><span class="line">| log_bin                         | ON                               |</span><br><span class="line">| log_bin_basename                | /www/server/data/mysql-bin       |</span><br><span class="line">| log_bin_index                   | /www/server/data/mysql-bin.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF                              |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF                              |</span><br><span class="line">| sql_log_bin                     | ON                               |</span><br><span class="line">+---------------------------------+----------------------------------+</span><br></pre></td></tr></table></figure><ul><li>log_bin:是否开启binlog，MySQL8默认开启</li><li>log_bin_basename:binlog日志不止一个文件，由多个文件组成（每次MySQL重启都会创建一个新的binlog）。这个参数表示binlog的基本文件名，每个文件后面都会追加标识来表示每个文件。</li><li>log_bin_index:binlog文件的索引文件。由于binlog可能包含很多文件，因此需要一个索引来管理。</li><li>log_bin_trust_function_creators:是否可以创建存储过程。（具体参考:<a href="https://www.cnblogs.com/kerrycode/p/7641835.html">MySQL参数log_bin_trust_function_creators介绍 - 潇湘隐者 - 博客园 (cnblogs.com)</a>）</li></ul><p><strong>修改binlog配置</strong></p><ul><li><p>方法一:修改<code>my.cnf</code>配置文件，需要重启MySQL服务，修改后永久生效。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">log-bin</span>=fengye404-bin</span><br><span class="line"><span class="comment"># binlog的基础文件名，当带上路径时，也会同时指定文件存放的路径</span></span><br><span class="line"><span class="attr">binlog_expire_logs_seconds</span>=<span class="number">3600</span></span><br><span class="line"><span class="comment"># binlog文件的过期时间，单位是秒，超过时间后会删除，不设置默认30天</span></span><br><span class="line"><span class="attr">max_binlog_size</span>=<span class="number">100</span>M</span><br><span class="line"><span class="comment"># 单个binlog文件的大小，超过大小时会自动创建新的文件，不设置默认1GB</span></span><br></pre></td></tr></table></figure></li><li><p>方法二:命令行设置，重启后会失效（不支持global，只支持session）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET sql_log_bin=0; </span><br></pre></td></tr></table></figure></li></ul><p><strong>查看binlog列表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binary logs;</span><br><span class="line">+------------------+-----------+-----------+</span><br><span class="line">| Log_name         | File_size | Encrypted |</span><br><span class="line">+------------------+-----------+-----------+</span><br><span class="line">| mysql-bin.000014 |  21784592 | No        |</span><br><span class="line">| mysql-bin.000015 |  11311449 | No        |</span><br><span class="line">+------------------+-----------+-----------+</span><br></pre></td></tr></table></figure><p><strong>查看binlog内容</strong></p><p>由于binlog是二进制文件，无法直接查看，需要借助<code>mysqlbinlog</code>命令工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog &quot;/www/server/data/mysql/mysql-bin.000015&quot;</span><br></pre></td></tr></table></figure><p>除了使用mysqlbinlog工具，还可以使用下面这种更加方便的查询命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binlog events [IN &#x27;log_name&#x27;] [FROM pos] [LIMIT [offset,] row_count];</span><br></pre></td></tr></table></figure><ul><li><code>IN &#39;log_name&#39;</code>:指定要查询的binlog文件名（不指定就是第一个binlog文件）　</li><li><code>FROM pos</code>:指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）</li><li><code>LIMIT [offset]</code>:偏移量(不指定就是0) </li><li><code>row_count</code>:查询总条数（不指定就是所有行）</li></ul><p>例子:<code>show binlog events in &quot;/www/server/data/mysql/mysql-bin.000015&quot;;</code></p><p><strong>查看binlog格式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;binlog_format&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| binlog_format | MIXED |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure><ul><li><p>STATEMENT:记录每一条修改数据的SQL语句。</p><p>优点:不需要记录每一行的变化，减少了binlog的日志量，节约IO，提高性能。</p></li><li><p>ROW:不记录SQL语句，而是记录那些行被修改。</p><p>优点:清楚地记录每一行数据修改地细节，不会出现某些特定情况下存储过程、函数、trigger的调用导致的无法正确复制的问题。</p></li><li><p>MIXED:Statement和Row的结合</p></li></ul><p><strong>使用binlog恢复数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [option] &lt;filename&gt; | mysql –u [username] -p [password] -v [database];</span><br></pre></td></tr></table></figure><ul><li>filename:文件完整路径</li><li>option:可选参数。比较重要的两对option参数是–start-date、–stop-date 和 –start-position、– stop-position。 <ul><li><code>--start-date</code> 和 <code>--stop-date</code>:可以指定恢复数据库的起始时间点和结束时间点。</li><li><code>--start-position</code> 和 <code>--stop-position</code>:可以指定恢复数据的开始位置和结束位置。</li></ul></li><li>username、password、database:用户名、密码、指定的数据库</li></ul><blockquote><p>注意:使用binlog恢复数据的同时，也相当于对数据库中的数据进行改动。因此恢复数据的操作也会被同时写入binlog。因此在恢复之前最好使用<code>flush logs</code>重新开启一个新的binlog文件。</p></blockquote><p><strong>删除binlog文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;PURGE &#123;MASTER | BINARY&#125; LOGS TO &#x27;指定日志文件名&#x27;;</span><br><span class="line"># 删除指定文件之前的（不包括指定文件）文件</span><br><span class="line">mysql&gt;PURGE &#123;MASTER | BINARY&#125; LOGS BEFORE &#x27;指定日期&#x27;;</span><br></pre></td></tr></table></figure><h3 id="中继日志"><a href="#中继日志" class="headerlink" title="中继日志"></a>中继日志</h3><p><strong>中继日志只在主从服务器架构的从服务器上存在</strong>。从服务器为了与主服务器保持一致，要从主服务器读取binlog的内容，并且把读取到的信息写入本地的日志文件中，这个从服务器本地的日志文件就叫<strong>中继日志</strong>。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的数据同步。</p><p>文件名格式:<code>从服务器名 -relay-bin.序号</code>。中继日志也有一个索引文件<code>从服务器名 -relay-bin.index</code></p><p>中继日志的格式与二进制日志相同，也需要用<code>mysqlbinlog</code>查看</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><blockquote><p>参考:<a href="https://zhuanlan.zhihu.com/p/164518315">小白都能懂的Mysql主从复制原理（原理+实操） - 知乎 (zhihu.com)</a></p></blockquote><p>在实际的生产环境中，一般都是读多写少，为了提高性能，会采用主从复制的方式进行<strong>读写分离</strong>。即在主数据库（master）中写入数据，从数据库（slave）中读取数据。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>主从复制的过程主要由三个线程参与:</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207290419731.png" alt="image-20220729041909576"></p><ul><li>master（binlog dump thread）:主库线程，主库数据更新时，将更新事件写入主库的binlog，并且通知从库数据有更新。</li><li>slave（I&#x2F;O thread）:从库线程，读取主库的binlog并写入从库的relay log。</li><li>slave（SQL thread）:从库线程，读取从库的relay log并执行SQL语句，将数据更新到从库的表中。</li></ul><blockquote><p>注意:要实现主从复制，必须要求主库开启binlog</p></blockquote><h3 id="搭建主从复制"><a href="#搭建主从复制" class="headerlink" title="搭建主从复制"></a>搭建主从复制</h3><h4 id="主机配置文件"><a href="#主机配置文件" class="headerlink" title="主机配置文件"></a>主机配置文件</h4><p>my.cnf</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># [必选] 主服务器唯一ID</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [必选] 启用binlog，并指定基础文件名，当带上路径时，也会同时指定文件存放的路径</span></span><br><span class="line"><span class="attr">log-bin</span>=fengye404</span><br><span class="line"></span><br><span class="line"><span class="comment"># [可选] 0（默认）表示读写（主机），1表示只读（从机）</span></span><br><span class="line"><span class="attr">read-only</span>=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [可选] binlog保留时长，单位为秒，不填默认30天</span></span><br><span class="line"><span class="attr">binlog_expire_logs_seconds</span>=<span class="number">6000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [可选] 单个binlog文件最大大小，默认1GB</span></span><br><span class="line"><span class="attr">max_binlog_siez</span>=<span class="number">200</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># [可选] 忽略的数据库，一般忽略mysql自带的数据库</span></span><br><span class="line"><span class="attr">binlog-ignore-db</span>=mysql</span><br><span class="line"><span class="attr">binlog-ignore-db</span>=information_schema</span><br><span class="line"><span class="attr">binlog-ignore-db</span>=performance_schema</span><br><span class="line"><span class="attr">binlog-ignore-db</span>=sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># [可选] 记录binlog的数据库，默认全部</span></span><br><span class="line"><span class="attr">binlog-do-db</span>=test</span><br><span class="line"></span><br><span class="line"><span class="comment"># [可选] 设置binlog格式</span></span><br><span class="line"><span class="attr">binlog_format</span>=MIXED</span><br></pre></td></tr></table></figure><h4 id="从机配置文件"><a href="#从机配置文件" class="headerlink" title="从机配置文件"></a>从机配置文件</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># [必选] 从服务器唯一ID</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [必选] 启用relaylog，并指定基础文件名，当带上路径时，也会同时指定文件存放的路径</span></span><br><span class="line"><span class="attr">relay-log</span>=fengye404</span><br><span class="line"></span><br><span class="line"><span class="comment"># [可选] 0（默认）表示读写（主机），1表示只读（从机）</span></span><br><span class="line"><span class="attr">read-only</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure><p><del>由于每台服务器的情况不同，剩下的部分自己实操吧，懒得写了</del></p><h3 id="主从复制的一致性问题"><a href="#主从复制的一致性问题" class="headerlink" title="主从复制的一致性问题"></a>主从复制的一致性问题</h3><p>根据上面讲的主从复制的原理，很容易想象到，其实主库和从库的内容不是实时同步的，其中可能会由于一些网络传输问题而存在一定的延迟。这样就会造成读写分离时读库的数据不是最新数据，也就是会发生主从同步中的数据不一致问题。按照数据一致性从弱到强，有三种数据同步策略。</p><h4 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h4><p>主库开启事务，更新完数据后可以直接提交，不需要等从库返回任何结果。</p><p>优点是不会影响主库写的效率，缺点是数据一致性弱。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207290510311.png" alt="image-20220729051055180"></p><h4 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h4><p>主库开启事务，更新完数据后可以必须等待至少一个从库接收到了binlog并写入到中继日志中后，才能提交。可以通过<code>rpl_semi_sync_master_wait_for_slave_count</code>参数设置需要多少个从库响应。</p><p>优点是数据一致性相比于异步复制提高了很多，缺点是主库的写入性能收到影响</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207300413690.png" alt="image-20220730041329574"></p><h4 id="组复制"><a href="#组复制" class="headerlink" title="组复制"></a>组复制</h4><p>半同步复制虽然一定程度上提高了数据的一致性，但是由于其需要从库响应来判断是否提交，所以无法满足对数据一致性要求很高的场景。</p><p>组复制技术，简称MGR（MySQL Group Replication），是MySQL5.7.17以后推出的新的数据复制技术，是基于Paxos协议的状态机复制。</p><p>首先我们将多个节点共同组成一个复制组，在执行读写事务的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于 （N&#x2F;2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对只读事务则不需要经过组内同意，直接 COMMIT 即可。</p><p><img src="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/202207300423661.png" alt="image-20220730042308542"></p><blockquote><p>全文大致参考:<a href="https://www.bilibili.com/video/BV1iq4y1u7vj">MySQL数据库教程_bilibili</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Weather-Forecast</title>
      <link href="/2022/02/16/Weather-Forecast/"/>
      <url>/2022/02/16/Weather-Forecast/</url>
      
        <content type="html"><![CDATA[<h1 id="Weather-Forecast"><a href="#Weather-Forecast" class="headerlink" title="Weather-Forecast"></a>Weather-Forecast</h1><p>部署地址：<a href="fengye404.top/weather">fengye404.top&#x2F;weather</a></p><p>github：<a href="https://github.com/fengye404/weather-forecast">fengye404&#x2F;weather-forecast: SAST.2022-FrontEnd-WoC (github.com)</a></p><p>SAST.2022 前端组的 WoC (Winter of Code)项目，技术栈： React + Semi Design </p><p>也是我自己第一次摸前端的项目，从 0 学三大件到学 React 、拼组件、调CSS，前前后后花了差不多有一个多星期。仿佛回到了去年寒假第一次学后端，虽说遇到的困难很多，但是做出来还是挺有成就感的。</p><p>其实还有好多想法由于时间原因没有实现，比如：</p><p>1、获取客户端地址，直接回调天气 api 。<del>之前用了搜狐的 api 本来写好了，但是部署完发现获取的是服务端的，直接寄（</del></p><p>2、加载过程中显示骨架屏幕</p><p>3、布局做到兼容多端。<del>布局太难了，摆烂</del></p><p>4、找个更好的天气API。<del>目前的API数据量太少，而且经常容易出bug（</del></p><p>做完还是发现后端适合自己。</p><p>前端，我劝你别学！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS虚化背景图片并解决白边</title>
      <link href="/2022/02/14/CSS%E8%99%9A%E5%8C%96%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E5%B9%B6%E8%A7%A3%E5%86%B3%E7%99%BD%E8%BE%B9/"/>
      <url>/2022/02/14/CSS%E8%99%9A%E5%8C%96%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E5%B9%B6%E8%A7%A3%E5%86%B3%E7%99%BD%E8%BE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS虚化背景图片并去掉白边"><a href="#CSS虚化背景图片并去掉白边" class="headerlink" title="CSS虚化背景图片并去掉白边"></a>CSS虚化背景图片并去掉白边</h1><p>直接上代码</p><p>App.jsx</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Layout</span>&#125; <span class="keyword">from</span> <span class="string">&quot;@douyinfe/semi-ui&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./App.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;<span class="title class_">Header</span>, <span class="title class_">Footer</span>, <span class="title class_">Content</span>&#125; = <span class="title class_">Layout</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Layout</span> <span class="attr">className</span>=<span class="string">&#123;</span>&quot;<span class="attr">layout</span>&quot;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&quot;<span class="attr">background</span>&quot;&#125;/&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Header</span>&gt;</span>Header<span class="tag">&lt;/<span class="name">Header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Content</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Footer</span>&gt;</span>Footer<span class="tag">&lt;/<span class="name">Footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>App.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.background</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vw</span>;<span class="comment">/*设置宽为屏幕宽度*/</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;<span class="comment">/*设置高为屏幕高度*/</span></span><br><span class="line">    <span class="attribute">position</span>: fixed;<span class="comment">/*固定位置*/</span></span><br><span class="line">    <span class="attribute">z-index</span>: -<span class="number">1</span>;<span class="comment">/*置于下层*/</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;../public/枝江往事.jpg&quot;</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>: center;</span><br><span class="line">    <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">    <span class="attribute">background-size</span>:cover;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">3px</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.02</span>);<span class="comment">/*放大，去掉白边*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.clloz.com/programming/front-end/css/2019/05/23/blur-white-border/">去掉模糊背景或图片的白边 – Clloz ☘️</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nps搭建内网穿透</title>
      <link href="/2022/02/10/nps%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2022/02/10/nps%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在玩 MC ，买了个 腾讯云2核4G 的服务器跑 MC 服务端，但是 mod 加多了之后还是有点卡，于是就用了个老的电脑搭建服务器，之前的买的服务器用来搭建内网穿透服务端。</p><p>一开始使用的是 frp ，后来被安利了 nps，因为有 web gui ，使用起来更友好一点。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>服务端是买的 腾讯云2核4G 服务器</p><p>centos7 x86_64</p><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/ehang-io/nps/releases/download/v0.26.10/linux_amd64_server.tar.gz</span><br></pre></td></tr></table></figure><h5 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf linux_amd64_server.tar.gz</span><br></pre></td></tr></table></figure><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nps install</span><br></pre></td></tr></table></figure><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nps start</span><br></pre></td></tr></table></figure><p>启动后就可以访问了，默认： <a href="http://ip:8080/">http://ip:8080</a></p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>客户端是老的笔记本</p><p>windows10 64</p><p>手动下载解压后，文件结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">│ npc.exe</span><br><span class="line">│</span><br><span class="line">└─conf</span><br><span class="line">        multi_account.conf</span><br><span class="line">        npc.conf</span><br></pre></td></tr></table></figure><h5 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h5><p>配置文件启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\npc.exe -config=[npc.conf的路径]</span><br></pre></td></tr></table></figure><h3 id="NPS-搭建-MC-服务端的栗子"><a href="#NPS-搭建-MC-服务端的栗子" class="headerlink" title="NPS 搭建 MC 服务端的栗子"></a>NPS 搭建 MC 服务端的栗子</h3><p>服务端新建客户端</p><p><img src="http://fengye404.top/wp-content/uploads/2022/03/35JFL@@OI1ANATO7LACGM-1.png" alt="img"></p><p>修改客户端配置文件 npc.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr=服务端IP:8024   ## 客户端命令中的 -server</span><br><span class="line">conn_type=tcp</span><br><span class="line">vkey=0u9xlw0311yelu4s      ## 客户端命令中的 -vkey</span><br><span class="line">auto_reconnection=true</span><br><span class="line">max_conn=1000</span><br><span class="line">flow_limit=1000</span><br><span class="line">rate_limit=1000</span><br><span class="line">basic_username=11</span><br><span class="line">basic_password=3</span><br><span class="line">web_username=user</span><br><span class="line">web_password=1234</span><br><span class="line">crypt=true</span><br><span class="line">compress=true</span><br><span class="line">#pprof_addr=0.0.0.0:9999</span><br><span class="line">disconnect_timeout=60</span><br><span class="line"></span><br><span class="line">[health_check_test1]</span><br><span class="line">health_check_timeout=1</span><br><span class="line">health_check_max_failed=3</span><br><span class="line">health_check_interval=1</span><br><span class="line">health_http_url=/</span><br><span class="line">health_check_type=http</span><br><span class="line">health_check_target=127.0.0.1:8083,127.0.0.1:8082</span><br><span class="line"></span><br><span class="line">[health_check_test2]</span><br><span class="line">health_check_timeout=1</span><br><span class="line">health_check_max_failed=3</span><br><span class="line">health_check_interval=1</span><br><span class="line">health_check_type=tcp</span><br><span class="line">health_check_target=127.0.0.1:8083,127.0.0.1:8082</span><br><span class="line"></span><br><span class="line">[mcsm]</span><br><span class="line">mode=tcp</span><br><span class="line">target_addr=127.0.0.1:23333    # MCSM web页面</span><br><span class="line">server_port=10000</span><br><span class="line"></span><br><span class="line">[mc]</span><br><span class="line">mode=tcp</span><br><span class="line">target_addr=127.0.0.1:25565    # MC</span><br><span class="line">server_port=10001</span><br><span class="line"></span><br><span class="line">[mcsm daemon]</span><br><span class="line">mode=tcp</span><br><span class="line">target_addr=127.0.0.1:24444    # MCSM 的守护进程</span><br><span class="line">server_port=10002</span><br></pre></td></tr></table></figure><p>MCSM 新建守护进程</p><p>ip 填 nps 服务端的 ip</p><p><img src="http://fengye404.top/wp-content/uploads/2022/03/L8INDAXU8V94Q9OACKE.png" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker笔记</title>
      <link href="/2022/01/28/Docker%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/28/Docker%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p>查看本机所有镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">参数:</span><br><span class="line">-a列出所有镜像（默认自带）</span><br><span class="line">-q只显示镜像id</span><br></pre></td></tr></table></figure><p>搜索镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker search 镜像名</span><br><span class="line">参数:</span><br><span class="line">-s 指定值列出收藏数不少于指定值的镜像</span><br><span class="line">--no-trunc  显示完整的镜像信息</span><br></pre></td></tr></table></figure><p>下载镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名[:TAG]</span><br></pre></td></tr></table></figure><p>删除镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像名</span><br><span class="line">参数:</span><br><span class="line">-f强制删除</span><br></pre></td></tr></table></figure><p>加载.tar镜像文件到本地docker仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i 镜像文件名</span><br></pre></td></tr></table></figure><hr><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>运行镜像，新建容器并启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run 镜像名</span><br><span class="line">参数:</span><br><span class="line">--name                         为容器起别名</span><br><span class="line">-d                             在后台启动容器</span><br><span class="line">-p 主机端口号:容器端口号           映射端口号       </span><br><span class="line">例: docker run -d --name mytomcat -p 8081:8080 tomcat</span><br></pre></td></tr></table></figure><p>查看正在运行的容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">参数:</span><br><span class="line">-a      查看正在运行的容器和历史运行过的容器</span><br><span class="line">-q      静默模式,只显示容器编号</span><br></pre></td></tr></table></figure><p>停止|关闭|重启容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名或id    -------开启容器</span><br><span class="line">docker restart 容器名或id  -------重启容器</span><br><span class="line">docker stop 容器名或id     -------正常停止容器</span><br><span class="line">docker kill 容器名或id     -------立即停止容器</span><br></pre></td></tr></table></figure><p>删除容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名或id</span><br><span class="line">参数:</span><br><span class="line">-f            强制删除正在运行的容器</span><br></pre></td></tr></table></figure><p>查看容器内服务日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker logs 容器名或id</span><br><span class="line">参数:</span><br><span class="line">-f              实时输出日志</span><br><span class="line">-t              加入时间戳</span><br><span class="line">--tail n        显示日志最后n行</span><br></pre></td></tr></table></figure><p>查看容器内的进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器名或id</span><br></pre></td></tr></table></figure><p>进入容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器名或id bash</span><br><span class="line">exit            退出容器</span><br></pre></td></tr></table></figure><p>主机与容器进行文件传输</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp 主机文件 容器名(或id):容器路径  -------将主机文件复制到容器内部</span><br><span class="line">docker cp 容器名(或id):容器文件 主机路径  -------将容器文件复制到主机内部</span><br></pre></td></tr></table></figure><p>查看容器内部细节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器名或id</span><br></pre></td></tr></table></figure><p>将容器打包成镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m &quot;描述信息&quot; -a &quot;作者&quot; 容器名或id 镜像名:标签</span><br></pre></td></tr></table></figure><p>将镜像保存成一个.tar文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save 镜像名称:标签 -o 文件名</span><br></pre></td></tr></table></figure><hr><h2 id="数据卷操作"><a href="#数据卷操作" class="headerlink" title="数据卷操作"></a>数据卷操作</h2><p>数据卷的作用：实现容器与宿主机之间的数据共享</p><p>特点：</p><ol><li>对数据卷的修改会立即影响容器</li><li>对数据卷的修改不会影响镜像</li><li>容器被删除后，数据卷也会一直存在</li></ol><h3 id="数据卷命令"><a href="#数据卷命令" class="headerlink" title="数据卷命令"></a>数据卷命令</h3><p>创建数据卷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create 卷名</span><br></pre></td></tr></table></figure><p>查看所有数据卷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><p>查看某个数据卷的细节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect 卷名</span><br></pre></td></tr></table></figure><p>删除数据卷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune    ------自动删除所有未使用的数据卷</span><br><span class="line">docker volume rm 卷名   ------删除指定数据卷</span><br></pre></td></tr></table></figure><h3 id="把数据卷挂载到容器中"><a href="#把数据卷挂载到容器中" class="headerlink" title="把数据卷挂载到容器中"></a>把数据卷挂载到容器中</h3><p>自定义数据卷目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run 镜像名</span><br><span class="line">-v 主机目录(绝对路径):容器内目录[:ro]   加:ro表示只读，即容器不能对目录进行写的操作，容器影响不到主机</span><br><span class="line">主要用于向容器中同步数据，docker会把容器内目录中的数据全部替换为主机目录中的数据</span><br></pre></td></tr></table></figure><p>自动数据卷目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run 镜像名</span><br><span class="line">-v 自定义卷名:容器内目录</span><br><span class="line">主要用于把容器中的数据取出，docker会自动在主机中创建一个目录作为卷并把容器中目录的内容全部复制到该新建目录下</span><br></pre></td></tr></table></figure><h2 id="常用服务的安装"><a href="#常用服务的安装" class="headerlink" title="常用服务的安装"></a>常用服务的安装</h2><h3 id="docker安装mysql"><a href="#docker安装mysql" class="headerlink" title="docker安装mysql"></a>docker安装mysql</h3><p>下载mysql镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><p>创建并运行mysql镜像，并指定环境变量和数据卷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 --name mysql01 -v mysqldata:/var/lib/mysql -d mysql</span><br><span class="line"></span><br><span class="line">参数解释：</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root </span><br><span class="line">表示指定mysql数据库的root用户的密码为root</span><br><span class="line"></span><br><span class="line">-v mysqldata:/var/lib/mysqlmysql</span><br><span class="line">表示创建一个mysqldata数据卷来存储mysql的数据</span><br><span class="line">mysql存储数据文件目录在/var/lib/mysql</span><br></pre></td></tr></table></figure><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><table><thead><tr><th>保留字</th><th>作用</th></tr></thead><tbody><tr><td>FROM</td><td>当前镜像是基于哪个镜像  第一个指令必须事FROM</td></tr><tr><td>MAINTAINER(deprecated)</td><td>镜像维护者的姓名和邮箱地址</td></tr><tr><td>RUN</td><td>构建镜像时需要运行的指令</td></tr><tr><td>EXPOSE</td><td>当前容器对外暴露出的端口号</td></tr><tr><td>WORKDIR</td><td>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</td></tr><tr><td>ENV</td><td>用来在构建镜像的过程中设置环境变量</td></tr><tr><td>ADD</td><td>将主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</td></tr><tr><td>COPY</td><td>类似于ADD，拷贝文件和目录到镜像中<br/>将从结构上下文目录中&lt;原路径&gt;的文件&#x2F;目录复制到新的一层的镜像的&lt;目标路径&gt;位置</td></tr><tr><td>VOLUME</td><td>容器数据卷，用于数据保存和持久化工作</td></tr><tr><td>CMD</td><td>指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run命令行参数中指定的程序替换</td></tr><tr><td>ENTRYPOINT</td><td>指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</td></tr></tbody></table><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><ul><li><p>基于哪个镜像构建新的镜像，在构建时会自动从docker hub拉取base镜像</p></li><li><p>必须作为Dockerfile的第一个指令出现</p></li><li><p>语法</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;[:&lt;tag&gt;]</span><br></pre></td></tr></table></figure></li></ul><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><ul><li><p>用来指定构建的镜像在运行为容器时对外暴露的端口</p></li><li><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt;[/tcp|/udp]</span><br><span class="line">EXPOSE 80/tcp    如果没有显示指定，则默认为tcp</span><br><span class="line">EXPOSE 80/udp</span><br></pre></td></tr></table></figure></li></ul><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><ul><li><p>指定在创建容器后，终端默认登录进来的工作目录</p></li><li><p>为Dockerfile中的RUN、CMD、ENTRYPOINT、COPY、ADD指定工作目录</p></li><li><p>可以指定绝对路径，如果路径不存在则会创建目录</p></li><li><p>可以使用多个WORKDIR命令，如果指定相对路径则是在上一个WORKDIR后的相对路径</p></li><li><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR &lt;dir&gt;</span><br><span class="line">WORKDIR /data     绝对路径/data</span><br><span class="line">WORKDIR aa  相对路径，/data下的aa，即/data/aa</span><br></pre></td></tr></table></figure></li></ul><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><ul><li><p>用来将context目录中的指定文件复制到镜像指定目录中</p></li><li><p>语法</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> &lt;src&gt; &lt;<span class="built_in">dir</span>&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hom* /mydir/        通配符</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hom?.text /mydir/ 通配符添加多个文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> home.text relativeDir/   可以指定相对路径</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> home.text /absoluteDir/  可以指定绝对路径</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><ul><li><p>和COPY一样</p></li><li><p>不同之处在于如果要复制的对象是个.tar压缩包，则会自动解压。如果复制的对象是个URL，则会自动下载</p></li><li><p>语法</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> &lt;src&gt; &lt;<span class="built_in">dir</span>&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> url /dir</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> test.tar /dir</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><ul><li><p>用来定义容器运行时可以挂载到主机上的目录</p></li><li><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure></li></ul><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><ul><li><p>用来为镜像设置环境变量，这个值将出现在构建阶段中后续</p></li><li><p>引用的时候用$<key></p></li><li><p>语法</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt;...</span><br></pre></td></tr></table></figure></li></ul><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><ul><li><p>RUN指令将在当前镜像之上的新层中执行并提交结果</p></li><li><p>在docker build时运行</p></li><li><p>生成的提交镜像将用于Dockerfile的下一步</p></li><li><p>语法</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> &lt;<span class="built_in">command</span>&gt;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;&lt;executeable&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;&lt;executeable&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><ul><li><p>与RUN类似</p></li><li><p>在docker run时运行</p></li><li><p>CMD 指令的首要目的在于为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束；注意: CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。 </p></li><li><p>Dockerfile中只能有一条CMD指令，如果有多条，则只有最后一条生效</p></li><li><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;command&gt;</span><br><span class="line">RUN [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</span><br><span class="line">CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数；</span><br></pre></td></tr></table></figure></li></ul><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><ul><li><p>与CMD类似</p></li><li><p>在docker run时运行</p></li><li><p>不会被docker run的命令行参数指定的指令覆盖</p></li><li><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT &lt;command&gt;</span><br><span class="line">ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</span><br></pre></td></tr></table></figure></li></ul><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java手写异步调用</title>
      <link href="/2021/12/27/Java%E6%89%8B%E5%86%99%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/"/>
      <url>/2021/12/27/Java%E6%89%8B%E5%86%99%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-手写异步调用"><a href="#Java-手写异步调用" class="headerlink" title="Java 手写异步调用"></a>Java 手写异步调用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天在写 mirai 机器人的一个小功能时，遇到了这样一个需求：<strong>机器人需要先发出一条消息，然后间隔 3 秒钟撤回这条消息</strong> 。</p><p><del>当然mirai本身提供了现成的方法，支持异步调用</del></p><p>最朴素的想法是使用<code>Thread.sleep(3000)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;3S after&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//3S after</span></span><br><span class="line"><span class="comment">//B</span></span><br></pre></td></tr></table></figure><p>但是这种方法是将方法A的调用线程(即主线程)休眠3S，如果我在主线程中多次调用这个方法，则下一次调用需要等待前一次休眠结束。这就叫阻塞。</p><p>主线程：sout(A)-&gt;等待3S-&gt;sout(B)-&gt;sout(A)-&gt;等待3S-&gt;sout(B)</p><p>显然，如果后续有其他的逻辑需要执行，那么这种方式显然不符合需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    test.A();</span><br><span class="line">    test.A();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//3s after</span></span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//3s after</span></span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//期望输出：</span></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//3s after</span></span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//3s after</span></span><br><span class="line"><span class="comment">//B</span></span><br></pre></td></tr></table></figure><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>主线程：sout(A)-&gt;创建线程1-&gt;sout(2)-&gt;创建线程2</p><p>线程1：等待3S-&gt;sout(B)</p><p>线程2：等待3S-&gt;sout(B)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.A();</span><br><span class="line">        test.A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//3s after</span></span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//3s after</span></span><br><span class="line"><span class="comment">//B</span></span><br></pre></td></tr></table></figure><p>这种方法的缺点：</p><ul><li><p>频繁地创建和销毁线程会占用大量的时间</p></li><li><p>创建线程后，无法跟踪线程的后续完成情况</p></li></ul><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p><a href="https://blog.csdn.net/ZHAOJING1234567/article/details/89882059?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.opensearchhbase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.opensearchhbase">Executor框架 CSDN</a></p><h3 id="Future-或-FutureTask"><a href="#Future-或-FutureTask" class="headerlink" title="Future 或 FutureTask"></a>Future 或 FutureTask</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="comment">//阿里巴巴规范手册不建议用 Executors 创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;3S after&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;task B completed&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//future.get()实际是阻塞的</span></span><br><span class="line">        <span class="comment">//System.out.println(future.get());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.A();</span><br><span class="line">        test.A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//3s after</span></span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//3s after</span></span><br><span class="line"><span class="comment">//B</span></span><br></pre></td></tr></table></figure><p>这种方法的缺点</p><ul><li><p>不同的 Future 之间的关系很难进行关联</p></li><li><p>Future 的 get()方法实际上是阻塞的，直到子线程执行完毕。如果把上面代码中的注释删掉，则输出结果变为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">3S after</span><br><span class="line">B</span><br><span class="line">task B completed</span><br><span class="line">A</span><br><span class="line">3S after</span><br><span class="line">B</span><br><span class="line">task B completed</span><br></pre></td></tr></table></figure></li></ul><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="comment">//阿里巴巴规范手册不建议用 Executors 创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;3S after&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;task B completed&quot;</span>;</span><br><span class="line">        &#125;, executorService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.A();</span><br><span class="line">        test.A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//3s after</span></span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//3s after</span></span><br><span class="line"><span class="comment">//B</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Angular规范的git-commit-message</title>
      <link href="/2021/10/22/Angular%E8%A7%84%E8%8C%83%E7%9A%84git-commit-message/"/>
      <url>/2021/10/22/Angular%E8%A7%84%E8%8C%83%E7%9A%84git-commit-message/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ git commit -m <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>-m</code>参数，就是用来指定 commit mesage 的。</p><p>如果一行不够，可以只执行<code>git commit</code>，就会跳出文本编译器，让你写多行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ git commit</span><br></pre></td></tr></table></figure><p>原则上是写什么都行的。</p><p>但是一般来说，commit message 应该清晰明了，说明本次提交的目的。</p><p>目前，社区有多种 Commit message 的<a href="https://github.com/ajoslin/conventional-changelog/blob/master/conventions">写法规范</a>。本文介绍<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit?spm=a2c6h.12873639.0.0.7ff92ae72HmL6b#heading=h.greljkmo14y0">Angular 规范</a>（见上图），这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。</p></blockquote><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt;// 空一行&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中，Header 是必需的，Body 和 Footer 可以省略。</p><p>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p><h3 id="2-1-Header"><a href="#2-1-Header" class="headerlink" title="2.1 Header"></a>2.1 Header</h3><p>Header部分只有一行，包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和<code>subject</code>（必需）。</p><p><strong>（1）type</strong></p><p><code>type</code>用于说明 commit 的类别，只允许使用下面7个标识。</p><ul><li>feat：新功能（feature）</li><li>fix：修补bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul><p>如果<code>type</code>为<code>feat</code>和<code>fix</code>，则该 commit 将肯定出现在 Change log 之中。其他情况（<code>docs</code>、<code>chore</code>、<code>style</code>、<code>refactor</code>、<code>test</code>）由你决定，要不要放入 Change log，建议是不要。</p><p><strong>（2）scope</strong></p><p><code>scope</code>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><p><strong>（3）subject</strong></p><p><code>subject</code>是 commit 目的的简短描述，不超过50个字符。</p><ul><li>以动词开头，使用第一人称现在时，比如<code>change</code>，而不是<code>changed</code>或<code>changes</code></li><li>第一个字母小写</li><li>结尾不加句号（<code>.</code>）</li></ul><h3 id="2-2-Body"><a href="#2-2-Body" class="headerlink" title="2.2 Body"></a>2.2 Body</h3><p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">More detailed explanatory text, <span class="keyword">if</span> necessary.  Wrap it to </span><br><span class="line">about 72 characters or so. Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent</span><br></pre></td></tr></table></figure><p>有两个注意点。</p><p>（1）使用第一人称现在时，比如使用<code>change</code>而不是<code>changed</code>或<code>changes</code>。</p><p>（2）应该说明代码变动的动机，以及与以前行为的对比。</p><h3 id="2-3-Footer"><a href="#2-3-Footer" class="headerlink" title="2.3 Footer"></a>2.3 Footer</h3><p>Footer 部分只用于两种情况。</p><p><strong>（1）不兼容变动</strong></p><p>如果当前代码与上一个版本不兼容，则 Footer 部分以<code>BREAKING CHANGE</code>开头，后面是对变动的描述、以及变动理由和迁移方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line"></span><br><span class="line">    To migrate the code follow the example below:</span><br><span class="line"></span><br><span class="line">    Before:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: &#x27;attribute&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    After:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: &#x27;@&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    The removed `inject` wasn&#x27;t generaly useful for directives so there should be no code using it.</span><br></pre></td></tr></table></figure><p><strong>（2）关闭 Issue</strong></p><p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes #234</span><br></pre></td></tr></table></figure><p>也可以一次关闭多个 issue 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes #123, #245, #992</span><br></pre></td></tr></table></figure><h3 id="2-4-Revert"><a href="#2-4-Revert" class="headerlink" title="2.4 Revert"></a>2.4 Revert</h3><p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以<code>revert:</code>开头，后面跟着被撤销 Commit 的 Header。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add &#x27;graphiteWidth&#x27; option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure><p>Body部分的格式是固定的，必须写成<code>This reverts commit &lt;hash&gt;.</code>，其中的<code>hash</code>是被撤销 commit 的 SHA 标识符。</p><p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的<code>Reverts</code>小标题下面。</p><blockquote><p>参考：</p><p><a href="https://developer.aliyun.com/article/441408">Git 提交的正确姿势：Commit message 编写指南-阿里云开发者社区 (aliyun.com)</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RestTemplate的简单使用</title>
      <link href="/2021/09/18/RestTemplate%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/09/18/RestTemplate%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是RestTemplate"><a href="#什么是RestTemplate" class="headerlink" title="什么是RestTemplate"></a>什么是RestTemplate</h3><blockquote><p>RestTemplate 是 Spring 提供的一个Http请求工具。它支持常见的Rest请求方案的模板，例如 GET 请求、POST 请求、PUT 请求、DELETE 请求以及一些通用的请求执行方法 exchange 以及 execute。</p><p>说白了，它的功能就类似 HttpClient。</p><p>在Spring项目中，使用 RestTemplate 发送 Http 请求无疑比 HttpClient 更加方便。</p><p>（但由于 RestTemplate 是阻塞、同步的，因此在面对大批请求时可能会有性能损失。因此在Spring5.x 以后，出现了 <code>WebClient</code> 来替代 RestTemplate）</p></blockquote><h3 id="发起Get请求"><a href="#发起Get请求" class="headerlink" title="发起Get请求"></a>发起Get请求</h3><p>get请求都需要在url后面手动拼接上参数</p><h4 id="getForObject"><a href="#getForObject" class="headerlink" title="getForObject"></a>getForObject</h4><p>获取响应对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;role&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getTest</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="comment">//请求的url,注意后面要手动拼接上请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8080/id?id=&#123;id&#125;&quot;</span>;</span><br><span class="line">        <span class="comment">//请求参数</span></span><br><span class="line">        Map&lt;String, Object&gt; params = Map.of(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//getForObject的第二个参数是返回值的类型</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class, params);</span><br><span class="line">        System.out.println(<span class="string">&quot;RestTemplate调用/id接口&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getForEntity"><a href="#getForEntity" class="headerlink" title="getForEntity"></a>getForEntity</h4><p>获取响应对象、http状态码、请求头等详细信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;role&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getTest</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8080/id?id=&#123;id&#125;&quot;</span>;</span><br><span class="line">        Map&lt;String, Object&gt; params = Map.of(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        ResponseEntity&lt;User&gt; responseEntity = restTemplate.getForEntity(url, User.class, params);</span><br><span class="line">        System.out.println(<span class="string">&quot;RestTemplate调用/id接口&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//额外获取的信息</span></span><br><span class="line">        <span class="type">HttpStatus</span> <span class="variable">statusCode</span> <span class="operator">=</span> responseEntity.getStatusCode();</span><br><span class="line">        <span class="type">int</span> <span class="variable">statusCodeValue</span> <span class="operator">=</span> responseEntity.getStatusCodeValue();</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> responseEntity.getHeaders();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getBody()可以获取响应对象</span></span><br><span class="line">        <span class="keyword">return</span> responseEntity.getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发起Post请求"><a href="#发起Post请求" class="headerlink" title="发起Post请求"></a>发起Post请求</h3><h4 id="postForObject"><a href="#postForObject" class="headerlink" title="postForObject"></a>postForObject</h4><h5 id="传递key-value形式的参数"><a href="#传递key-value形式的参数" class="headerlink" title="传递key&#x2F;value形式的参数"></a>传递key&#x2F;value形式的参数</h5><p>与Get请求不同，Post请求中传参的Map必须是MultiValueMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">postUser</span><span class="params">(<span class="type">int</span> id, String username, String password, String role)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, username, password, role);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//也可以这也获取参数</span></span><br><span class="line"><span class="comment">//但是不能加@RequestBody注解，因为传递的参数不是放在body里的</span></span><br><span class="line"><span class="comment">//    @PostMapping(&quot;/id&quot;)</span></span><br><span class="line"><span class="comment">//    public User postUser(User user) &#123;</span></span><br><span class="line"><span class="comment">//        return user;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">postTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8080/id&quot;</span>;</span><br><span class="line">        MultiValueMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">        params.add(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        params.add(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;username&quot;</span>);</span><br><span class="line">        params.add(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">        params.add(<span class="string">&quot;role&quot;</span>, <span class="string">&quot;role&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.postForObject(url, params, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;RestTemplate调用/id接口&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="传递json数据"><a href="#传递json数据" class="headerlink" title="传递json数据"></a>传递json数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">postUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">postTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8080/id&quot;</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;role&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.postForObject(url, params, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;RestTemplate调用/id接口&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="postForEntity"><a href="#postForEntity" class="headerlink" title="postForEntity"></a>postForEntity</h4><p>postForEntity 和 postForObject 的区别就相当于 getForEntity 与 getForObject 的区别</p><p>不再赘述</p><h4 id="postForLocation-不常用"><a href="#postForLocation-不常用" class="headerlink" title="postForLocation(不常用)"></a>postForLocation(不常用)</h4><p>postForLocation 方法的返回值是一个 Uri 对象，因为 POST 请求一般用来添加数据，有的时候需要将刚刚添加成功的数据的 URL 返回来，此时就可以使用这个方法，一个常见的使用场景如用户注册功能，用户注册成功之后，可能就自动跳转到登录页面了，此时就可以使用该方法。</p><p><strong>注意：postForLocation 方法返回的 Uri 实际上是指响应头的 Location 字段，所以，provider 中 register 接口的响应头必须要有 Location 字段（即请求的接口实际上是一个重定向的接口），否则 postForLocation 方法的返回值为null。</strong></p><blockquote><p>参考博客：<a href="https://blog.csdn.net/jinjiniao1/article/details/100849237">https://blog.csdn.net/jinjiniao1/article/details/100849237</a></p><p><a href="https://www.cnblogs.com/wwct/p/12325173.html">Java RestTemplate传递参数 - 威威超酷 - 博客园 (cnblogs.com)</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot使用HibernateValidator实现参数校验</title>
      <link href="/2021/09/10/SpringBoot%E4%BD%BF%E7%94%A8HibernateValidator%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/2021/09/10/SpringBoot%E4%BD%BF%E7%94%A8HibernateValidator%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Hibernate-Validator"><a href="#Hibernate-Validator" class="headerlink" title="Hibernate Validator"></a>Hibernate Validator</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>Hibernate Validator是Spring Boot集成的参数校验框架；</p><p>但从Spring Boot 2.3版本开始默认移除了校验功能，如果想要开启的话需要添加如下依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul><li>@Null：被注释的属性必须为null；</li><li>@NotNull：被注释的属性不能为null；</li><li>@AssertTrue：被注释的属性必须为true；</li><li>@AssertFalse：被注释的属性必须为false；</li><li>@Min：被注释的属性必须大于等于其value值；</li><li>@Max：被注释的属性必须小于等于其value值；</li><li>@Size：被注释的属性必须在其min和max值之间；</li><li>@Pattern：被注释的属性必须符合其regexp所定义的正则表达式；</li><li>@NotBlank：被注释的字符串不能为空字符串；</li><li>@NotEmpty：被注释的属性不能为空；</li><li>@Email：被注释的属性必须符合邮箱格式。</li><li>@PastOrPresent：必须是过去或现在的时间</li></ul><h3 id="使用注解实现校验"><a href="#使用注解实现校验" class="headerlink" title="使用注解实现校验"></a>使用注解实现校验</h3><p>pojo类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;角色不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String role;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String username, String password, String role, Date createTime, <span class="type">boolean</span> enable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.role = role;</span><br><span class="line">        <span class="built_in">this</span>.createTime = createTime;</span><br><span class="line">        <span class="built_in">this</span>.enable = enable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;register&quot;)</span></span><br><span class="line">    <span class="comment">//添加注解@Valid开启校验</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">register</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> Account account)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountService.register(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当传入参数不符合参数规范时，会抛出异常。在这个框架中有个默认的异常处理类DefaultHandlerExceptionResolver。</p><p>当传入的json中的username为空，异常信息：</p><blockquote><p>2021-09-10 15:40:25.749  WARN 22228 — [nio-8080-exec-2] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.web.bind.MethodArgumentNotValidException: Validation failed for argument [0] in public com.example.demo.pojo.Account com.example.demo.controller.AccountController.register(com.example.demo.pojo.Account): [Field error in object ‘account’ on field ‘username’: rejected value [null]; codes [NotNull.account.username,NotNull.username,NotNull.java.lang.String,NotNull]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [account.username,username]; arguments []; default message [username]]; default message [用户名不能为空]] ]</p></blockquote><h3 id="自定义异常处理"><a href="#自定义异常处理" class="headerlink" title="自定义异常处理"></a>自定义异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;ResultCode&gt; <span class="title function_">handlerValidationException</span><span class="params">(MethodArgumentNotValidException e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;参数校验异常&quot;</span>, e);</span><br><span class="line">        <span class="comment">//流处理，获取错误信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">messages</span> <span class="operator">=</span> e.getBindingResult().getAllErrors().stream()</span><br><span class="line">                .map(ObjectError::getDefaultMessage)</span><br><span class="line">                .collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> Result.failure(messages);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="级联校验"><a href="#级联校验" class="headerlink" title="级联校验"></a>级联校验</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="meta">@Null</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> Department department;</span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Group&gt; groups;</span><br><span class="line">    <span class="comment">//或者可以这样写：</span></span><br><span class="line">    <span class="comment">//private List&lt;@Valid Group&gt; groups;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在级联的属性上要加@Valid</p><h3 id="在其他地方实现校验"><a href="#在其他地方实现校验" class="headerlink" title="在其他地方实现校验"></a>在其他地方实现校验</h3><p>@Valid加在Controller中，抛出的异常是<code>MethodArgumentNotValidException</code></p><p>而加在其他地方，抛出的异常却是<code>ConstraintViolationException</code></p><p>在做全局异常处理的时候要注意区别。</p><h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><p>例如上面的Employee类，我们想要它在不同的情况下有不同的校验规则，这时就需要用到分组校验</p><p>1、创建一个分组类，里面添加一些内部接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidationGroups</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">insertNeed</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">selectNeed</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">updateNeed</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、为不同的情况添加不同的分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用之前的结构来表示分组</span></span><br><span class="line">    <span class="meta">@Null(groups = ValidationGroups.insertNeed.class)</span></span><br><span class="line">    <span class="meta">@NotNull(groups = ValidationGroups.selectNeed.class)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个注解可以s</span></span><br><span class="line">    <span class="meta">@NotNull(groups = ValidationGroups.insertNeed.class,ValidationGroups.selectNeed.class)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Valid(groups = ValidationGroups.insertNeed.class)</span></span><br><span class="line">    <span class="keyword">private</span> Department department;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Valid(groups = ValidationGroups.insertNeed.class)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Group&gt; groups;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、在需要校验时用@Validated标识需要使用的分组规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(ValidationGroups.insertNeed.class)</span> Employee Employee)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring中Aop的注解使用</title>
      <link href="/2021/09/09/Spring%E4%B8%ADAop%E7%9A%84%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/09/09/Spring%E4%B8%ADAop%E7%9A%84%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="AOP的相关术语"><a href="#AOP的相关术语" class="headerlink" title="AOP的相关术语"></a>AOP的相关术语</h2><h4 id="切面（Aspect）"><a href="#切面（Aspect）" class="headerlink" title="切面（Aspect）"></a>切面（Aspect）</h4><p>切点+通知</p><h4 id="切点（Pointcut）"><a href="#切点（Pointcut）" class="headerlink" title="切点（Pointcut）"></a>切点（Pointcut）</h4><p>切点定义了通知功能被应用的范围。比如日志切面的应用范围就是所有接口，即所有controller层的接口方法。</p><h4 id="通知（Advice）"><a href="#通知（Advice）" class="headerlink" title="通知（Advice）"></a>通知（Advice）</h4><p>通知描述了切面要完成的工作以及何时执行。</p><ul><li>前置通知（Before）：在目标方法调用前调用通知功能；</li><li>后置通知（After）：在目标方法调用之后调用通知功能，不关心方法的返回结果；</li><li>返回通知（AfterReturning）：在目标方法成功执行之后调用通知功能；</li><li>异常通知（AfterThrowing）：在目标方法抛出异常后调用通知功能；</li><li>环绕通知（Around）：通知包裹了目标方法，在目标方法调用之前和之后执行自定义的行为。</li></ul><h4 id="连接点（JoinPoint）"><a href="#连接点（JoinPoint）" class="headerlink" title="连接点（JoinPoint）"></a>连接点（JoinPoint）</h4><p>通知功能被应用的时机。比如接口方法被调用的时候就是日志切面的连接点。</p><h4 id="引入（Introduction）"><a href="#引入（Introduction）" class="headerlink" title="引入（Introduction）"></a>引入（Introduction）</h4><p>在无需修改现有类的情况下，向现有的类添加新方法或属性。</p><h4 id="织入（Weaving）"><a href="#织入（Weaving）" class="headerlink" title="织入（Weaving）"></a>织入（Weaving）</h4><p>把切面应用到目标对象并创建新的代理对象的过程。</p><h2 id="Spring中使用注解创建切面"><a href="#Spring中使用注解创建切面" class="headerlink" title="Spring中使用注解创建切面"></a>Spring中使用注解创建切面</h2><blockquote><p>相关注解：</p><p>@Aspect：用于定义切面</p><p>@Before：通知方法会在目标方法调用之前执行</p><p>@After：通知方法会在目标方法返回或抛出异常后执行</p><p>@AfterReturning：通知方法会在目标方法返回后执行</p><p>@AfterThrowing：通知方法会在目标方法抛出异常后执行</p><p>@Around：通知方法会将目标方法封装起来</p><p>@Pointcut：定义切点表达式</p><p>切点表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;execution( 方法修饰符 返回类型 方法所属的包.类名.方法名称(方法参数) )  </span><br><span class="line">&gt;&quot;*&quot;表示不限     &quot;..&quot;表示参数不限</span><br><span class="line">&gt;方法修饰符不写表示不限，不用&quot;*&quot; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;//com.example.demo.controller包中所有类的public方法都应用切面里的通知</span><br><span class="line">&gt;execution(public * com.example.demo.controller.*.*(..))</span><br><span class="line">&gt;//com.example.demo.service包及其子包下所有类中的所有方法都应用切面里的通知</span><br><span class="line">&gt;execution(* com.example.demo.service..*.*(..))</span><br><span class="line">&gt;//com.example.demo.service.UserService类中的所有方法都应用切面里的通知</span><br><span class="line">&gt;execution(* com.example.demo.service.UserService.*(..))</span><br></pre></td></tr></table></figure></blockquote><p>1、定义切面类Aspect</p><p>2、定义切点Pointcut</p><p>3、定义通知Advice</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebLogAspect</span> &#123;</span><br><span class="line">    <span class="comment">//表示com.example.demo.controller包下的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution( * com.example.demo.controller.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myPointcut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;myPointcut()&quot;)</span></span><br><span class="line">    <span class="comment">//环绕通知的限定参数：ProceedingJoinPoint</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">applicationLogger</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> proceedingJoinPoint.getSignature().getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> proceedingJoinPoint.getTarget().getClass().toString();</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        Object[] array = proceedingJoinPoint.getArgs();</span><br><span class="line">        log.info(<span class="string">&quot;调用前:&quot;</span> + className + <span class="string">&quot;:&quot;</span> + methodName + <span class="string">&quot;args=&quot;</span> + objectMapper.writeValueAsString(array));</span><br><span class="line">        <span class="comment">//z</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">        log.info(<span class="string">&quot;调用后:&quot;</span> + className + <span class="string">&quot;:&quot;</span> + methodName + <span class="string">&quot;args=&quot;</span> + objectMapper.writeValueAsString(array));</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ笔记</title>
      <link href="/2021/08/28/RabbitMQ%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/28/RabbitMQ%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="docker安装RabbitMQ"><a href="#docker安装RabbitMQ" class="headerlink" title="docker安装RabbitMQ"></a>docker安装RabbitMQ</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-d --name myrabbitmq \</span><br><span class="line">-p 5672:5672 -p 15672:15672 \</span><br><span class="line">-v rabbitmqData:/var/lib/rabbitmq \</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=username \</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=password \</span><br><span class="line">rabbitmq:management</span><br></pre></td></tr></table></figure><h2 id="几种基础模型"><a href="#几种基础模型" class="headerlink" title="几种基础模型"></a>几种基础模型</h2><h3 id="基础生产者与消费者模型"><a href="#基础生产者与消费者模型" class="headerlink" title="基础生产者与消费者模型"></a>基础生产者与消费者模型</h3><ul><li>一对一</li><li>生产者生产消息后放入消息队列，消费者从队列中获得消息后进行消费。</li></ul><p>生产者代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Provider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接mq的连接工厂对象</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接rabbitmq主机</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;123.56.2.36&quot;</span>);</span><br><span class="line">        <span class="comment">//设置端口号</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//设置连接哪个虚拟主机</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">        <span class="comment">//设置访问虚拟主机的用户名和密码</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接中的通道对象</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通道绑定对应的消息队列</span></span><br><span class="line">        <span class="comment">//参数1:队列名称 如果队列不存在则自动创建</span></span><br><span class="line">        <span class="comment">//参数2:队列是否持久化 (不持久化则mq重启会被删除)</span></span><br><span class="line">        <span class="comment">//参数3:队列是否独占</span></span><br><span class="line">        <span class="comment">//参数4:是否在消费完成后自动删除队列</span></span><br><span class="line">        <span class="comment">//参数5:附加参数</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发布消息</span></span><br><span class="line">        <span class="comment">//参数1:交换机名称</span></span><br><span class="line">        <span class="comment">//参数2:队列名称</span></span><br><span class="line">        <span class="comment">//参数3:传递消息的额外设置(PERSISTENT_TEXT_PLAIN表示消息也会持久化)</span></span><br><span class="line">        <span class="comment">//参数4:消息的具体内容(byte数组)</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;hello&quot;</span>,MessageProperties.PERSISTENT_TEXT_PLAIN,<span class="string">&quot;hello rabbitmq&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConsume</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建连接mq的连接工厂对象</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//设置连接rabbitmq主机</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;123.56.2.36&quot;</span>);</span><br><span class="line">        <span class="comment">//设置端口号</span></span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//设置连接哪个虚拟主机</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">        <span class="comment">//设置访问虚拟主机的用户名和密码</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通道绑定对应的消息队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        <span class="comment">//参数1:队列名称</span></span><br><span class="line">        <span class="comment">//参数2:是否开启消息自动确认</span></span><br><span class="line">        <span class="comment">//参数3:消费时的回调接口</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="comment">//最后一个参数:消息队列中取出的消息</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//消费者一直处于监听状态，不需要关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把其中创建连接的代码提取成工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConnectionUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义提供连接对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionFactory = <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">            <span class="comment">//设置连接rabbitmq主机</span></span><br><span class="line">            connectionFactory.setHost(<span class="string">&quot;123.56.2.36&quot;</span>);</span><br><span class="line">            <span class="comment">//设置端口号</span></span><br><span class="line">            connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">            <span class="comment">//设置连接哪个虚拟主机</span></span><br><span class="line">            connectionFactory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">            <span class="comment">//设置访问虚拟主机的用户名和密码</span></span><br><span class="line">            connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> connectionFactory.newConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭通道和关闭连接的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConnectionAndChanel</span><span class="params">(Channel channel, Connection connection)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span>)</span><br><span class="line">                channel.close();</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span>)</span><br><span class="line">                connection.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工作队列模型"><a href="#工作队列模型" class="headerlink" title="工作队列模型"></a>工作队列模型</h3><ul><li><p>多个消费者对应一个队列，防止消息处理费事时，消息的堆积</p></li><li><p>默认是轮询执行</p><p>可以通过设置消费者每次只能消费一个消息并且手动确认消息来实现“能者多劳”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次只消费一个</span></span><br><span class="line"><span class="comment">//channel.basicQos(1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭消息自动确认</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行业务逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//手动确认消息</span></span><br><span class="line"><span class="comment">//channel.basicAck(envelope.getDeliveryTag(),false);</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Fanout模型"><a href="#Fanout模型" class="headerlink" title="Fanout模型"></a>Fanout模型</h3><ul><li>生产者把消息发送到交换机，交换机再通过队列发送给消费者</li><li>有多个消费者，每个消费者都有自己的queue，每个queue都需要绑定到exchange(交换机)</li><li>exchange会把消息发送到所有绑定的queue中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Provider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//获取连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQConnectionUtil.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//给通道声明指定交换机</span></span><br><span class="line">        <span class="comment">//参数1:交换机的名字</span></span><br><span class="line">        <span class="comment">//参数2:交换机类型</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs&quot;</span>, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;logs&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;test&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RabbitMQConnectionUtil.closeConnectionAndChanel(channel, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQConnectionUtil.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs&quot;</span>, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//创建临时队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//绑定交换机和队列</span></span><br><span class="line">        channel.queueBind(queueName, <span class="string">&quot;logs&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer1:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQConnectionUtil.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs&quot;</span>, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//创建临时队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//绑定交换机和队列</span></span><br><span class="line">        channel.queueBind(queueName, <span class="string">&quot;logs&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer2:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>provider生产的消息会同时发给Consumer1和Consumer2</p><h3 id="Routing模型-direct"><a href="#Routing模型-direct" class="headerlink" title="Routing模型(direct)"></a>Routing模型(direct)</h3><ul><li>队列与交换机的绑定需要指定routingKey</li><li>消息的发送方再向exchange发消息时，也要指定routingKey</li><li>exchange会比对routingKey，讲消息发送到对应的queue中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Provider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQConnectionUtil.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//给通道声明指定交换机</span></span><br><span class="line">        <span class="comment">//参数1:交换机的名字</span></span><br><span class="line">        <span class="comment">//参数2:交换机类型</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;logs_direct&quot;</span>, routingKey, <span class="literal">null</span>, (<span class="string">&quot;这是direct模型发布的基于routingKey:&quot;</span> + routingKey).getBytes());</span><br><span class="line">        RabbitMQConnectionUtil.closeConnectionAndChanel(channel, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQConnectionUtil.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//通道声明交换机及交换机的类型</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="comment">//创建一个临时队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//基于routingKey绑定队列和交换机</span></span><br><span class="line">        channel.queueBind(queueName, <span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer1:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQConnectionUtil.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//通道声明交换机及交换机的类型</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="comment">//创建一个临时队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//基于routingKey绑定队列和交换机</span></span><br><span class="line">        channel.queueBind(queueName, <span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName, <span class="string">&quot;logs_direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer2:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Routing模型-topic"><a href="#Routing模型-topic" class="headerlink" title="Routing模型(topic)"></a>Routing模型(topic)</h3><ul><li>与direct类似</li><li>不同之处在于topic类型的exchange可以让queue在绑定routingKey的时候使用通配符</li><li>这种模型的routingKey一般由几个单词组成，多个单词之间用’.’分隔，例如<code>message.info</code></li><li>通配符：<code>*</code>匹配一个词，<code>#</code>匹配多个词(包括0个)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Provider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQConnectionUtil.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//给通道声明指定交换机</span></span><br><span class="line">        <span class="comment">//参数1:交换机的名字</span></span><br><span class="line">        <span class="comment">//参数2:交换机类型</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs_topic&quot;</span>, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;user.save&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;logs_topic&quot;</span>, routingKey, <span class="literal">null</span>, (<span class="string">&quot;这是direct模型发布的基于routingKey:&quot;</span> + routingKey).getBytes());</span><br><span class="line">        RabbitMQConnectionUtil.closeConnectionAndChanel(channel, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQConnectionUtil.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//通道声明交换机及交换机的类型</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs_topic&quot;</span>, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">//创建一个临时队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//基于routingKey绑定队列和交换机</span></span><br><span class="line">        channel.queueBind(queueName, <span class="string">&quot;logs_topic&quot;</span>, <span class="string">&quot;user.*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer1:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> RabbitMQConnectionUtil.getConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">//通道声明交换机及交换机的类型</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;logs_topic&quot;</span>, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">        <span class="comment">//创建一个临时队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//基于routingKey绑定队列和交换机</span></span><br><span class="line">        channel.queueBind(queueName, <span class="string">&quot;logs_topic&quot;</span>, <span class="string">&quot;*.save&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer2:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h2><p>1、引入依赖</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="code">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">&lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure><p>2、application.yml配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: <span class="number">123.56</span><span class="number">.2</span><span class="number">.36</span></span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: admin</span><br><span class="line">    password: admin</span><br><span class="line">    virtual-host: /ems</span><br></pre></td></tr></table></figure><h3 id="剩下的以后再更新"><a href="#剩下的以后再更新" class="headerlink" title="剩下的以后再更新("></a>剩下的以后再更新(</h3><p>11111</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/04/20/MySQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="DQL查询"><a href="#DQL查询" class="headerlink" title="DQL查询"></a>DQL查询</h2><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><ul><li>语法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  查询列表</span><br><span class="line">FROM</span><br><span class="line">  表名;</span><br></pre></td></tr></table></figure><ul><li>起别名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 起别名</span><br><span class="line">SELECT </span><br><span class="line">  name AS my_name   # 第一种方式</span><br><span class="line">FROM </span><br><span class="line">  students;  </span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  name my_name   # 第二种方式</span><br><span class="line">FROM </span><br><span class="line">  students; </span><br></pre></td></tr></table></figure><ul><li>去重</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  DISTINCT name </span><br><span class="line">FROM </span><br><span class="line">  students;</span><br></pre></td></tr></table></figure><ul><li>字段拼接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MySQL中的&#x27;+&#x27;号只能作为运算符</span><br><span class="line">SELECT </span><br><span class="line">  CONCAT(last_name,first_name) AS name</span><br><span class="line">FROM</span><br><span class="line">  students;</span><br></pre></td></tr></table></figure><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><ul><li>语法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  查询列表</span><br><span class="line">FROM</span><br><span class="line">  表名</span><br><span class="line">WHERE</span><br><span class="line">  筛选条件;</span><br></pre></td></tr></table></figure><ul><li>逻辑运算符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; 等价于AND </span><br><span class="line">|| 等价于OR </span><br><span class="line"> ！等价于NOT</span><br><span class="line"># 从students表中选取id在10到20之间的学生的name(开区间)</span><br><span class="line">SELECT</span><br><span class="line">  name </span><br><span class="line">FROM </span><br><span class="line">  students</span><br><span class="line">WHERE</span><br><span class="line">  id &gt; 10 AND id &lt; 20;</span><br></pre></td></tr></table></figure><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><ul><li>like</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">通配符：% 任意多个字符</span><br><span class="line">        _ 任意单个字符</span><br><span class="line">转义字符： &#x27;\_&#x27;  &#x27;\%&#x27;</span><br><span class="line">           &#x27;&amp;_&#x27; ESCAPE &#x27;&amp;&#x27; (&amp;可为任意符号)</span><br><span class="line"># 从students表中查询name字段中第三个为A，第五个为_，第六个为%的学生</span><br><span class="line">SELECT</span><br><span class="line">  *</span><br><span class="line">FROM</span><br><span class="line">  students</span><br><span class="line">WHERE</span><br><span class="line">  name LIKE &#x27;__A_\_\%%&#x27;;</span><br><span class="line"># 等价于 name LIKE &#x27;__A_$_$%%&#x27; ESCAPE &#x27;$&#x27;;</span><br></pre></td></tr></table></figure><ul><li>between a and b</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 从students表中查询id在100到120之间的学生信息(闭区间)</span><br><span class="line">SELECT</span><br><span class="line">  *</span><br><span class="line">FROM</span><br><span class="line">  students</span><br><span class="line">WHERE</span><br><span class="line">  id BETWEEN 100 ADN 120;</span><br><span class="line"># 等价于 id &gt;=100 AND id &lt;=120;</span><br><span class="line">1、BETWEEN AND是闭区间</span><br><span class="line">2、a表达式必须&lt;=b表达式</span><br></pre></td></tr></table></figure><ul><li>in</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 从students表中查询id为60，70，80，90的学生信息</span><br><span class="line">SELECT</span><br><span class="line">  *</span><br><span class="line">FROM</span><br><span class="line">  students</span><br><span class="line">WHERE</span><br><span class="line">  id IN (&#x27;60&#x27;,&#x27;70&#x27;,&#x27;80&#x27;,&#x27;90&#x27;);</span><br><span class="line"># 等价于 id = &#x27;60&#x27; OR id = &#x27;70&#x27; OR id = &#x27;80&#x27; OR id = &#x27;90&#x27;;</span><br></pre></td></tr></table></figure><ul><li>is null</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 从students表中查询id不存在的学生信息</span><br><span class="line">SELECT</span><br><span class="line">  *</span><br><span class="line">FROM</span><br><span class="line">  students</span><br><span class="line">WHERE</span><br><span class="line">  id IS NULL;</span><br><span class="line"># 等价于id &lt;=&gt; NULL</span><br><span class="line"># &lt;=&gt;安全等于   &lt;&gt;安全不等于</span><br><span class="line"># mysql中不能用id = NULL判断</span><br></pre></td></tr></table></figure><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><ul><li>语法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  查询列表</span><br><span class="line">FROM</span><br><span class="line">  表名</span><br><span class="line">(筛选条件)</span><br><span class="line">ORDER BY </span><br><span class="line">  排序列表 （ASC|DESC）</span><br><span class="line"># 默认ASC升序</span><br><span class="line">排序列表可以是单个字段、多个字段、表达式、函数、别名等</span><br></pre></td></tr></table></figure><h4 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h4><h5 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h5><ul><li>字符函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"># 1、1ength获取参数值的字节个数</span><br><span class="line">SELECT LENGTH(&#x27;hello&#x27;);</span><br><span class="line"># 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2、concat 拼接字符串</span><br><span class="line">SELECT CONCAT(last_name,&#x27;_&#x27;,first_name) 姓名 FROM students;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3、upper、lower 大小写转换</span><br><span class="line">SELECT UPPER(&#x27;hello&#x27;);</span><br><span class="line"># HELLO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 4、substr\substring 字符串截取</span><br><span class="line"># 注意所有SQL语句的索引都是从1</span><br><span class="line"></span><br><span class="line"># 返回从第三个位置开始到字符串结尾的子字符串</span><br><span class="line">SELECT SUBSTR(&#x27;I love you&#x27;,3);</span><br><span class="line"># love you</span><br><span class="line"></span><br><span class="line"># 返回从第三个位置开始长度为4的子字符串</span><br><span class="line">SELECT SUBSTR(&#x27;I love you&#x27;,3，4);</span><br><span class="line"># love</span><br><span class="line"></span><br><span class="line"># 返回从倒数第五个位置开始长度为3的子字符串</span><br><span class="line">SELECT SUBSTR(&#x27;I love you&#x27;,-3，3);</span><br><span class="line"># you</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 5、instr 返回字符串第一次出现的索引，如果找不到则返回0</span><br><span class="line">SELECT INSTR(&#x27;I love you&#x27;,&#x27;love&#x27;);</span><br><span class="line"># 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 6、trim 去除前后空格</span><br><span class="line">SELECT LENGTH(&#x27;        hello        &#x27;);</span><br><span class="line"># 5</span><br><span class="line"></span><br><span class="line"># 去除其他字符</span><br><span class="line">SELECT TRIM(&#x27;a&#x27; FROM &#x27;aaaaaaaaaaaaaahelloaaaaaaaaaaa&#x27;);</span><br><span class="line"># hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 7、lpad(rpad) 用指定字符实现左(右)填充指定长度</span><br><span class="line">SELECT LPAD(&#x27;hello&#x27;，10，&#x27;$&#x27;);</span><br><span class="line"># $$$$$hello</span><br><span class="line"></span><br><span class="line"># 如果原长度超过指定长度，则从右开始截断</span><br><span class="line">SELECT LPAD(&#x27;hello&#x27;,2,&#x27;$&#x27;);</span><br><span class="line"># he</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 8、replace 替换</span><br><span class="line">SELECT REPLACE(&#x27;I love you&#x27;,&#x27;you&#x27;,&#x27;she&#x27;);</span><br><span class="line"># I love she</span><br></pre></td></tr></table></figure><ul><li>数学函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 1、round 四舍五入</span><br><span class="line">SELECT ROUND(1.65);</span><br><span class="line"># 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2、ceil(floor) 向上(向下)取整，返回&gt;=(&lt;=)该参数的最小整数</span><br><span class="line">SELECT CEIL(1.02);</span><br><span class="line"># 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3、truncate 截断(保留小数点后多少位)</span><br><span class="line">SELECT TRUNCATE(1.14514,1);</span><br><span class="line"># 1.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 4、mod 取余</span><br><span class="line">SELECT MOD(10,3);</span><br><span class="line">#等同于SELECT 10%3;</span><br><span class="line"># 1</span><br></pre></td></tr></table></figure><ul><li>日期函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 1、now 返回当前系统日期+时间</span><br><span class="line">SELECT NOW();</span><br><span class="line"># 2021-04-09 16:05:36</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2、curdate 返回当前系统日期，不包含时间</span><br><span class="line">SELECT CURDATE();</span><br><span class="line"># 2021-04-09</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3、curtime 返回当前系统时间，不包含日期</span><br><span class="line">SELECT CURTIME();</span><br><span class="line"># 16:05:36</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 4、获取指定的部分年、月、日、小时、分钟</span><br><span class="line">SELECT YEAR(NOW());</span><br><span class="line"># 2021</span><br><span class="line"># 类似还有MONTH()、DAY()、HOUR()等</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 5、str_to_date 将字符通过指定格式转化为日期</span><br><span class="line">SELECT STR_TO_DATE(&#x27;1998-3-2&#x27;,&#x27;%Y-%c-%d&#x27;);</span><br><span class="line"># 1998-03-02</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 6、date_format 将日期转换为字符</span><br><span class="line">SELECT DATE_FORMAT(NOW(),&#x27;%Y年%m月%d日&#x27;);</span><br><span class="line"># 2021年04月09日                                                                 </span><br></pre></td></tr></table></figure><ul><li>流程控制函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 1、if函数： 类似于三目运算符</span><br><span class="line">SELECT IF(10&lt;5,&#x27;大&#x27;,&#x27;小&#x27;);</span><br><span class="line"># 大</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2、case函数： </span><br><span class="line"># 使用一：类似于switch case</span><br><span class="line">CASE sid;</span><br><span class="line">WHEN 10 THEN grade+10;</span><br><span class="line">WHEN 20 THEN grade+20;</span><br><span class="line">WHEN 30 THEN grade+30;</span><br><span class="line">ELSE grade+2;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"># 使用二：类似于 if else</span><br><span class="line">CASE</span><br><span class="line">WHEN sid&gt;2000 THEN &#x27;A&#x27;</span><br><span class="line">WHEN sid&gt;1000 THEN &#x27;B&#x27;</span><br><span class="line">WHEN sid&gt;500  THEN &#x27;C&#x27;</span><br><span class="line">ELSE &#x27;D&#x27;</span><br><span class="line">END</span><br></pre></td></tr></table></figure><ul><li>其他函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># version 查看版本</span><br><span class="line"># datebase 查看数据库</span><br><span class="line"># user 查看当前用户</span><br></pre></td></tr></table></figure><h5 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">功能：</span><br><span class="line">用作统计使用，又称为聚合函数或统计函数或组合函数</span><br><span class="line">分类：</span><br><span class="line">sum 求和、 avg 平均值、 max 最大值、 min 最小值、 count 计算个数</span><br><span class="line">特点：</span><br><span class="line">1、sum、avg一般处理数值型</span><br><span class="line">   max、min、count可以处理任何类型</span><br><span class="line">2、以上分组函数都忽略null值</span><br><span class="line">3、可以和distinct搭配实现去重</span><br><span class="line">4、count(*)等价于count(常量),作用为统计表里全部数据的个数</span><br><span class="line">5、和分组函数一同查询的字段要求是group by后的字段                                                                                                                                                                                                                                                                                                                                                                                                                              </span><br></pre></td></tr></table></figure><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><ul><li>语法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT 分组函数，列(要求出现在group by的后面)</span><br><span class="line">FROM 表</span><br><span class="line">[WHERE 筛选条件]</span><br><span class="line">GROUP BY 分组的列表</span><br><span class="line">[ORDER BY 子句]</span><br><span class="line">注意：查询列表必须要求是分组函数+group by后出现的字段</span><br></pre></td></tr></table></figure><ul><li>简单分组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询一个公司每个工种的最高工资</span><br><span class="line">SELECT MAX(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 案例2：查询每个位置上的部门个数</span><br><span class="line">SELECT COUNT(*),location_id</span><br><span class="line">FROM departments</span><br><span class="line">GROUP BY location_id;</span><br></pre></td></tr></table></figure><ul><li>分组前的筛选</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在分组前用where关键字</span><br><span class="line"># 案例3：查询邮箱中包含a字符的，每个部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE email like &#x27;%a%&#x27;</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 案例4：查询有奖金的每个领导的手下员工的最高工资</span><br><span class="line">SELECT MAX(salary),manager_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY manager</span><br></pre></td></tr></table></figure><ul><li>分组后的筛选</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">在分组查询后用having关键词取代where</span><br><span class="line"># 案例5：查询哪个部门的员工个数&gt;2</span><br><span class="line">SELECT COUNT(*),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING COUNT(*)&gt;2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 案例6：查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</span><br><span class="line">SELECT MAX(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BU job_id</span><br><span class="line">HAVING MAX(salary)&gt;12000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 案例7：查询领导编号&gt;102的每个领导手下的员工最低工资&gt;5000的领导编号，以及其最低工资</span><br><span class="line">SELECT MIN(salary),manager_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE manager_id&gt;102</span><br><span class="line">GROUP BY manager_id</span><br><span class="line">HAVING MIN(salary)&gt;5000</span><br></pre></td></tr></table></figure><ul><li>按表达式或函数分组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 案例8：按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数大于5的有哪些</span><br><span class="line">SELECT COUNT(*)</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY LENGTH(last_name)</span><br><span class="line">HAVING COUNT(*)&gt;5;</span><br></pre></td></tr></table></figure><ul><li>按多个字段分组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 案例9：查询每个部门每个工种的员工的平均工资</span><br><span class="line">SELECT AVG(salary),department_id,job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id,job_id;</span><br><span class="line">#将department_id和job_id一致的分成一组</span><br></pre></td></tr></table></figure><ul><li>添加排序</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 案例10：查询每个部门每个工种的员工的平均工资，并且按平均工资降序显示</span><br><span class="line">SELECT AVG(salary),department_id,job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id,job_id</span><br><span class="line">ORDER BY AVG(salary) DESC;</span><br></pre></td></tr></table></figure><h4 id="连接查询-多表查询"><a href="#连接查询-多表查询" class="headerlink" title="连接查询&#x2F;多表查询"></a>连接查询&#x2F;多表查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">当查询的字段来涉及个表时，就需要用到连接查询</span><br><span class="line">按年代分类：</span><br><span class="line">  sql92标准：只支持内连接</span><br><span class="line">  sql99标准：支持内连接+外连接（左外+右外）+交叉连接</span><br><span class="line">按功能分类：</span><br><span class="line">  内连接：</span><br><span class="line">    等值连接</span><br><span class="line">    非等值连接</span><br><span class="line">    自连接</span><br><span class="line">  外连接：</span><br><span class="line">    左外连接</span><br><span class="line">    右外连接</span><br><span class="line">    全外连接</span><br><span class="line">  交叉连接</span><br></pre></td></tr></table></figure><h5 id="sql92标准"><a href="#sql92标准" class="headerlink" title="sql92标准"></a>sql92标准</h5><h6 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h6><ul><li>等值连接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询女生名和对应的男生名</span><br><span class="line">SELECT girl_name,boy_name</span><br><span class="line">FROM boys,girls</span><br><span class="line">WHERE girls.boyfriend_id=boys.id;</span><br><span class="line"># 用表名限定字段</span><br><span class="line"># 表的先后顺序没有要求</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 案例2：查询员工名和对应的部门名</span><br><span class="line">SELECT name,department_name</span><br><span class="line">FROM employees,departments</span><br><span class="line">WHERE employees.department_id=departments.id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 案例3：查询员工名，工种号，工种名</span><br><span class="line">SELECT name,e.job_id,job_name</span><br><span class="line">FROM employees e,jobs j</span><br><span class="line">WHERE e.job_id=j.id;</span><br><span class="line"># 为表起别名，起了别名后不能再用原名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加筛选</span><br><span class="line"># 案例4：查询有奖金的员工名、部门名</span><br><span class="line">SELECT name,department_name</span><br><span class="line">FROM employees e, departments d</span><br><span class="line">WHERE e.department_id=d.id</span><br><span class="line">AND e.commission_pct IS NOT NULL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 案例5：查询位置名中第二个字符为o的部门名和位置名</span><br><span class="line">SELECT department_name, location_name</span><br><span class="line">FROM departments d, locations l</span><br><span class="line">WHERE d.location_id=l.location_name</span><br><span class="line">AND l.location_name LIKE &#x27;_o%&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加分组</span><br><span class="line"># 案例6：查询每个城市的部门个数和城市名</span><br><span class="line">SELECT COUNT(*),city</span><br><span class="line">FROM departments d, citys c</span><br><span class="line">WHERE d.city_id=c.id;</span><br><span class="line">GROUP BY city;        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 案例7：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资</span><br><span class="line">SELECT department_name, d.manager_id, MIN(salary)</span><br><span class="line">FROM departments d, employees e</span><br><span class="line">WHERE e.department_id=d.id</span><br><span class="line">AND commission_pct IS NOT NULL</span><br><span class="line">GROUP BY department_name, d.manager_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加排序</span><br><span class="line"># 案例8：查询每个工种的工种名和员工的个数，并且按员工个数降序</span><br><span class="line">SELECT job_name, COUNT(*)</span><br><span class="line">FROM jobs j, employees e</span><br><span class="line">WHERE e.job_id=j.id</span><br><span class="line">GROUP BY job_name</span><br><span class="line">ORDER BY COUNT(*) DESC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 实现三表连接</span><br><span class="line"># 案例9：查询员工名、部门名和所在的城市</span><br><span class="line">SELECT name，department_name, city</span><br><span class="line">FROM employees e, departments d, citys c</span><br><span class="line">WHERE e.department_id=d.id</span><br><span class="line">AND d.city_id=c.id</span><br></pre></td></tr></table></figure><ul><li>非等值连接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询员工的工资和工资级别</span><br><span class="line">SELECT salary, grade_level</span><br><span class="line">FROM employees e, job_grades g</span><br><span class="line">WHERE salary BETWEEN g.lowest_sal AND g.highest_sal;</span><br></pre></td></tr></table></figure><ul><li>自连接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">把一张表当作多张表来用</span><br><span class="line"># 案例1：查询员工名和上级的名称</span><br><span class="line">SELECT e.name, m.name</span><br><span class="line">FROM employees e, employees m</span><br><span class="line">WHERE e.manager_id=m.employee_id;</span><br></pre></td></tr></table></figure><h5 id="sql99标准-推荐"><a href="#sql99标准-推荐" class="headerlink" title="sql99标准(推荐)"></a>sql99标准(推荐)</h5><ul><li>语法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT 查询列表</span><br><span class="line">FROM 表1 别名 </span><br><span class="line">[连接类型] JOIN 表2 别名 []</span><br><span class="line">ON 连续条件</span><br><span class="line">WHERE 筛选条件</span><br><span class="line">关键字：</span><br><span class="line">1、using</span><br><span class="line">用法类似与on</span><br><span class="line">using(id)等价于on a.id=b.id</span><br><span class="line">连接类型：</span><br><span class="line">inner 内连接</span><br><span class="line">left[outer] 左外连接</span><br><span class="line">right[outer] 右外连接</span><br><span class="line">full[outer] 全外连接 (mysql不支持)</span><br><span class="line">cross 交叉连接</span><br></pre></td></tr></table></figure><h6 id="内连接-1"><a href="#内连接-1" class="headerlink" title="内连接"></a>内连接</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">1、inner可以省略</span><br><span class="line">2、筛选条件放在where后面，连接条件放在on后面</span><br><span class="line">3、查询多表的交集部分</span><br></pre></td></tr></table></figure><ul><li>语法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT 查询列表</span><br><span class="line">FROM 表1 别名</span><br><span class="line">INNER JOIN 表2 别名</span><br><span class="line">ON 连接条件</span><br></pre></td></tr></table></figure><ul><li>等值连接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询员工名、部门名</span><br><span class="line">SELECT name, department_name</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departments d</span><br><span class="line">ON e.department=d.id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加筛选</span><br><span class="line"># 案例2：查询名字中包含e的员工名和工种名</span><br><span class="line">SELECT name, job_name</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN jobs j</span><br><span class="line">ON e.job_id=j.id</span><br><span class="line">WHERE name LIKE &#x27;%e%&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加分组</span><br><span class="line"># 案例3：查询部门个数&gt;3的城市名和部门个数</span><br><span class="line">SELECT city_name, COUNT(*)</span><br><span class="line">FROM departments d</span><br><span class="line">INNNER JOIN citys c</span><br><span class="line">ON d.city_id=c.city_name     </span><br><span class="line">GROUP BY c.city_name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加排序</span><br><span class="line"># 案例4：查询员工个数&gt;3的部门名和员工个数，并按个数降序</span><br><span class="line">SELECT department_name, e.COUNT(*)</span><br><span class="line">FROM department d</span><br><span class="line">INNER JOIN employees e</span><br><span class="line">ON e.department_id=d.id</span><br><span class="line">HAVING e.COUNT(*)&gt;3</span><br><span class="line">GROUP BY department_name</span><br><span class="line">ORDER BY e.COUNT(*) DESC;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 三表连接</span><br><span class="line"># 案例5：查询员工名、部门名、工种名并按部门名降序</span><br><span class="line">SELECT name, department_name, job_name</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departments d</span><br><span class="line">ON e.department_i=d.id</span><br><span class="line">INNER JOIN jobs j</span><br><span class="line">ON e.job_id=j.id </span><br><span class="line">ORDER BY department_name DESC;                      </span><br></pre></td></tr></table></figure><ul><li>非等值连接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询员工的工资级别</span><br><span class="line">SELECT salary, grade_level</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN job_grades g</span><br><span class="line">ON e.salary BETWEEN g.lowest_sal AND g.highest_sal;</span><br></pre></td></tr></table></figure><ul><li>自连接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询员工的名字、上级的名字</span><br><span class="line">SELECT e.name, m.name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN employees m</span><br><span class="line">ON e.manager_id=m.id;</span><br></pre></td></tr></table></figure><h6 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">1、外连接的查询结果为主表中的所有记录，与副表中符合连接条件的记录。</span><br><span class="line">2、左外连接，left左边的是主表</span><br><span class="line">   右外连接，right右边的是主表</span><br></pre></td></tr></table></figure><ul><li>左(右)外连接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 案例1 ：查询男朋友不在男生表的女生</span><br><span class="line"># 左外</span><br><span class="line">SELECT b.name, g.name</span><br><span class="line">FROM girls g</span><br><span class="line">LEFT OUTER JOIN boys b</span><br><span class="line">ON g.boyfriend_id=b.id</span><br><span class="line">[WHERE b.id IS NULL] </span><br><span class="line"># 只显示没有男朋友的女生</span><br><span class="line"></span><br><span class="line"># 右外</span><br><span class="line">SELECT b.name, g.name</span><br><span class="line">FROM boys b</span><br><span class="line">RIGHT OUTER JOIN girls g</span><br><span class="line">ON g.boyfriend_id=b.id</span><br></pre></td></tr></table></figure><ul><li>全外连接(mysql不支持)</li></ul><h6 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查询结果是笛卡尔乘积</span><br></pre></td></tr></table></figure><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">含义：出现在其他语句中的select语句，称为子查询或内查询</span><br><span class="line">      外部的查询语句称为主查询或外查询</span><br><span class="line">分类：</span><br><span class="line">按结果集的行列数不同：</span><br><span class="line">  标量子查询（结果集只有一行一列）</span><br><span class="line">  列子查询（结果集只有一列多行）</span><br><span class="line">  行子查询（结果集只有一行多列）</span><br><span class="line">  表子查询（一般情况）</span><br><span class="line">按子查询出现的位置：</span><br><span class="line">  select后：仅支持标量子查询</span><br><span class="line">  from后：仅支持表子查询</span><br><span class="line">  where或having后：标量子查询、列(行)子查询</span><br><span class="line">  exists后（相关子查询）：表子查询</span><br></pre></td></tr></table></figure><h5 id="where或having后面"><a href="#where或having后面" class="headerlink" title="where或having后面"></a>where或having后面</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">1、子查询放在小括号内</span><br><span class="line">2、子查询一般放在条件的右侧</span><br><span class="line">3、标量子查询，一般搭配着单行操作符使用 &lt;  &gt;  &gt;=  &lt;=  &lt;&gt;  =</span><br><span class="line">4、列子查询，一般搭配多行操作符使用  in、any/some、all</span><br></pre></td></tr></table></figure><h6 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：谁的工资比Abel高</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&gt;(</span><br><span class="line">    SELECT salary</span><br><span class="line">    FROM employees </span><br><span class="line">    WHERE name=&#x27;Abel&#x27;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 案例2：返回job_id与141号员工相同，salary 比143号员工多的员工 姓名，job_id和工资</span><br><span class="line">SELECT name, job_id, salary</span><br><span class="line">FROM employees e</span><br><span class="line">WHERE e.job_id=(</span><br><span class="line">    SELECT job_id</span><br><span class="line">    FROM employees</span><br><span class="line">    WHERE employee_id=141</span><br><span class="line">)</span><br><span class="line">AND salary&gt;(</span><br><span class="line">    SELECT salary</span><br><span class="line">    FROM employees</span><br><span class="line">    WHERE employee_id=143</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h6 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">1、返回多行</span><br><span class="line">2、需要配合多行比较操作符来使用：</span><br><span class="line">in/not in</span><br><span class="line">any/some</span><br><span class="line">all</span><br><span class="line"># 案例1：返回loaction_id是1400或1700的部门中的所有员工姓名</span><br><span class="line">select name</span><br><span class="line">from employees</span><br><span class="line">where department_id in(</span><br><span class="line">    select distinct department_id</span><br><span class="line">    from department</span><br><span class="line">    where location_id in(1400,1700)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 案例2：返回其它工种中比job_id为`IT_PROG`工种所有员工的工资都要低的员工的员工号、姓名</span><br><span class="line">select id,name</span><br><span class="line">from employees</span><br><span class="line">where salary &lt; all(  # min</span><br><span class="line">    select distinct salary </span><br><span class="line">    from employees</span><br><span class="line">    where job_id = &#x27;IT_PROG&#x27;</span><br><span class="line">) and job_id != &#x27;IT_PROG&#x27;;</span><br></pre></td></tr></table></figure><h6 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">特点：返回一行多列</span><br><span class="line"># 案例1：查询员工编号最少并且工资最高的员工信息</span><br><span class="line">select *</span><br><span class="line">from employees</span><br><span class="line">where (employee_id,salary)=(</span><br><span class="line">    select min(employee_id),max(salary)</span><br><span class="line">    from employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="select后面"><a href="#select后面" class="headerlink" title="select后面"></a>select后面</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">特点：只支持一行一列（标量子查询）</span><br><span class="line"># 案例1：查询每个部门的员工的个数</span><br><span class="line">select e.*,(</span><br><span class="line">    select count(*)</span><br><span class="line">    from employees e</span><br><span class="line">    where e.department_id=d.department_id</span><br><span class="line">) 个数</span><br><span class="line">from department d;</span><br></pre></td></tr></table></figure><h5 id="from后面"><a href="#from后面" class="headerlink" title="from后面"></a>from后面</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">特点：将select返回的结果当作表（数据源）来使用</span><br><span class="line">必须起别名</span><br><span class="line"># 案例1、查询每个部门的平均工资的工资等级</span><br><span class="line">select ag_dep.*, grade.level</span><br><span class="line">from(</span><br><span class="line">   select avg(salary) ag ,department_id</span><br><span class="line">   from employees</span><br><span class="line">   group by department_id</span><br><span class="line">) ag_dep</span><br><span class="line">inner join job_grades g</span><br><span class="line">on ag_dep.ag between lowest_sal and highest_sal;</span><br></pre></td></tr></table></figure><h5 id="exists后面（相关子查询）"><a href="#exists后面（相关子查询）" class="headerlink" title="exists后面（相关子查询）"></a>exists后面（相关子查询）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">exists语法：</span><br><span class="line">exists(完整的查询语句)</span><br><span class="line">结果：1或0</span><br><span class="line"># 案例1：查询有员工的部门名</span><br><span class="line">select department_name</span><br><span class="line">from departments d</span><br><span class="line">where exists(</span><br><span class="line">    select *</span><br><span class="line">    from employees e</span><br><span class="line">    where d.department_id=e.department_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">limit语句放在查询语句的最后</span><br><span class="line"></span><br><span class="line">如果要显示的页数为pages，每页的条目数为size</span><br><span class="line">则可以写为limit (page-1)*size,size;</span><br></pre></td></tr></table></figure><ul><li>语法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表1</span><br><span class="line">[join type join 表2</span><br><span class="line">on 连接条件</span><br><span class="line">where 筛选条件</span><br><span class="line">group by 分组字段</span><br><span class="line">having 分组后的筛选</span><br><span class="line">order by 排序的字段]</span><br><span class="line">limit 分页语句;</span><br><span class="line">limit后分页条件有两种：</span><br><span class="line">  1、limit后跟着两个数字（只有一个数字时默认第一个数字为0）：</span><br><span class="line">    limit 1,3;</span><br><span class="line">    表示查询3条数据，跳过1条数据（即查询2，3，4）</span><br><span class="line">  2、limit和offset关键字组合使用：</span><br><span class="line">    limit 5 offset 4;</span><br><span class="line">    表示查询5条数据，跳过4条（即查询5，6，7，8，9）</span><br></pre></td></tr></table></figure><ul><li>案例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询前五条员工信息</span><br><span class="line">select * from employees limit 0,5;</span><br><span class="line">select * from employees limit 5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 案例2：查询第11条到第25条</span><br><span class="line">select * from employees limit 10,15;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 案例3：查询有奖金的前十名员工的信息</span><br><span class="line">select * </span><br><span class="line">from employees </span><br><span class="line">where commission_pct is not null</span><br><span class="line">order by salary desc</span><br><span class="line">limit 10;</span><br></pre></td></tr></table></figure><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">应用场景：</span><br><span class="line">当要查询的结果来自多个表，且多个表没有直接的连接关系，但是查询的信息一致</span><br></pre></td></tr></table></figure><ul><li>语法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查询语句1</span><br><span class="line">union</span><br><span class="line">查询语句2</span><br><span class="line">union</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h2 id="DML增删改"><a href="#DML增删改" class="headerlink" title="DML增删改"></a>DML增删改</h2><h4 id="插入语句"><a href="#插入语句" class="headerlink" title="插入语句"></a>插入语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、插入的值的类型要与列的类型一致或兼容</span><br><span class="line">2、为nullable的列插入null的方法：</span><br><span class="line">   ①列名对应的值为null</span><br><span class="line">   ②不写列名和值</span><br><span class="line">3、列的顺序可以调换</span><br><span class="line">4、列名的个数必须与值的个数保持一致</span><br><span class="line">5、可以省略列名，默认所有列，并且列的顺序和表中列的顺序一致</span><br></pre></td></tr></table></figure><ul><li>语法1</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 (列名) value(值);</span><br></pre></td></tr></table></figure><ul><li>语法2</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名</span><br><span class="line">set 列名1=值1, 列名2=值2;</span><br><span class="line">两种插入方式的比较：</span><br><span class="line">1、方式一支持插入多行，方式二不支持</span><br><span class="line">2、方式一支持子查询，方式二不支持</span><br></pre></td></tr></table></figure><h4 id="修改语句"><a href="#修改语句" class="headerlink" title="修改语句"></a>修改语句</h4><h5 id="单表修改"><a href="#单表修改" class="headerlink" title="单表修改"></a>单表修改</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update 表名</span><br><span class="line">set 字段=值,...</span><br><span class="line">where 筛选条件</span><br></pre></td></tr></table></figure><h5 id="联表修改"><a href="#联表修改" class="headerlink" title="联表修改"></a>联表修改</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update 表1 别名</span><br><span class="line">inner|left|right join 表2 别名</span><br><span class="line">on 连接条件</span><br><span class="line">set 字段=值,...</span><br><span class="line">where 筛选条件</span><br></pre></td></tr></table></figure><h4 id="删除语句"><a href="#删除语句" class="headerlink" title="删除语句"></a>删除语句</h4><h5 id="单表删除"><a href="#单表删除" class="headerlink" title="单表删除"></a>单表删除</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 where 筛选条件</span><br><span class="line"># 不指定where则s</span><br></pre></td></tr></table></figure><h5 id="联表删除"><a href="#联表删除" class="headerlink" title="联表删除"></a>联表删除</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delete 别名</span><br><span class="line">from 表1名 别名</span><br><span class="line">inner|left|right join 表2 别名</span><br><span class="line">on 连接条件</span><br><span class="line">where 筛选条件</span><br></pre></td></tr></table></figure><h5 id="truncate清空表中的数据"><a href="#truncate清空表中的数据" class="headerlink" title="truncate清空表中的数据"></a>truncate清空表中的数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">truncate [table] 表名;</span><br><span class="line"># 关键词table可以省略</span><br></pre></td></tr></table></figure><p>区别：</p><p>1、truncate清空整个表，属于DDL语句，不能回滚</p><p>2、delete删除不会清除自增的数据</p><h2 id="DDL数据定义语句"><a href="#DDL数据定义语句" class="headerlink" title="DDL数据定义语句"></a>DDL数据定义语句</h2><h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><h5 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create database 库名;</span><br><span class="line"># 如果库已经存在会报错</span><br><span class="line">create database if not exists 库名;</span><br><span class="line"># 如果不存在则创建，存在不会报错</span><br></pre></td></tr></table></figure><h5 id="修改库字符集"><a href="#修改库字符集" class="headerlink" title="修改库字符集"></a>修改库字符集</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database 库名 character set 字符集名;</span><br></pre></td></tr></table></figure><h5 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drop database 库名;</span><br><span class="line"># 如果库不存在会报错</span><br><span class="line">drop database if exists 库名;</span><br><span class="line"># 如果存在则创建，不存在不会报错</span><br></pre></td></tr></table></figure><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">字段名 字段的类型 [(长度) 约束],</span><br><span class="line">字段名 字段的类型 [(长度) 约束],</span><br><span class="line">...</span><br><span class="line">字段名 字段的类型 [(长度) 约束]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 修改字段名 字段的类型 [(长度) 约束]</span><br><span class="line">alter table 表名 change [column] 原字段名 [新字段名] 字段类型;</span><br><span class="line"># 修改字段类型</span><br><span class="line">alter table 表名 modify [column] 字段名 新字段类型 [新约束];</span><br><span class="line"># 添加字段</span><br><span class="line">alter table 表名 add 字段名 字段的类型 [(长度) 约束];</span><br><span class="line"># 删除字段</span><br><span class="line">alter table 表名 drop [column] 字段名;</span><br><span class="line"># 修改表名</span><br><span class="line">alter table 表名 rename to 新表名;</span><br></pre></td></tr></table></figure><h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table [if exists] book_author;</span><br></pre></td></tr></table></figure><h5 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 复制结构</span><br><span class="line">create table 新表名 like 原表名;</span><br><span class="line"># 复制结构+全部数据</span><br><span class="line">create table 新表名 select * from 旧表名;</span><br><span class="line"># 复制部分结构+部分数据</span><br><span class="line">create table 新表名 select [字段名] from 旧表名 [条件语句];</span><br></pre></td></tr></table></figure><h2 id="存储过程（procedure）"><a href="#存储过程（procedure）" class="headerlink" title="存储过程（procedure）"></a>存储过程（procedure）</h2><p>存储过程是<strong>一组为了完成特定功能的SQL语句集合</strong>。使用存储过程的目的是<strong>将常用或复杂的工作预先用SQL语句写好并用一个指定名称存储起来</strong>，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需用 <code>CALL</code> 调用这个存储过程即可。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...) </span><br><span class="line">BEGIN</span><br><span class="line">存储过程体 </span><br><span class="line">END</span><br></pre></td></tr></table></figure><blockquote><p><code>delimiter</code> 命令：</p><p>在 MySQL 中，服务器处理 SQL 语句默认是以分号作为语句结束标志的。然而，在创建存储过程时，存储过程体可能包含有多条 SQL 语句，这些 SQL 语句如果仍以分号作为语句结束符，那么 MySQL 服务器在处理时会以遇到的第一条 SQL 语句结尾处的分号作为整个程序的结束符，而不再去处理存储过程体中后面的 SQL 语句，这样显然不行。为解决这个问题，通常可使用 DELIMITER 命令将结束命令修改为其他字符。在创建存储过程最后的 end 后写上修改的结束符，表示语句结束。</p><p><code>delimiter //</code> 将结束符修改为&#x2F;&#x2F;</p><p><code>delimiter ;</code> 将结束符修改为;</p></blockquote><h4 id="例：创建不带参数的存储过程"><a href="#例：创建不带参数的存储过程" class="headerlink" title="例：创建不带参数的存储过程"></a>例：创建不带参数的存储过程</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">delimiter //</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">create procedure <span class="built_in">test</span>()</span></span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt; update t_user set c_name = &quot;hello&quot; where id = 1;</span><br><span class="line">    -&gt; end //</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">delimiter ;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用存储过程</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">call <span class="built_in">test</span>;</span></span><br></pre></td></tr></table></figure><h4 id="例：创建带参数的存储过程"><a href="#例：创建带参数的存储过程" class="headerlink" title="例：创建带参数的存储过程"></a>例：创建带参数的存储过程</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">delimiter //</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">create procedure <span class="built_in">test</span></span></span><br><span class="line">    -&gt; (IN name varchar(30))</span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt; update t_user set c_name = name where id = 1;</span><br><span class="line">    -&gt; end //</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">delimiter ;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用存储过程</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">call <span class="built_in">test</span>(<span class="string">&#x27;hello&#x27;</span>)</span></span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">drop procudure <span class="built_in">test</span>;</span></span><br></pre></td></tr></table></figure><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有存储过程</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show procedure status;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看指定存储过程</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show procedure status like 存储过程名;</span></span><br></pre></td></tr></table></figure><blockquote><p>参考</p><p>[MySQL之存储过程（PROCEDURE） - 菜菜成长记 - 博客园 (cnblogs.com)](</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
